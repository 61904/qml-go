// ** file automatically generated by glgen -- do not edit manually **

package GL

// #cgo CXXFLAGS: -std=c++0x -pedantic-errors -Wall -fno-strict-aliasing
// #cgo LDFLAGS: -lstdc++
// #cgo pkg-config: Qt5Core Qt5OpenGL
//
// #include "funcs.h"
//
// void free(void*);
//
import "C"

import (
	"fmt"
	"reflect"
	"unsafe"

	"gopkg.in/qml.v1/gl/glbase"
)

// API returns a value that offers methods matching the OpenGL version 4.3 API.
//
// The returned API must not be used after the provided OpenGL context becomes invalid.
func API(context glbase.Contexter) *GL {
	gl := &GL{}
	gl.funcs = C.gl4_3core_funcs()
	if gl.funcs == nil {
		panic(fmt.Errorf("OpenGL version 4.3 is not available"))
	}
	return gl
}

// GL implements the OpenGL version 4.3 API. Values of this
// type must be created via the API function, and it must not be used after
// the associated OpenGL context becomes invalid.
type GL struct {
	funcs unsafe.Pointer
}

const (
	NONE = 0

	BYTE           = 0x1400
	UNSIGNED_BYTE  = 0x1401
	SHORT          = 0x1402
	UNSIGNED_SHORT = 0x1403
	INT            = 0x1404
	UNSIGNED_INT   = 0x1405
	FLOAT          = 0x1406
	DOUBLE         = 0x140A
	HALF_FLOAT     = 0x140B

	COLOR_BUFFER_BIT   = 0x00004000
	DEPTH_BUFFER_BIT   = 0x00000100
	STENCIL_BUFFER_BIT = 0x00000400

	ALWAYS   = 0x0207
	EQUAL    = 0x0202
	GEQUAL   = 0x0206
	GREATER  = 0x0204
	LEQUAL   = 0x0203
	LESS     = 0x0201
	NEVER    = 0x0200
	NOTEQUAL = 0x0205

	DST_ALPHA           = 0x0304
	ONE                 = 1
	ONE_MINUS_DST_ALPHA = 0x0305
	ONE_MINUS_SRC_ALPHA = 0x0303
	ONE_MINUS_SRC_COLOR = 0x0301
	SRC_ALPHA           = 0x0302
	SRC_COLOR           = 0x0300
	ZERO                = 0

	DST_COLOR           = 0x0306
	ONE_MINUS_DST_COLOR = 0x0307
	SRC_ALPHA_SATURATE  = 0x0308

	CLIP_DISTANCE0 = 0x3000
	CLIP_DISTANCE1 = 0x3001
	CLIP_DISTANCE2 = 0x3002
	CLIP_DISTANCE3 = 0x3003
	CLIP_DISTANCE4 = 0x3004
	CLIP_DISTANCE5 = 0x3005
	CLIP_DISTANCE6 = 0x3006
	CLIP_DISTANCE7 = 0x3007

	BACK           = 0x0405
	FRONT          = 0x0404
	FRONT_AND_BACK = 0x0408

	CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT = 0x00000001

	CONTEXT_COMPATIBILITY_PROFILE_BIT = 0x00000002
	CONTEXT_CORE_PROFILE_BIT          = 0x00000001

	BACK_LEFT   = 0x0402
	BACK_RIGHT  = 0x0403
	FRONT_LEFT  = 0x0400
	FRONT_RIGHT = 0x0401
	LEFT        = 0x0406
	RIGHT       = 0x0407

	BLEND                = 0x0BE2
	COLOR_LOGIC_OP       = 0x0BF2
	CULL_FACE            = 0x0B44
	DEPTH_TEST           = 0x0B71
	DITHER               = 0x0BD0
	LINE_SMOOTH          = 0x0B20
	POLYGON_OFFSET_FILL  = 0x8037
	POLYGON_OFFSET_LINE  = 0x2A02
	POLYGON_OFFSET_POINT = 0x2A01
	POLYGON_SMOOTH       = 0x0B41
	SCISSOR_TEST         = 0x0C11
	STENCIL_TEST         = 0x0B90
	TEXTURE_1D           = 0x0DE0
	TEXTURE_2D           = 0x0DE1

	INVALID_ENUM                  = 0x0500
	INVALID_FRAMEBUFFER_OPERATION = 0x0506
	INVALID_OPERATION             = 0x0502
	INVALID_VALUE                 = 0x0501
	NO_ERROR                      = 0
	OUT_OF_MEMORY                 = 0x0505
	STACK_OVERFLOW                = 0x0503
	STACK_UNDERFLOW               = 0x0504

	LINEAR = 0x2601

	CCW = 0x0901
	CW  = 0x0900

	ALIASED_LINE_WIDTH_RANGE      = 0x846E
	BLEND_DST                     = 0x0BE0
	BLEND_SRC                     = 0x0BE1
	COLOR_CLEAR_VALUE             = 0x0C22
	COLOR_WRITEMASK               = 0x0C23
	CULL_FACE_MODE                = 0x0B45
	DEPTH_CLEAR_VALUE             = 0x0B73
	DEPTH_FUNC                    = 0x0B74
	DEPTH_RANGE                   = 0x0B70
	DEPTH_WRITEMASK               = 0x0B72
	DOUBLEBUFFER                  = 0x0C32
	DRAW_BUFFER                   = 0x0C01
	FRONT_FACE                    = 0x0B46
	LINE_SMOOTH_HINT              = 0x0C52
	LINE_WIDTH                    = 0x0B21
	LINE_WIDTH_GRANULARITY        = 0x0B23
	LINE_WIDTH_RANGE              = 0x0B22
	LOGIC_OP_MODE                 = 0x0BF0
	MAX_CLIP_DISTANCES            = 0x0D32
	MAX_TEXTURE_SIZE              = 0x0D33
	MAX_VIEWPORT_DIMS             = 0x0D3A
	PACK_ALIGNMENT                = 0x0D05
	PACK_LSB_FIRST                = 0x0D01
	PACK_ROW_LENGTH               = 0x0D02
	PACK_SKIP_PIXELS              = 0x0D04
	PACK_SKIP_ROWS                = 0x0D03
	PACK_SWAP_BYTES               = 0x0D00
	POINT_SIZE                    = 0x0B11
	POINT_SIZE_GRANULARITY        = 0x0B13
	POINT_SIZE_RANGE              = 0x0B12
	POLYGON_MODE                  = 0x0B40
	POLYGON_OFFSET_FACTOR         = 0x8038
	POLYGON_OFFSET_UNITS          = 0x2A00
	POLYGON_SMOOTH_HINT           = 0x0C53
	READ_BUFFER                   = 0x0C02
	SCISSOR_BOX                   = 0x0C10
	SMOOTH_LINE_WIDTH_GRANULARITY = 0x0B23
	SMOOTH_LINE_WIDTH_RANGE       = 0x0B22
	SMOOTH_POINT_SIZE_GRANULARITY = 0x0B13
	SMOOTH_POINT_SIZE_RANGE       = 0x0B12
	STENCIL_CLEAR_VALUE           = 0x0B91
	STENCIL_FAIL                  = 0x0B94
	STENCIL_FUNC                  = 0x0B92
	STENCIL_PASS_DEPTH_FAIL       = 0x0B95
	STENCIL_PASS_DEPTH_PASS       = 0x0B96
	STENCIL_REF                   = 0x0B97
	STENCIL_VALUE_MASK            = 0x0B93
	STENCIL_WRITEMASK             = 0x0B98
	STEREO                        = 0x0C33
	SUBPIXEL_BITS                 = 0x0D50
	TEXTURE_BINDING_1D            = 0x8068
	TEXTURE_BINDING_2D            = 0x8069
	TEXTURE_BINDING_3D            = 0x806A
	UNPACK_ALIGNMENT              = 0x0CF5
	UNPACK_LSB_FIRST              = 0x0CF1
	UNPACK_ROW_LENGTH             = 0x0CF2
	UNPACK_SKIP_PIXELS            = 0x0CF4
	UNPACK_SKIP_ROWS              = 0x0CF3
	UNPACK_SWAP_BYTES             = 0x0CF0
	VIEWPORT                      = 0x0BA2

	TEXTURE_ALPHA_SIZE      = 0x805F
	TEXTURE_BLUE_SIZE       = 0x805E
	TEXTURE_BORDER_COLOR    = 0x1004
	TEXTURE_GREEN_SIZE      = 0x805D
	TEXTURE_HEIGHT          = 0x1001
	TEXTURE_INTERNAL_FORMAT = 0x1003
	TEXTURE_MAG_FILTER      = 0x2800
	TEXTURE_MIN_FILTER      = 0x2801
	TEXTURE_RED_SIZE        = 0x805C
	TEXTURE_WIDTH           = 0x1000
	TEXTURE_WRAP_S          = 0x2802
	TEXTURE_WRAP_T          = 0x2803

	DONT_CARE = 0x1100
	FASTEST   = 0x1101
	NICEST    = 0x1102

	FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8B8B
	TEXTURE_COMPRESSION_HINT        = 0x84EF

	REPLACE = 0x1E01

	AND           = 0x1501
	AND_INVERTED  = 0x1504
	AND_REVERSE   = 0x1502
	CLEAR         = 0x1500
	COPY          = 0x1503
	COPY_INVERTED = 0x150C
	EQUIV         = 0x1509
	INVERT        = 0x150A
	NAND          = 0x150E
	NOOP          = 0x1505
	NOR           = 0x1508
	OR            = 0x1507
	OR_INVERTED   = 0x150D
	OR_REVERSE    = 0x150B
	SET           = 0x150F
	XOR           = 0x1506

	MAP_FLUSH_EXPLICIT_BIT    = 0x0010
	MAP_INVALIDATE_BUFFER_BIT = 0x0008
	MAP_INVALIDATE_RANGE_BIT  = 0x0004
	MAP_READ_BIT              = 0x0001
	MAP_UNSYNCHRONIZED_BIT    = 0x0020
	MAP_WRITE_BIT             = 0x0002

	TEXTURE = 0x1702

	LINE  = 0x1B01
	POINT = 0x1B00

	FILL = 0x1B02

	COLOR   = 0x1800
	DEPTH   = 0x1801
	STENCIL = 0x1802

	ALPHA           = 0x1906
	BLUE            = 0x1905
	DEPTH_COMPONENT = 0x1902
	GREEN           = 0x1904
	RED             = 0x1903
	RGB             = 0x1907
	RGBA            = 0x1908
	STENCIL_INDEX   = 0x1901

	R3_G3_B2 = 0x2A10
	RGB10    = 0x8052
	RGB10_A2 = 0x8059
	RGB12    = 0x8053
	RGB16    = 0x8054
	RGB4     = 0x804F
	RGB5     = 0x8050
	RGB5_A1  = 0x8057
	RGB8     = 0x8051
	RGBA12   = 0x805A
	RGBA16   = 0x805B
	RGBA2    = 0x8055
	RGBA4    = 0x8056
	RGBA8    = 0x8058

	PACK_IMAGE_HEIGHT   = 0x806C
	PACK_SKIP_IMAGES    = 0x806B
	UNPACK_IMAGE_HEIGHT = 0x806E
	UNPACK_SKIP_IMAGES  = 0x806D

	UNSIGNED_BYTE_3_3_2     = 0x8032
	UNSIGNED_INT_10_10_10_2 = 0x8036
	UNSIGNED_INT_8_8_8_8    = 0x8035
	UNSIGNED_SHORT_4_4_4_4  = 0x8033
	UNSIGNED_SHORT_5_5_5_1  = 0x8034

	POINT_FADE_THRESHOLD_SIZE = 0x8128

	LINES                    = 0x0001
	LINES_ADJACENCY          = 0x000A
	LINE_LOOP                = 0x0002
	LINE_STRIP               = 0x0003
	LINE_STRIP_ADJACENCY     = 0x000B
	POINTS                   = 0x0000
	TRIANGLES                = 0x0004
	TRIANGLES_ADJACENCY      = 0x000C
	TRIANGLE_FAN             = 0x0006
	TRIANGLE_STRIP           = 0x0005
	TRIANGLE_STRIP_ADJACENCY = 0x000D

	DECR = 0x1E03
	INCR = 0x1E02
	KEEP = 0x1E00

	EXTENSIONS = 0x1F03
	RENDERER   = 0x1F01
	VENDOR     = 0x1F00
	VERSION    = 0x1F02

	NEAREST = 0x2600

	LINEAR_MIPMAP_LINEAR   = 0x2703
	LINEAR_MIPMAP_NEAREST  = 0x2701
	NEAREST_MIPMAP_LINEAR  = 0x2702
	NEAREST_MIPMAP_NEAREST = 0x2700

	TEXTURE_WRAP_R = 0x8072

	PROXY_TEXTURE_1D   = 0x8063
	PROXY_TEXTURE_2D   = 0x8064
	PROXY_TEXTURE_3D   = 0x8070
	TEXTURE_3D         = 0x806F
	TEXTURE_BASE_LEVEL = 0x813C
	TEXTURE_MAX_LEVEL  = 0x813D
	TEXTURE_MAX_LOD    = 0x813B
	TEXTURE_MIN_LOD    = 0x813A

	CLAMP_TO_BORDER = 0x812D
	CLAMP_TO_EDGE   = 0x812F
	REPEAT          = 0x2901

	SYNC_FLUSH_COMMANDS_BIT                       = 0x00000001
	INVALID_INDEX                                 = 0xFFFFFFFF
	TIMEOUT_IGNORED                               = 0xFFFFFFFFFFFFFFFF
	CONSTANT_COLOR                                = 0x8001
	ONE_MINUS_CONSTANT_COLOR                      = 0x8002
	CONSTANT_ALPHA                                = 0x8003
	ONE_MINUS_CONSTANT_ALPHA                      = 0x8004
	FUNC_ADD                                      = 0x8006
	MIN                                           = 0x8007
	MAX                                           = 0x8008
	BLEND_EQUATION_RGB                            = 0x8009
	FUNC_SUBTRACT                                 = 0x800A
	FUNC_REVERSE_SUBTRACT                         = 0x800B
	TEXTURE_DEPTH                                 = 0x8071
	MAX_3D_TEXTURE_SIZE                           = 0x8073
	MULTISAMPLE                                   = 0x809D
	SAMPLE_ALPHA_TO_COVERAGE                      = 0x809E
	SAMPLE_ALPHA_TO_ONE                           = 0x809F
	SAMPLE_COVERAGE                               = 0x80A0
	SAMPLE_BUFFERS                                = 0x80A8
	SAMPLES                                       = 0x80A9
	SAMPLE_COVERAGE_VALUE                         = 0x80AA
	SAMPLE_COVERAGE_INVERT                        = 0x80AB
	BLEND_DST_RGB                                 = 0x80C8
	BLEND_SRC_RGB                                 = 0x80C9
	BLEND_DST_ALPHA                               = 0x80CA
	BLEND_SRC_ALPHA                               = 0x80CB
	BGR                                           = 0x80E0
	BGRA                                          = 0x80E1
	MAX_ELEMENTS_VERTICES                         = 0x80E8
	MAX_ELEMENTS_INDICES                          = 0x80E9
	DEPTH_COMPONENT16                             = 0x81A5
	DEPTH_COMPONENT24                             = 0x81A6
	DEPTH_COMPONENT32                             = 0x81A7
	FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING         = 0x8210
	FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE         = 0x8211
	FRAMEBUFFER_ATTACHMENT_RED_SIZE               = 0x8212
	FRAMEBUFFER_ATTACHMENT_GREEN_SIZE             = 0x8213
	FRAMEBUFFER_ATTACHMENT_BLUE_SIZE              = 0x8214
	FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE             = 0x8215
	FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE             = 0x8216
	FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE           = 0x8217
	FRAMEBUFFER_DEFAULT                           = 0x8218
	FRAMEBUFFER_UNDEFINED                         = 0x8219
	DEPTH_STENCIL_ATTACHMENT                      = 0x821A
	MAJOR_VERSION                                 = 0x821B
	MINOR_VERSION                                 = 0x821C
	NUM_EXTENSIONS                                = 0x821D
	CONTEXT_FLAGS                                 = 0x821E
	INDEX                                         = 0x8222
	COMPRESSED_RED                                = 0x8225
	COMPRESSED_RG                                 = 0x8226
	RG                                            = 0x8227
	RG_INTEGER                                    = 0x8228
	R8                                            = 0x8229
	R16                                           = 0x822A
	RG8                                           = 0x822B
	RG16                                          = 0x822C
	R16F                                          = 0x822D
	R32F                                          = 0x822E
	RG16F                                         = 0x822F
	RG32F                                         = 0x8230
	R8I                                           = 0x8231
	R8UI                                          = 0x8232
	R16I                                          = 0x8233
	R16UI                                         = 0x8234
	R32I                                          = 0x8235
	R32UI                                         = 0x8236
	RG8I                                          = 0x8237
	RG8UI                                         = 0x8238
	RG16I                                         = 0x8239
	RG16UI                                        = 0x823A
	RG32I                                         = 0x823B
	RG32UI                                        = 0x823C
	UNSIGNED_BYTE_2_3_3_REV                       = 0x8362
	UNSIGNED_SHORT_5_6_5                          = 0x8363
	UNSIGNED_SHORT_5_6_5_REV                      = 0x8364
	UNSIGNED_SHORT_4_4_4_4_REV                    = 0x8365
	UNSIGNED_SHORT_1_5_5_5_REV                    = 0x8366
	UNSIGNED_INT_8_8_8_8_REV                      = 0x8367
	UNSIGNED_INT_2_10_10_10_REV                   = 0x8368
	MIRRORED_REPEAT                               = 0x8370
	TEXTURE0                                      = 0x84C0
	TEXTURE1                                      = 0x84C1
	TEXTURE2                                      = 0x84C2
	TEXTURE3                                      = 0x84C3
	TEXTURE4                                      = 0x84C4
	TEXTURE5                                      = 0x84C5
	TEXTURE6                                      = 0x84C6
	TEXTURE7                                      = 0x84C7
	TEXTURE8                                      = 0x84C8
	TEXTURE9                                      = 0x84C9
	TEXTURE10                                     = 0x84CA
	TEXTURE11                                     = 0x84CB
	TEXTURE12                                     = 0x84CC
	TEXTURE13                                     = 0x84CD
	TEXTURE14                                     = 0x84CE
	TEXTURE15                                     = 0x84CF
	TEXTURE16                                     = 0x84D0
	TEXTURE17                                     = 0x84D1
	TEXTURE18                                     = 0x84D2
	TEXTURE19                                     = 0x84D3
	TEXTURE20                                     = 0x84D4
	TEXTURE21                                     = 0x84D5
	TEXTURE22                                     = 0x84D6
	TEXTURE23                                     = 0x84D7
	TEXTURE24                                     = 0x84D8
	TEXTURE25                                     = 0x84D9
	TEXTURE26                                     = 0x84DA
	TEXTURE27                                     = 0x84DB
	TEXTURE28                                     = 0x84DC
	TEXTURE29                                     = 0x84DD
	TEXTURE30                                     = 0x84DE
	TEXTURE31                                     = 0x84DF
	ACTIVE_TEXTURE                                = 0x84E0
	MAX_RENDERBUFFER_SIZE                         = 0x84E8
	COMPRESSED_RGB                                = 0x84ED
	COMPRESSED_RGBA                               = 0x84EE
	TEXTURE_RECTANGLE                             = 0x84F5
	TEXTURE_BINDING_RECTANGLE                     = 0x84F6
	PROXY_TEXTURE_RECTANGLE                       = 0x84F7
	MAX_RECTANGLE_TEXTURE_SIZE                    = 0x84F8
	DEPTH_STENCIL                                 = 0x84F9
	UNSIGNED_INT_24_8                             = 0x84FA
	MAX_TEXTURE_LOD_BIAS                          = 0x84FD
	TEXTURE_LOD_BIAS                              = 0x8501
	INCR_WRAP                                     = 0x8507
	DECR_WRAP                                     = 0x8508
	TEXTURE_CUBE_MAP                              = 0x8513
	TEXTURE_BINDING_CUBE_MAP                      = 0x8514
	TEXTURE_CUBE_MAP_POSITIVE_X                   = 0x8515
	TEXTURE_CUBE_MAP_NEGATIVE_X                   = 0x8516
	TEXTURE_CUBE_MAP_POSITIVE_Y                   = 0x8517
	TEXTURE_CUBE_MAP_NEGATIVE_Y                   = 0x8518
	TEXTURE_CUBE_MAP_POSITIVE_Z                   = 0x8519
	TEXTURE_CUBE_MAP_NEGATIVE_Z                   = 0x851A
	PROXY_TEXTURE_CUBE_MAP                        = 0x851B
	MAX_CUBE_MAP_TEXTURE_SIZE                     = 0x851C
	SRC1_ALPHA                                    = 0x8589
	VERTEX_ARRAY_BINDING                          = 0x85B5
	VERTEX_ATTRIB_ARRAY_ENABLED                   = 0x8622
	VERTEX_ATTRIB_ARRAY_SIZE                      = 0x8623
	VERTEX_ATTRIB_ARRAY_STRIDE                    = 0x8624
	VERTEX_ATTRIB_ARRAY_TYPE                      = 0x8625
	CURRENT_VERTEX_ATTRIB                         = 0x8626
	VERTEX_PROGRAM_POINT_SIZE                     = 0x8642
	PROGRAM_POINT_SIZE                            = 0x8642
	VERTEX_ATTRIB_ARRAY_POINTER                   = 0x8645
	DEPTH_CLAMP                                   = 0x864F
	TEXTURE_COMPRESSED_IMAGE_SIZE                 = 0x86A0
	TEXTURE_COMPRESSED                            = 0x86A1
	NUM_COMPRESSED_TEXTURE_FORMATS                = 0x86A2
	COMPRESSED_TEXTURE_FORMATS                    = 0x86A3
	BUFFER_SIZE                                   = 0x8764
	BUFFER_USAGE                                  = 0x8765
	STENCIL_BACK_FUNC                             = 0x8800
	STENCIL_BACK_FAIL                             = 0x8801
	STENCIL_BACK_PASS_DEPTH_FAIL                  = 0x8802
	STENCIL_BACK_PASS_DEPTH_PASS                  = 0x8803
	RGBA32F                                       = 0x8814
	RGB32F                                        = 0x8815
	RGBA16F                                       = 0x881A
	RGB16F                                        = 0x881B
	MAX_DRAW_BUFFERS                              = 0x8824
	DRAW_BUFFER0                                  = 0x8825
	DRAW_BUFFER1                                  = 0x8826
	DRAW_BUFFER2                                  = 0x8827
	DRAW_BUFFER3                                  = 0x8828
	DRAW_BUFFER4                                  = 0x8829
	DRAW_BUFFER5                                  = 0x882A
	DRAW_BUFFER6                                  = 0x882B
	DRAW_BUFFER7                                  = 0x882C
	DRAW_BUFFER8                                  = 0x882D
	DRAW_BUFFER9                                  = 0x882E
	DRAW_BUFFER10                                 = 0x882F
	DRAW_BUFFER11                                 = 0x8830
	DRAW_BUFFER12                                 = 0x8831
	DRAW_BUFFER13                                 = 0x8832
	DRAW_BUFFER14                                 = 0x8833
	DRAW_BUFFER15                                 = 0x8834
	BLEND_EQUATION_ALPHA                          = 0x883D
	TEXTURE_DEPTH_SIZE                            = 0x884A
	TEXTURE_COMPARE_MODE                          = 0x884C
	TEXTURE_COMPARE_FUNC                          = 0x884D
	COMPARE_REF_TO_TEXTURE                        = 0x884E
	TEXTURE_CUBE_MAP_SEAMLESS                     = 0x884F
	QUERY_COUNTER_BITS                            = 0x8864
	CURRENT_QUERY                                 = 0x8865
	QUERY_RESULT                                  = 0x8866
	QUERY_RESULT_AVAILABLE                        = 0x8867
	MAX_VERTEX_ATTRIBS                            = 0x8869
	VERTEX_ATTRIB_ARRAY_NORMALIZED                = 0x886A
	MAX_TEXTURE_IMAGE_UNITS                       = 0x8872
	ARRAY_BUFFER                                  = 0x8892
	ELEMENT_ARRAY_BUFFER                          = 0x8893
	ARRAY_BUFFER_BINDING                          = 0x8894
	ELEMENT_ARRAY_BUFFER_BINDING                  = 0x8895
	VERTEX_ATTRIB_ARRAY_BUFFER_BINDING            = 0x889F
	READ_ONLY                                     = 0x88B8
	WRITE_ONLY                                    = 0x88B9
	READ_WRITE                                    = 0x88BA
	BUFFER_ACCESS                                 = 0x88BB
	BUFFER_MAPPED                                 = 0x88BC
	BUFFER_MAP_POINTER                            = 0x88BD
	STREAM_DRAW                                   = 0x88E0
	STREAM_READ                                   = 0x88E1
	STREAM_COPY                                   = 0x88E2
	STATIC_DRAW                                   = 0x88E4
	STATIC_READ                                   = 0x88E5
	STATIC_COPY                                   = 0x88E6
	DYNAMIC_DRAW                                  = 0x88E8
	DYNAMIC_READ                                  = 0x88E9
	DYNAMIC_COPY                                  = 0x88EA
	PIXEL_PACK_BUFFER                             = 0x88EB
	PIXEL_UNPACK_BUFFER                           = 0x88EC
	PIXEL_PACK_BUFFER_BINDING                     = 0x88ED
	PIXEL_UNPACK_BUFFER_BINDING                   = 0x88EF
	DEPTH24_STENCIL8                              = 0x88F0
	TEXTURE_STENCIL_SIZE                          = 0x88F1
	VERTEX_ATTRIB_ARRAY_INTEGER                   = 0x88FD
	MAX_ARRAY_TEXTURE_LAYERS                      = 0x88FF
	MIN_PROGRAM_TEXEL_OFFSET                      = 0x8904
	MAX_PROGRAM_TEXEL_OFFSET                      = 0x8905
	SAMPLES_PASSED                                = 0x8914
	GEOMETRY_VERTICES_OUT                         = 0x8916
	GEOMETRY_INPUT_TYPE                           = 0x8917
	GEOMETRY_OUTPUT_TYPE                          = 0x8918
	CLAMP_READ_COLOR                              = 0x891C
	FIXED_ONLY                                    = 0x891D
	UNIFORM_BUFFER                                = 0x8A11
	UNIFORM_BUFFER_BINDING                        = 0x8A28
	UNIFORM_BUFFER_START                          = 0x8A29
	UNIFORM_BUFFER_SIZE                           = 0x8A2A
	MAX_VERTEX_UNIFORM_BLOCKS                     = 0x8A2B
	MAX_GEOMETRY_UNIFORM_BLOCKS                   = 0x8A2C
	MAX_FRAGMENT_UNIFORM_BLOCKS                   = 0x8A2D
	MAX_COMBINED_UNIFORM_BLOCKS                   = 0x8A2E
	MAX_UNIFORM_BUFFER_BINDINGS                   = 0x8A2F
	MAX_UNIFORM_BLOCK_SIZE                        = 0x8A30
	MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS        = 0x8A31
	MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS      = 0x8A32
	MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS      = 0x8A33
	UNIFORM_BUFFER_OFFSET_ALIGNMENT               = 0x8A34
	ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH          = 0x8A35
	ACTIVE_UNIFORM_BLOCKS                         = 0x8A36
	UNIFORM_TYPE                                  = 0x8A37
	UNIFORM_SIZE                                  = 0x8A38
	UNIFORM_NAME_LENGTH                           = 0x8A39
	UNIFORM_BLOCK_INDEX                           = 0x8A3A
	UNIFORM_OFFSET                                = 0x8A3B
	UNIFORM_ARRAY_STRIDE                          = 0x8A3C
	UNIFORM_MATRIX_STRIDE                         = 0x8A3D
	UNIFORM_IS_ROW_MAJOR                          = 0x8A3E
	UNIFORM_BLOCK_BINDING                         = 0x8A3F
	UNIFORM_BLOCK_DATA_SIZE                       = 0x8A40
	UNIFORM_BLOCK_NAME_LENGTH                     = 0x8A41
	UNIFORM_BLOCK_ACTIVE_UNIFORMS                 = 0x8A42
	UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES          = 0x8A43
	UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER     = 0x8A44
	UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER   = 0x8A45
	UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER   = 0x8A46
	FRAGMENT_SHADER                               = 0x8B30
	VERTEX_SHADER                                 = 0x8B31
	MAX_FRAGMENT_UNIFORM_COMPONENTS               = 0x8B49
	MAX_VERTEX_UNIFORM_COMPONENTS                 = 0x8B4A
	MAX_VARYING_FLOATS                            = 0x8B4B
	MAX_VARYING_COMPONENTS                        = 0x8B4B
	MAX_VERTEX_TEXTURE_IMAGE_UNITS                = 0x8B4C
	MAX_COMBINED_TEXTURE_IMAGE_UNITS              = 0x8B4D
	SHADER_TYPE                                   = 0x8B4F
	FLOAT_VEC2                                    = 0x8B50
	FLOAT_VEC3                                    = 0x8B51
	FLOAT_VEC4                                    = 0x8B52
	INT_VEC2                                      = 0x8B53
	INT_VEC3                                      = 0x8B54
	INT_VEC4                                      = 0x8B55
	BOOL                                          = 0x8B56
	BOOL_VEC2                                     = 0x8B57
	BOOL_VEC3                                     = 0x8B58
	BOOL_VEC4                                     = 0x8B59
	FLOAT_MAT2                                    = 0x8B5A
	FLOAT_MAT3                                    = 0x8B5B
	FLOAT_MAT4                                    = 0x8B5C
	SAMPLER_1D                                    = 0x8B5D
	SAMPLER_2D                                    = 0x8B5E
	SAMPLER_3D                                    = 0x8B5F
	SAMPLER_CUBE                                  = 0x8B60
	SAMPLER_1D_SHADOW                             = 0x8B61
	SAMPLER_2D_SHADOW                             = 0x8B62
	SAMPLER_2D_RECT                               = 0x8B63
	SAMPLER_2D_RECT_SHADOW                        = 0x8B64
	FLOAT_MAT2x3                                  = 0x8B65
	FLOAT_MAT2x4                                  = 0x8B66
	FLOAT_MAT3x2                                  = 0x8B67
	FLOAT_MAT3x4                                  = 0x8B68
	FLOAT_MAT4x2                                  = 0x8B69
	FLOAT_MAT4x3                                  = 0x8B6A
	DELETE_STATUS                                 = 0x8B80
	COMPILE_STATUS                                = 0x8B81
	LINK_STATUS                                   = 0x8B82
	VALIDATE_STATUS                               = 0x8B83
	INFO_LOG_LENGTH                               = 0x8B84
	ATTACHED_SHADERS                              = 0x8B85
	ACTIVE_UNIFORMS                               = 0x8B86
	ACTIVE_UNIFORM_MAX_LENGTH                     = 0x8B87
	SHADER_SOURCE_LENGTH                          = 0x8B88
	ACTIVE_ATTRIBUTES                             = 0x8B89
	ACTIVE_ATTRIBUTE_MAX_LENGTH                   = 0x8B8A
	SHADING_LANGUAGE_VERSION                      = 0x8B8C
	CURRENT_PROGRAM                               = 0x8B8D
	TEXTURE_RED_TYPE                              = 0x8C10
	TEXTURE_GREEN_TYPE                            = 0x8C11
	TEXTURE_BLUE_TYPE                             = 0x8C12
	TEXTURE_ALPHA_TYPE                            = 0x8C13
	TEXTURE_DEPTH_TYPE                            = 0x8C16
	UNSIGNED_NORMALIZED                           = 0x8C17
	TEXTURE_1D_ARRAY                              = 0x8C18
	PROXY_TEXTURE_1D_ARRAY                        = 0x8C19
	TEXTURE_2D_ARRAY                              = 0x8C1A
	PROXY_TEXTURE_2D_ARRAY                        = 0x8C1B
	TEXTURE_BINDING_1D_ARRAY                      = 0x8C1C
	TEXTURE_BINDING_2D_ARRAY                      = 0x8C1D
	MAX_GEOMETRY_TEXTURE_IMAGE_UNITS              = 0x8C29
	TEXTURE_BUFFER                                = 0x8C2A
	MAX_TEXTURE_BUFFER_SIZE                       = 0x8C2B
	TEXTURE_BINDING_BUFFER                        = 0x8C2C
	TEXTURE_BUFFER_DATA_STORE_BINDING             = 0x8C2D
	R11F_G11F_B10F                                = 0x8C3A
	UNSIGNED_INT_10F_11F_11F_REV                  = 0x8C3B
	RGB9_E5                                       = 0x8C3D
	UNSIGNED_INT_5_9_9_9_REV                      = 0x8C3E
	TEXTURE_SHARED_SIZE                           = 0x8C3F
	SRGB                                          = 0x8C40
	SRGB8                                         = 0x8C41
	SRGB_ALPHA                                    = 0x8C42
	SRGB8_ALPHA8                                  = 0x8C43
	COMPRESSED_SRGB                               = 0x8C48
	COMPRESSED_SRGB_ALPHA                         = 0x8C49
	TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH         = 0x8C76
	TRANSFORM_FEEDBACK_BUFFER_MODE                = 0x8C7F
	MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS    = 0x8C80
	TRANSFORM_FEEDBACK_VARYINGS                   = 0x8C83
	TRANSFORM_FEEDBACK_BUFFER_START               = 0x8C84
	TRANSFORM_FEEDBACK_BUFFER_SIZE                = 0x8C85
	PRIMITIVES_GENERATED                          = 0x8C87
	TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN         = 0x8C88
	RASTERIZER_DISCARD                            = 0x8C89
	MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 0x8C8A
	MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS       = 0x8C8B
	INTERLEAVED_ATTRIBS                           = 0x8C8C
	SEPARATE_ATTRIBS                              = 0x8C8D
	TRANSFORM_FEEDBACK_BUFFER                     = 0x8C8E
	TRANSFORM_FEEDBACK_BUFFER_BINDING             = 0x8C8F
	POINT_SPRITE_COORD_ORIGIN                     = 0x8CA0
	LOWER_LEFT                                    = 0x8CA1
	UPPER_LEFT                                    = 0x8CA2
	STENCIL_BACK_REF                              = 0x8CA3
	STENCIL_BACK_VALUE_MASK                       = 0x8CA4
	STENCIL_BACK_WRITEMASK                        = 0x8CA5
	DRAW_FRAMEBUFFER_BINDING                      = 0x8CA6
	FRAMEBUFFER_BINDING                           = 0x8CA6
	RENDERBUFFER_BINDING                          = 0x8CA7
	READ_FRAMEBUFFER                              = 0x8CA8
	DRAW_FRAMEBUFFER                              = 0x8CA9
	READ_FRAMEBUFFER_BINDING                      = 0x8CAA
	RENDERBUFFER_SAMPLES                          = 0x8CAB
	DEPTH_COMPONENT32F                            = 0x8CAC
	DEPTH32F_STENCIL8                             = 0x8CAD
	FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE            = 0x8CD0
	FRAMEBUFFER_ATTACHMENT_OBJECT_NAME            = 0x8CD1
	FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL          = 0x8CD2
	FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE  = 0x8CD3
	FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER          = 0x8CD4
	FRAMEBUFFER_COMPLETE                          = 0x8CD5
	FRAMEBUFFER_INCOMPLETE_ATTACHMENT             = 0x8CD6
	FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT     = 0x8CD7
	FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER            = 0x8CDB
	FRAMEBUFFER_INCOMPLETE_READ_BUFFER            = 0x8CDC
	FRAMEBUFFER_UNSUPPORTED                       = 0x8CDD
	MAX_COLOR_ATTACHMENTS                         = 0x8CDF
	COLOR_ATTACHMENT0                             = 0x8CE0
	COLOR_ATTACHMENT1                             = 0x8CE1
	COLOR_ATTACHMENT2                             = 0x8CE2
	COLOR_ATTACHMENT3                             = 0x8CE3
	COLOR_ATTACHMENT4                             = 0x8CE4
	COLOR_ATTACHMENT5                             = 0x8CE5
	COLOR_ATTACHMENT6                             = 0x8CE6
	COLOR_ATTACHMENT7                             = 0x8CE7
	COLOR_ATTACHMENT8                             = 0x8CE8
	COLOR_ATTACHMENT9                             = 0x8CE9
	COLOR_ATTACHMENT10                            = 0x8CEA
	COLOR_ATTACHMENT11                            = 0x8CEB
	COLOR_ATTACHMENT12                            = 0x8CEC
	COLOR_ATTACHMENT13                            = 0x8CED
	COLOR_ATTACHMENT14                            = 0x8CEE
	COLOR_ATTACHMENT15                            = 0x8CEF
	DEPTH_ATTACHMENT                              = 0x8D00
	STENCIL_ATTACHMENT                            = 0x8D20
	FRAMEBUFFER                                   = 0x8D40
	RENDERBUFFER                                  = 0x8D41
	RENDERBUFFER_WIDTH                            = 0x8D42
	RENDERBUFFER_HEIGHT                           = 0x8D43
	RENDERBUFFER_INTERNAL_FORMAT                  = 0x8D44
	STENCIL_INDEX1                                = 0x8D46
	STENCIL_INDEX4                                = 0x8D47
	STENCIL_INDEX8                                = 0x8D48
	STENCIL_INDEX16                               = 0x8D49
	RENDERBUFFER_RED_SIZE                         = 0x8D50
	RENDERBUFFER_GREEN_SIZE                       = 0x8D51
	RENDERBUFFER_BLUE_SIZE                        = 0x8D52
	RENDERBUFFER_ALPHA_SIZE                       = 0x8D53
	RENDERBUFFER_DEPTH_SIZE                       = 0x8D54
	RENDERBUFFER_STENCIL_SIZE                     = 0x8D55
	FRAMEBUFFER_INCOMPLETE_MULTISAMPLE            = 0x8D56
	MAX_SAMPLES                                   = 0x8D57
	RGBA32UI                                      = 0x8D70
	RGB32UI                                       = 0x8D71
	RGBA16UI                                      = 0x8D76
	RGB16UI                                       = 0x8D77
	RGBA8UI                                       = 0x8D7C
	RGB8UI                                        = 0x8D7D
	RGBA32I                                       = 0x8D82
	RGB32I                                        = 0x8D83
	RGBA16I                                       = 0x8D88
	RGB16I                                        = 0x8D89
	RGBA8I                                        = 0x8D8E
	RGB8I                                         = 0x8D8F
	RED_INTEGER                                   = 0x8D94
	GREEN_INTEGER                                 = 0x8D95
	BLUE_INTEGER                                  = 0x8D96
	RGB_INTEGER                                   = 0x8D98
	RGBA_INTEGER                                  = 0x8D99
	BGR_INTEGER                                   = 0x8D9A
	BGRA_INTEGER                                  = 0x8D9B
	FRAMEBUFFER_ATTACHMENT_LAYERED                = 0x8DA7
	FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS          = 0x8DA8
	FLOAT_32_UNSIGNED_INT_24_8_REV                = 0x8DAD
	FRAMEBUFFER_SRGB                              = 0x8DB9
	COMPRESSED_RED_RGTC1                          = 0x8DBB
	COMPRESSED_SIGNED_RED_RGTC1                   = 0x8DBC
	COMPRESSED_RG_RGTC2                           = 0x8DBD
	COMPRESSED_SIGNED_RG_RGTC2                    = 0x8DBE
	SAMPLER_1D_ARRAY                              = 0x8DC0
	SAMPLER_2D_ARRAY                              = 0x8DC1
	SAMPLER_BUFFER                                = 0x8DC2
	SAMPLER_1D_ARRAY_SHADOW                       = 0x8DC3
	SAMPLER_2D_ARRAY_SHADOW                       = 0x8DC4
	SAMPLER_CUBE_SHADOW                           = 0x8DC5
	UNSIGNED_INT_VEC2                             = 0x8DC6
	UNSIGNED_INT_VEC3                             = 0x8DC7
	UNSIGNED_INT_VEC4                             = 0x8DC8
	INT_SAMPLER_1D                                = 0x8DC9
	INT_SAMPLER_2D                                = 0x8DCA
	INT_SAMPLER_3D                                = 0x8DCB
	INT_SAMPLER_CUBE                              = 0x8DCC
	INT_SAMPLER_2D_RECT                           = 0x8DCD
	INT_SAMPLER_1D_ARRAY                          = 0x8DCE
	INT_SAMPLER_2D_ARRAY                          = 0x8DCF
	INT_SAMPLER_BUFFER                            = 0x8DD0
	UNSIGNED_INT_SAMPLER_1D                       = 0x8DD1
	UNSIGNED_INT_SAMPLER_2D                       = 0x8DD2
	UNSIGNED_INT_SAMPLER_3D                       = 0x8DD3
	UNSIGNED_INT_SAMPLER_CUBE                     = 0x8DD4
	UNSIGNED_INT_SAMPLER_2D_RECT                  = 0x8DD5
	UNSIGNED_INT_SAMPLER_1D_ARRAY                 = 0x8DD6
	UNSIGNED_INT_SAMPLER_2D_ARRAY                 = 0x8DD7
	UNSIGNED_INT_SAMPLER_BUFFER                   = 0x8DD8
	GEOMETRY_SHADER                               = 0x8DD9
	MAX_GEOMETRY_UNIFORM_COMPONENTS               = 0x8DDF
	MAX_GEOMETRY_OUTPUT_VERTICES                  = 0x8DE0
	MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS          = 0x8DE1
	QUERY_WAIT                                    = 0x8E13
	QUERY_NO_WAIT                                 = 0x8E14
	QUERY_BY_REGION_WAIT                          = 0x8E15
	QUERY_BY_REGION_NO_WAIT                       = 0x8E16
	QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION      = 0x8E4C
	FIRST_VERTEX_CONVENTION                       = 0x8E4D
	LAST_VERTEX_CONVENTION                        = 0x8E4E
	PROVOKING_VERTEX                              = 0x8E4F
	SAMPLE_POSITION                               = 0x8E50
	SAMPLE_MASK                                   = 0x8E51
	SAMPLE_MASK_VALUE                             = 0x8E52
	MAX_SAMPLE_MASK_WORDS                         = 0x8E59
	COPY_READ_BUFFER                              = 0x8F36
	COPY_WRITE_BUFFER                             = 0x8F37
	R8_SNORM                                      = 0x8F94
	RG8_SNORM                                     = 0x8F95
	RGB8_SNORM                                    = 0x8F96
	RGBA8_SNORM                                   = 0x8F97
	R16_SNORM                                     = 0x8F98
	RG16_SNORM                                    = 0x8F99
	RGB16_SNORM                                   = 0x8F9A
	RGBA16_SNORM                                  = 0x8F9B
	SIGNED_NORMALIZED                             = 0x8F9C
	PRIMITIVE_RESTART                             = 0x8F9D
	PRIMITIVE_RESTART_INDEX                       = 0x8F9E
	TEXTURE_2D_MULTISAMPLE                        = 0x9100
	PROXY_TEXTURE_2D_MULTISAMPLE                  = 0x9101
	TEXTURE_2D_MULTISAMPLE_ARRAY                  = 0x9102
	PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY            = 0x9103
	TEXTURE_BINDING_2D_MULTISAMPLE                = 0x9104
	TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY          = 0x9105
	TEXTURE_SAMPLES                               = 0x9106
	TEXTURE_FIXED_SAMPLE_LOCATIONS                = 0x9107
	SAMPLER_2D_MULTISAMPLE                        = 0x9108
	INT_SAMPLER_2D_MULTISAMPLE                    = 0x9109
	UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE           = 0x910A
	SAMPLER_2D_MULTISAMPLE_ARRAY                  = 0x910B
	INT_SAMPLER_2D_MULTISAMPLE_ARRAY              = 0x910C
	UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY     = 0x910D
	MAX_COLOR_TEXTURE_SAMPLES                     = 0x910E
	MAX_DEPTH_TEXTURE_SAMPLES                     = 0x910F
	MAX_INTEGER_SAMPLES                           = 0x9110
	MAX_SERVER_WAIT_TIMEOUT                       = 0x9111
	OBJECT_TYPE                                   = 0x9112
	SYNC_CONDITION                                = 0x9113
	SYNC_STATUS                                   = 0x9114
	SYNC_FLAGS                                    = 0x9115
	SYNC_FENCE                                    = 0x9116
	SYNC_GPU_COMMANDS_COMPLETE                    = 0x9117
	UNSIGNALED                                    = 0x9118
	SIGNALED                                      = 0x9119
	ALREADY_SIGNALED                              = 0x911A
	TIMEOUT_EXPIRED                               = 0x911B
	CONDITION_SATISFIED                           = 0x911C
	WAIT_FAILED                                   = 0x911D
	BUFFER_ACCESS_FLAGS                           = 0x911F
	BUFFER_MAP_LENGTH                             = 0x9120
	BUFFER_MAP_OFFSET                             = 0x9121
	MAX_VERTEX_OUTPUT_COMPONENTS                  = 0x9122
	MAX_GEOMETRY_INPUT_COMPONENTS                 = 0x9123
	MAX_GEOMETRY_OUTPUT_COMPONENTS                = 0x9124
	MAX_FRAGMENT_INPUT_COMPONENTS                 = 0x9125
	CONTEXT_PROFILE_MASK                          = 0x9126
)

// https://www.opengl.org/sdk/docs/man2/xhtml/glViewport.xml
func (gl *GL) Viewport(x, y, width, height int32) {
	C.gl4_3core_glViewport(gl.funcs, C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height))
}

// DepthRange specifies the mapping of depth values from normalized device
// coordinates to window coordinates.
//
// Parameter nearVal specifies the mapping of the near clipping plane to window
// coordinates (defaults to 0), while farVal specifies the mapping of the far
// clipping plane to window coordinates (defaults to 1).
//
// After clipping and division by w, depth coordinates range from -1 to 1,
// corresponding to the near and far clipping planes. DepthRange specifies a
// linear mapping of the normalized depth coordinates in this range to window
// depth coordinates. Regardless of the actual depth buffer implementation,
// window coordinate depth values are treated as though they range from 0 through 1
// (like color components). Thus, the values accepted by DepthRange are both
// clamped to this range before they are accepted.
//
// The default setting of (0, 1) maps the near plane to 0 and the far plane to 1.
// With this mapping, the depth buffer range is fully utilized.
//
// It is not necessary that nearVal be less than farVal. Reverse mappings such as
// nearVal 1, and farVal 0 are acceptable.
//
// GL.INVALID_OPERATION is generated if DepthRange is executed between the
// execution of Begin and the corresponding execution of End.
//
// See also DepthFunc, PolygonOffset, Viewport.
//
// https://www.opengl.org/sdk/docs/man2/xhtml/glDepthRange.xml
func (gl *GL) DepthRange(nearVal, farVal float64) {
	C.gl4_3core_glDepthRange(gl.funcs, C.GLdouble(nearVal), C.GLdouble(farVal))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsEnabled.xml
func (gl *GL) IsEnabled(cap glbase.Enum) bool {
	glresult := C.gl4_3core_glIsEnabled(gl.funcs, C.GLenum(cap))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetTexLevelParameteriv.xml
func (gl *GL) GetTexLevelParameteriv(target glbase.Enum, level int32, pname glbase.Enum, params []int32) {
	C.gl4_3core_glGetTexLevelParameteriv(gl.funcs, C.GLenum(target), C.GLint(level), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetTexLevelParameterfv.xml
func (gl *GL) GetTexLevelParameterfv(target glbase.Enum, level int32, pname glbase.Enum, params []float32) {
	C.gl4_3core_glGetTexLevelParameterfv(gl.funcs, C.GLenum(target), C.GLint(level), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetTexParameteriv.xml
func (gl *GL) GetTexParameteriv(target, pname glbase.Enum, params []int32) {
	C.gl4_3core_glGetTexParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetTexParameterfv.xml
func (gl *GL) GetTexParameterfv(target, pname glbase.Enum, params []float32) {
	C.gl4_3core_glGetTexParameterfv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetTexImage.xml
func (gl *GL) GetTexImage(target glbase.Enum, level int32, format, gltype glbase.Enum, pixels interface{}) {
	pixels_v := reflect.ValueOf(pixels)
	if pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	C.gl4_3core_glGetTexImage(gl.funcs, C.GLenum(target), C.GLint(level), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(pixels_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetIntegerv.xml
func (gl *GL) GetIntegerv(pname glbase.Enum, params []int32) {
	C.gl4_3core_glGetIntegerv(gl.funcs, C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetFloatv.xml
func (gl *GL) GetFloatv(pname glbase.Enum, params []float32) {
	C.gl4_3core_glGetFloatv(gl.funcs, C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetError.xml
func (gl *GL) GetError() glbase.Enum {
	glresult := C.gl4_3core_glGetError(gl.funcs)
	return glbase.Enum(glresult)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetDoublev.xml
func (gl *GL) GetDoublev(pname glbase.Enum, params []float64) {
	C.gl4_3core_glGetDoublev(gl.funcs, C.GLenum(pname), (*C.GLdouble)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetBooleanv.xml
func (gl *GL) GetBooleanv(pname glbase.Enum, params []bool) {
	C.gl4_3core_glGetBooleanv(gl.funcs, C.GLenum(pname), (*C.GLboolean)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glReadPixels.xml
func (gl *GL) ReadPixels(x, y, width, height int32, format, gltype glbase.Enum, pixels interface{}) {
	pixels_v := reflect.ValueOf(pixels)
	if pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	C.gl4_3core_glReadPixels(gl.funcs, C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(pixels_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glReadBuffer.xml
func (gl *GL) ReadBuffer(mode glbase.Enum) {
	C.gl4_3core_glReadBuffer(gl.funcs, C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPixelStorei.xml
func (gl *GL) PixelStorei(pname glbase.Enum, param int32) {
	C.gl4_3core_glPixelStorei(gl.funcs, C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPixelStoref.xml
func (gl *GL) PixelStoref(pname glbase.Enum, param float32) {
	C.gl4_3core_glPixelStoref(gl.funcs, C.GLenum(pname), C.GLfloat(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDepthFunc.xml
func (gl *GL) DepthFunc(glfunc glbase.Enum) {
	C.gl4_3core_glDepthFunc(gl.funcs, C.GLenum(glfunc))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glStencilOp.xml
func (gl *GL) StencilOp(fail, zfail, zpass glbase.Enum) {
	C.gl4_3core_glStencilOp(gl.funcs, C.GLenum(fail), C.GLenum(zfail), C.GLenum(zpass))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glStencilFunc.xml
func (gl *GL) StencilFunc(glfunc glbase.Enum, ref int32, mask uint32) {
	C.gl4_3core_glStencilFunc(gl.funcs, C.GLenum(glfunc), C.GLint(ref), C.GLuint(mask))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glLogicOp.xml
func (gl *GL) LogicOp(opcode glbase.Enum) {
	C.gl4_3core_glLogicOp(gl.funcs, C.GLenum(opcode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBlendFunc.xml
func (gl *GL) BlendFunc(sfactor, dfactor glbase.Enum) {
	C.gl4_3core_glBlendFunc(gl.funcs, C.GLenum(sfactor), C.GLenum(dfactor))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFlush.xml
func (gl *GL) Flush() {
	C.gl4_3core_glFlush(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFinish.xml
func (gl *GL) Finish() {
	C.gl4_3core_glFinish(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEnable.xml
func (gl *GL) Enable(cap glbase.Enum) {
	C.gl4_3core_glEnable(gl.funcs, C.GLenum(cap))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDisable.xml
func (gl *GL) Disable(cap glbase.Enum) {
	C.gl4_3core_glDisable(gl.funcs, C.GLenum(cap))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDepthMask.xml
func (gl *GL) DepthMask(flag bool) {
	C.gl4_3core_glDepthMask(gl.funcs, *(*C.GLboolean)(unsafe.Pointer(&flag)))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColorMask.xml
func (gl *GL) ColorMask(red, green, blue, alpha bool) {
	C.gl4_3core_glColorMask(gl.funcs, *(*C.GLboolean)(unsafe.Pointer(&red)), *(*C.GLboolean)(unsafe.Pointer(&green)), *(*C.GLboolean)(unsafe.Pointer(&blue)), *(*C.GLboolean)(unsafe.Pointer(&alpha)))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glStencilMask.xml
func (gl *GL) StencilMask(mask uint32) {
	C.gl4_3core_glStencilMask(gl.funcs, C.GLuint(mask))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClearDepth.xml
func (gl *GL) ClearDepth(depth float64) {
	C.gl4_3core_glClearDepth(gl.funcs, C.GLdouble(depth))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClearStencil.xml
func (gl *GL) ClearStencil(s int32) {
	C.gl4_3core_glClearStencil(gl.funcs, C.GLint(s))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClearColor.xml
func (gl *GL) ClearColor(red, green, blue, alpha float32) {
	C.gl4_3core_glClearColor(gl.funcs, C.GLfloat(red), C.GLfloat(green), C.GLfloat(blue), C.GLfloat(alpha))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClear.xml
func (gl *GL) Clear(mask glbase.Bitfield) {
	C.gl4_3core_glClear(gl.funcs, C.GLbitfield(mask))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawBuffer.xml
func (gl *GL) DrawBuffer(mode glbase.Enum) {
	C.gl4_3core_glDrawBuffer(gl.funcs, C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexImage2D.xml
func (gl *GL) TexImage2D(target glbase.Enum, level, internalformat, width, height, border int32, format, gltype glbase.Enum, pixels interface{}) {
	pixels_v := reflect.ValueOf(pixels)
	if pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	C.gl4_3core_glTexImage2D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(internalformat), C.GLsizei(width), C.GLsizei(height), C.GLint(border), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(pixels_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexImage1D.xml
func (gl *GL) TexImage1D(target glbase.Enum, level, internalformat, width, border int32, format, gltype glbase.Enum, pixels interface{}) {
	pixels_v := reflect.ValueOf(pixels)
	if pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	C.gl4_3core_glTexImage1D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(internalformat), C.GLsizei(width), C.GLint(border), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(pixels_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexParameteriv.xml
func (gl *GL) TexParameteriv(target, pname glbase.Enum, params []int32) {
	C.gl4_3core_glTexParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexParameteri.xml
func (gl *GL) TexParameteri(target, pname glbase.Enum, param int32) {
	C.gl4_3core_glTexParameteri(gl.funcs, C.GLenum(target), C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexParameterfv.xml
func (gl *GL) TexParameterfv(target, pname glbase.Enum, params []float32) {
	C.gl4_3core_glTexParameterfv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexParameterf.xml
func (gl *GL) TexParameterf(target, pname glbase.Enum, param float32) {
	C.gl4_3core_glTexParameterf(gl.funcs, C.GLenum(target), C.GLenum(pname), C.GLfloat(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glScissor.xml
func (gl *GL) Scissor(x, y, width, height int32) {
	C.gl4_3core_glScissor(gl.funcs, C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPolygonMode.xml
func (gl *GL) PolygonMode(face, mode glbase.Enum) {
	C.gl4_3core_glPolygonMode(gl.funcs, C.GLenum(face), C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPointSize.xml
func (gl *GL) PointSize(size float32) {
	C.gl4_3core_glPointSize(gl.funcs, C.GLfloat(size))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glLineWidth.xml
func (gl *GL) LineWidth(width float32) {
	C.gl4_3core_glLineWidth(gl.funcs, C.GLfloat(width))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glHint.xml
func (gl *GL) Hint(target, mode glbase.Enum) {
	C.gl4_3core_glHint(gl.funcs, C.GLenum(target), C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFrontFace.xml
func (gl *GL) FrontFace(mode glbase.Enum) {
	C.gl4_3core_glFrontFace(gl.funcs, C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCullFace.xml
func (gl *GL) CullFace(mode glbase.Enum) {
	C.gl4_3core_glCullFace(gl.funcs, C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIndexubv.xml
func (gl *GL) Indexubv(c []uint8) {
	C.gl4_3core_glIndexubv(gl.funcs, (*C.GLubyte)(unsafe.Pointer(&c[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIndexub.xml
func (gl *GL) Indexub(c uint8) {
	C.gl4_3core_glIndexub(gl.funcs, C.GLubyte(c))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsTexture.xml
func (gl *GL) IsTexture(texture glbase.Texture) bool {
	glresult := C.gl4_3core_glIsTexture(gl.funcs, C.GLuint(texture))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGenTextures.xml
func (gl *GL) GenTextures(n int32, textures []uint32) {
	C.gl4_3core_glGenTextures(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&textures[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteTextures.xml
func (gl *GL) DeleteTextures(n int32, textures []uint32) {
	C.gl4_3core_glDeleteTextures(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&textures[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindTexture.xml
func (gl *GL) BindTexture(target glbase.Enum, texture glbase.Texture) {
	C.gl4_3core_glBindTexture(gl.funcs, C.GLenum(target), C.GLuint(texture))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexSubImage2D.xml
func (gl *GL) TexSubImage2D(target glbase.Enum, level, xoffset, yoffset, width, height int32, format, gltype glbase.Enum, pixels interface{}) {
	pixels_v := reflect.ValueOf(pixels)
	if pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	C.gl4_3core_glTexSubImage2D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLint(yoffset), C.GLsizei(width), C.GLsizei(height), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(pixels_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexSubImage1D.xml
func (gl *GL) TexSubImage1D(target glbase.Enum, level, xoffset, width int32, format, gltype glbase.Enum, pixels interface{}) {
	pixels_v := reflect.ValueOf(pixels)
	if pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	C.gl4_3core_glTexSubImage1D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLsizei(width), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(pixels_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCopyTexSubImage2D.xml
func (gl *GL) CopyTexSubImage2D(target glbase.Enum, level, xoffset, yoffset, x, y, width, height int32) {
	C.gl4_3core_glCopyTexSubImage2D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLint(yoffset), C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCopyTexSubImage1D.xml
func (gl *GL) CopyTexSubImage1D(target glbase.Enum, level, xoffset, x, y, width int32) {
	C.gl4_3core_glCopyTexSubImage1D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLint(x), C.GLint(y), C.GLsizei(width))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCopyTexImage2D.xml
func (gl *GL) CopyTexImage2D(target glbase.Enum, level int32, internalformat glbase.Enum, x, y, width, height, border int32) {
	C.gl4_3core_glCopyTexImage2D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLenum(internalformat), C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height), C.GLint(border))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCopyTexImage1D.xml
func (gl *GL) CopyTexImage1D(target glbase.Enum, level int32, internalformat glbase.Enum, x, y, width, border int32) {
	C.gl4_3core_glCopyTexImage1D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLenum(internalformat), C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLint(border))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPolygonOffset.xml
func (gl *GL) PolygonOffset(factor, units float32) {
	C.gl4_3core_glPolygonOffset(gl.funcs, C.GLfloat(factor), C.GLfloat(units))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawElements.xml
func (gl *GL) DrawElements(mode glbase.Enum, count int32, gltype glbase.Enum, indices interface{}) {
	indices_v := reflect.ValueOf(indices)
	if indices_v.Kind() != reflect.Slice {
		panic("parameter indices must be a slice")
	}
	C.gl4_3core_glDrawElements(gl.funcs, C.GLenum(mode), C.GLsizei(count), C.GLenum(gltype), unsafe.Pointer(indices_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawArrays.xml
func (gl *GL) DrawArrays(mode glbase.Enum, first, count int32) {
	C.gl4_3core_glDrawArrays(gl.funcs, C.GLenum(mode), C.GLint(first), C.GLsizei(count))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCopyTexSubImage3D.xml
func (gl *GL) CopyTexSubImage3D(target glbase.Enum, level, xoffset, yoffset, zoffset, x, y, width, height int32) {
	C.gl4_3core_glCopyTexSubImage3D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLint(yoffset), C.GLint(zoffset), C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexSubImage3D.xml
func (gl *GL) TexSubImage3D(target glbase.Enum, level, xoffset, yoffset, zoffset, width, height, depth int32, format, gltype glbase.Enum, pixels interface{}) {
	pixels_v := reflect.ValueOf(pixels)
	if pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	C.gl4_3core_glTexSubImage3D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLint(yoffset), C.GLint(zoffset), C.GLsizei(width), C.GLsizei(height), C.GLsizei(depth), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(pixels_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexImage3D.xml
func (gl *GL) TexImage3D(target glbase.Enum, level, internalformat, width, height, depth, border int32, format, gltype glbase.Enum, pixels interface{}) {
	pixels_v := reflect.ValueOf(pixels)
	if pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	C.gl4_3core_glTexImage3D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(internalformat), C.GLsizei(width), C.GLsizei(height), C.GLsizei(depth), C.GLint(border), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(pixels_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawRangeElements.xml
func (gl *GL) DrawRangeElements(mode glbase.Enum, start, end uint32, count int32, gltype glbase.Enum, indices interface{}) {
	indices_v := reflect.ValueOf(indices)
	if indices_v.Kind() != reflect.Slice {
		panic("parameter indices must be a slice")
	}
	C.gl4_3core_glDrawRangeElements(gl.funcs, C.GLenum(mode), C.GLuint(start), C.GLuint(end), C.GLsizei(count), C.GLenum(gltype), unsafe.Pointer(indices_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBlendEquation.xml
func (gl *GL) BlendEquation(mode glbase.Enum) {
	C.gl4_3core_glBlendEquation(gl.funcs, C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBlendColor.xml
func (gl *GL) BlendColor(red, green, blue, alpha float32) {
	C.gl4_3core_glBlendColor(gl.funcs, C.GLfloat(red), C.GLfloat(green), C.GLfloat(blue), C.GLfloat(alpha))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetCompressedTexImage.xml
func (gl *GL) GetCompressedTexImage(target glbase.Enum, level int32, img interface{}) {
	img_v := reflect.ValueOf(img)
	if img_v.Kind() != reflect.Slice {
		panic("parameter img must be a slice")
	}
	C.gl4_3core_glGetCompressedTexImage(gl.funcs, C.GLenum(target), C.GLint(level), unsafe.Pointer(img_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCompressedTexSubImage1D.xml
func (gl *GL) CompressedTexSubImage1D(target glbase.Enum, level, xoffset, width int32, format glbase.Enum, imageSize int32, data interface{}) {
	data_v := reflect.ValueOf(data)
	if data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	C.gl4_3core_glCompressedTexSubImage1D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLsizei(width), C.GLenum(format), C.GLsizei(imageSize), unsafe.Pointer(data_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCompressedTexSubImage2D.xml
func (gl *GL) CompressedTexSubImage2D(target glbase.Enum, level, xoffset, yoffset, width, height int32, format glbase.Enum, imageSize int32, data interface{}) {
	data_v := reflect.ValueOf(data)
	if data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	C.gl4_3core_glCompressedTexSubImage2D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLint(yoffset), C.GLsizei(width), C.GLsizei(height), C.GLenum(format), C.GLsizei(imageSize), unsafe.Pointer(data_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCompressedTexSubImage3D.xml
func (gl *GL) CompressedTexSubImage3D(target glbase.Enum, level, xoffset, yoffset, zoffset, width, height, depth int32, format glbase.Enum, imageSize int32, data interface{}) {
	data_v := reflect.ValueOf(data)
	if data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	C.gl4_3core_glCompressedTexSubImage3D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLint(yoffset), C.GLint(zoffset), C.GLsizei(width), C.GLsizei(height), C.GLsizei(depth), C.GLenum(format), C.GLsizei(imageSize), unsafe.Pointer(data_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCompressedTexImage1D.xml
func (gl *GL) CompressedTexImage1D(target glbase.Enum, level int32, internalformat glbase.Enum, width, border, imageSize int32, data interface{}) {
	data_v := reflect.ValueOf(data)
	if data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	C.gl4_3core_glCompressedTexImage1D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLenum(internalformat), C.GLsizei(width), C.GLint(border), C.GLsizei(imageSize), unsafe.Pointer(data_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCompressedTexImage2D.xml
func (gl *GL) CompressedTexImage2D(target glbase.Enum, level int32, internalformat glbase.Enum, width, height, border, imageSize int32, data interface{}) {
	data_v := reflect.ValueOf(data)
	if data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	C.gl4_3core_glCompressedTexImage2D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLenum(internalformat), C.GLsizei(width), C.GLsizei(height), C.GLint(border), C.GLsizei(imageSize), unsafe.Pointer(data_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCompressedTexImage3D.xml
func (gl *GL) CompressedTexImage3D(target glbase.Enum, level int32, internalformat glbase.Enum, width, height, depth, border, imageSize int32, data interface{}) {
	data_v := reflect.ValueOf(data)
	if data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	C.gl4_3core_glCompressedTexImage3D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLenum(internalformat), C.GLsizei(width), C.GLsizei(height), C.GLsizei(depth), C.GLint(border), C.GLsizei(imageSize), unsafe.Pointer(data_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSampleCoverage.xml
func (gl *GL) SampleCoverage(value float32, invert bool) {
	C.gl4_3core_glSampleCoverage(gl.funcs, C.GLfloat(value), *(*C.GLboolean)(unsafe.Pointer(&invert)))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glActiveTexture.xml
func (gl *GL) ActiveTexture(texture glbase.Enum) {
	C.gl4_3core_glActiveTexture(gl.funcs, C.GLenum(texture))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPointParameteriv.xml
func (gl *GL) PointParameteriv(pname glbase.Enum, params []int32) {
	C.gl4_3core_glPointParameteriv(gl.funcs, C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPointParameteri.xml
func (gl *GL) PointParameteri(pname glbase.Enum, param int32) {
	C.gl4_3core_glPointParameteri(gl.funcs, C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPointParameterfv.xml
func (gl *GL) PointParameterfv(pname glbase.Enum, params []float32) {
	C.gl4_3core_glPointParameterfv(gl.funcs, C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPointParameterf.xml
func (gl *GL) PointParameterf(pname glbase.Enum, param float32) {
	C.gl4_3core_glPointParameterf(gl.funcs, C.GLenum(pname), C.GLfloat(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiDrawArrays.xml
func (gl *GL) MultiDrawArrays(mode glbase.Enum, first, count []int32, drawcount int32) {
	C.gl4_3core_glMultiDrawArrays(gl.funcs, C.GLenum(mode), (*C.GLint)(unsafe.Pointer(&first[0])), (*C.GLsizei)(unsafe.Pointer(&count[0])), C.GLsizei(drawcount))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBlendFuncSeparate.xml
func (gl *GL) BlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha glbase.Enum) {
	C.gl4_3core_glBlendFuncSeparate(gl.funcs, C.GLenum(sfactorRGB), C.GLenum(dfactorRGB), C.GLenum(sfactorAlpha), C.GLenum(dfactorAlpha))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetBufferParameteriv.xml
func (gl *GL) GetBufferParameteriv(target, pname glbase.Enum, params []int32) {
	C.gl4_3core_glGetBufferParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUnmapBuffer.xml
func (gl *GL) UnmapBuffer(target glbase.Enum) bool {
	glresult := C.gl4_3core_glUnmapBuffer(gl.funcs, C.GLenum(target))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetBufferSubData.xml
func (gl *GL) GetBufferSubData(target glbase.Enum, offset, size int, data interface{}) {
	data_v := reflect.ValueOf(data)
	if data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	C.gl4_3core_glGetBufferSubData(gl.funcs, C.GLenum(target), C.GLintptr(offset), C.GLsizeiptr(size), unsafe.Pointer(data_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBufferSubData.xml
func (gl *GL) BufferSubData(target glbase.Enum, offset, size int, data interface{}) {
	data_v := reflect.ValueOf(data)
	if data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	C.gl4_3core_glBufferSubData(gl.funcs, C.GLenum(target), C.GLintptr(offset), C.GLsizeiptr(size), unsafe.Pointer(data_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBufferData.xml
func (gl *GL) BufferData(target glbase.Enum, size int, data interface{}, usage glbase.Enum) {
	data_v := reflect.ValueOf(data)
	if data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	C.gl4_3core_glBufferData(gl.funcs, C.GLenum(target), C.GLsizeiptr(size), unsafe.Pointer(data_v.Index(0).Addr().Pointer()), C.GLenum(usage))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsBuffer.xml
func (gl *GL) IsBuffer(buffer glbase.Buffer) bool {
	glresult := C.gl4_3core_glIsBuffer(gl.funcs, C.GLuint(buffer))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGenBuffers.xml
func (gl *GL) GenBuffers(n int32, buffers []uint32) {
	C.gl4_3core_glGenBuffers(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&buffers[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteBuffers.xml
func (gl *GL) DeleteBuffers(n int32, buffers []uint32) {
	C.gl4_3core_glDeleteBuffers(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&buffers[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindBuffer.xml
func (gl *GL) BindBuffer(target glbase.Enum, buffer glbase.Buffer) {
	C.gl4_3core_glBindBuffer(gl.funcs, C.GLenum(target), C.GLuint(buffer))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetQueryObjectuiv.xml
func (gl *GL) GetQueryObjectuiv(id uint32, pname glbase.Enum, params []uint32) {
	C.gl4_3core_glGetQueryObjectuiv(gl.funcs, C.GLuint(id), C.GLenum(pname), (*C.GLuint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetQueryObjectiv.xml
func (gl *GL) GetQueryObjectiv(id uint32, pname glbase.Enum, params []int32) {
	C.gl4_3core_glGetQueryObjectiv(gl.funcs, C.GLuint(id), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetQueryiv.xml
func (gl *GL) GetQueryiv(target, pname glbase.Enum, params []int32) {
	C.gl4_3core_glGetQueryiv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEndQuery.xml
func (gl *GL) EndQuery(target glbase.Enum) {
	C.gl4_3core_glEndQuery(gl.funcs, C.GLenum(target))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBeginQuery.xml
func (gl *GL) BeginQuery(target glbase.Enum, id uint32) {
	C.gl4_3core_glBeginQuery(gl.funcs, C.GLenum(target), C.GLuint(id))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsQuery.xml
func (gl *GL) IsQuery(id uint32) bool {
	glresult := C.gl4_3core_glIsQuery(gl.funcs, C.GLuint(id))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteQueries.xml
func (gl *GL) DeleteQueries(n int32, ids []uint32) {
	C.gl4_3core_glDeleteQueries(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&ids[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGenQueries.xml
func (gl *GL) GenQueries(n int32, ids []uint32) {
	C.gl4_3core_glGenQueries(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&ids[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribPointer.xml
func (gl *GL) VertexAttribPointer(index glbase.Attrib, size int32, gltype glbase.Enum, normalized bool, stride int32, pointer interface{}) {
	pointer_v := reflect.ValueOf(pointer)
	if pointer_v.Kind() != reflect.Slice {
		panic("parameter pointer must be a slice")
	}
	C.gl4_3core_glVertexAttribPointer(gl.funcs, C.GLuint(index), C.GLint(size), C.GLenum(gltype), *(*C.GLboolean)(unsafe.Pointer(&normalized)), C.GLsizei(stride), unsafe.Pointer(pointer_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glValidateProgram.xml
func (gl *GL) ValidateProgram(program glbase.Program) {
	C.gl4_3core_glValidateProgram(gl.funcs, C.GLuint(program))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform4i.xml
func (gl *GL) Uniform4i(location glbase.Uniform, v0, v1, v2, v3 int32) {
	C.gl4_3core_glUniform4i(gl.funcs, C.GLint(location), C.GLint(v0), C.GLint(v1), C.GLint(v2), C.GLint(v3))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform3i.xml
func (gl *GL) Uniform3i(location glbase.Uniform, v0, v1, v2 int32) {
	C.gl4_3core_glUniform3i(gl.funcs, C.GLint(location), C.GLint(v0), C.GLint(v1), C.GLint(v2))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform2i.xml
func (gl *GL) Uniform2i(location glbase.Uniform, v0, v1 int32) {
	C.gl4_3core_glUniform2i(gl.funcs, C.GLint(location), C.GLint(v0), C.GLint(v1))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform1i.xml
func (gl *GL) Uniform1i(location glbase.Uniform, v0 int32) {
	C.gl4_3core_glUniform1i(gl.funcs, C.GLint(location), C.GLint(v0))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform4f.xml
func (gl *GL) Uniform4f(location glbase.Uniform, v0, v1, v2, v3 float32) {
	C.gl4_3core_glUniform4f(gl.funcs, C.GLint(location), C.GLfloat(v0), C.GLfloat(v1), C.GLfloat(v2), C.GLfloat(v3))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform3f.xml
func (gl *GL) Uniform3f(location glbase.Uniform, v0, v1, v2 float32) {
	C.gl4_3core_glUniform3f(gl.funcs, C.GLint(location), C.GLfloat(v0), C.GLfloat(v1), C.GLfloat(v2))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform2f.xml
func (gl *GL) Uniform2f(location glbase.Uniform, v0, v1 float32) {
	C.gl4_3core_glUniform2f(gl.funcs, C.GLint(location), C.GLfloat(v0), C.GLfloat(v1))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform1f.xml
func (gl *GL) Uniform1f(location glbase.Uniform, v0 float32) {
	C.gl4_3core_glUniform1f(gl.funcs, C.GLint(location), C.GLfloat(v0))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUseProgram.xml
func (gl *GL) UseProgram(program glbase.Program) {
	C.gl4_3core_glUseProgram(gl.funcs, C.GLuint(program))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glShaderSource.xml
func (gl *GL) ShaderSource(shader glbase.Shader, source ...string) {
	count := len(source)
	length := make([]int32, count)
	glstring := make([]unsafe.Pointer, count)
	for i, src := range source {
		length[i] = int32(len(src))
		if len(src) > 0 {
			glstring[i] = *(*unsafe.Pointer)(unsafe.Pointer(&src))
		} else {
			glstring[i] = unsafe.Pointer(uintptr(0))
		}
	}
	C.gl4_3core_glShaderSource(gl.funcs, C.GLuint(shader), C.GLsizei(count), (**C.GLchar)(unsafe.Pointer(&glstring[0])), (*C.GLint)(unsafe.Pointer(&length[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glLinkProgram.xml
func (gl *GL) LinkProgram(program glbase.Program) {
	C.gl4_3core_glLinkProgram(gl.funcs, C.GLuint(program))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsShader.xml
func (gl *GL) IsShader(shader glbase.Shader) bool {
	glresult := C.gl4_3core_glIsShader(gl.funcs, C.GLuint(shader))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsProgram.xml
func (gl *GL) IsProgram(program glbase.Program) bool {
	glresult := C.gl4_3core_glIsProgram(gl.funcs, C.GLuint(program))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// GetVertexAttribiv returns in params the value of a generic vertex attribute
// parameter. The generic vertex attribute to be queried is specified by
// index, and the parameter to be queried is specified by pname.
//
// The accepted parameter names are as follows:
//
//   GL.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING
//       params returns a single value, the name of the buffer object
//       currently bound to the binding point corresponding to generic vertex
//       attribute array index. If no buffer object is bound, 0 is returned.
//       The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_ENABLED
//       params returns a single value that is non-zero (true) if the vertex
//       attribute array for index is enabled and 0 (false) if it is
//       disabled. The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_SIZE
//       params returns a single value, the size of the vertex attribute
//       array for index. The size is the number of values for each element
//       of the vertex attribute array, and it will be 1, 2, 3, or 4. The
//       initial value is 4.
//
//   GL.VERTEX_ATTRIB_ARRAY_STRIDE
//       params returns a single value, the array stride for (number of bytes
//       between successive elements in) the vertex attribute array for
//       index. A value of 0 indicates that the array elements are stored
//       sequentially in memory. The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_TYPE
//       params returns a single value, a symbolic constant indicating the
//       array type for the vertex attribute array for index. Possible values
//       are GL.BYTE, GL.UNSIGNED_BYTE, GL.SHORT, GL.UNSIGNED_SHORT, GL.INT,
//       GL.UNSIGNED_INT, GL.FLOAT, and GL.DOUBLE. The initial value is
//       GL.FLOAT.
//
//   GL.VERTEX_ATTRIB_ARRAY_NORMALIZED
//       params returns a single value that is non-zero (true) if fixed-point
//       data types for the vertex attribute array indicated by index are
//       normalized when they are converted to floating point, and 0 (false)
//       otherwise. The initial value is 0.
//
//   GL.CURRENT_VERTEX_ATTRIB
//       params returns four values that represent the current value for the
//       generic vertex attribute specified by index. Generic vertex
//       attribute 0 is unique in that it has no current state, so an error
//       will be generated if index is 0. The initial value for all other
//       generic vertex attributes is (0,0,0,1).
//
// All of the parameters except GL.CURRENT_VERTEX_ATTRIB represent
// client-side state.
//
// Error GL.INVALID_VALUE is generated if index is greater than or equal to
// GL.MAX_VERTEX_ATTRIBS. GL.INVALID_ENUM is generated if pname is not an
// accepted value.  GL.INVALID_OPERATION is generated if index is 0 and pname
// is GL.CURRENT_VERTEX_ATTRIB.
//
// GetVertexAttrib is available only if the GL version is 2.0 or greater.
//
// https://www.opengl.org/sdk/docs/man2/xhtml/glGetVertexAttribiv.xml
func (gl *GL) GetVertexAttribiv(index glbase.Attrib, pname glbase.Enum) (params int32) {
	C.gl4_3core_glGetVertexAttribiv(gl.funcs, C.GLuint(index), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params)))
	return params
}

// GetVertexAttribfv returns in params the value of a generic vertex attribute
// parameter. The generic vertex attribute to be queried is specified by
// index, and the parameter to be queried is specified by pname.
//
// The accepted parameter names are as follows:
//
//   GL.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING
//       params returns a single value, the name of the buffer object
//       currently bound to the binding point corresponding to generic vertex
//       attribute array index. If no buffer object is bound, 0 is returned.
//       The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_ENABLED
//       params returns a single value that is non-zero (true) if the vertex
//       attribute array for index is enabled and 0 (false) if it is
//       disabled. The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_SIZE
//       params returns a single value, the size of the vertex attribute
//       array for index. The size is the number of values for each element
//       of the vertex attribute array, and it will be 1, 2, 3, or 4. The
//       initial value is 4.
//
//   GL.VERTEX_ATTRIB_ARRAY_STRIDE
//       params returns a single value, the array stride for (number of bytes
//       between successive elements in) the vertex attribute array for
//       index. A value of 0 indicates that the array elements are stored
//       sequentially in memory. The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_TYPE
//       params returns a single value, a symbolic constant indicating the
//       array type for the vertex attribute array for index. Possible values
//       are GL.BYTE, GL.UNSIGNED_BYTE, GL.SHORT, GL.UNSIGNED_SHORT, GL.INT,
//       GL.UNSIGNED_INT, GL.FLOAT, and GL.DOUBLE. The initial value is
//       GL.FLOAT.
//
//   GL.VERTEX_ATTRIB_ARRAY_NORMALIZED
//       params returns a single value that is non-zero (true) if fixed-point
//       data types for the vertex attribute array indicated by index are
//       normalized when they are converted to floating point, and 0 (false)
//       otherwise. The initial value is 0.
//
//   GL.CURRENT_VERTEX_ATTRIB
//       params returns four values that represent the current value for the
//       generic vertex attribute specified by index. Generic vertex
//       attribute 0 is unique in that it has no current state, so an error
//       will be generated if index is 0. The initial value for all other
//       generic vertex attributes is (0,0,0,1).
//
// All of the parameters except GL.CURRENT_VERTEX_ATTRIB represent
// client-side state.
//
// Error GL.INVALID_VALUE is generated if index is greater than or equal to
// GL.MAX_VERTEX_ATTRIBS. GL.INVALID_ENUM is generated if pname is not an
// accepted value.  GL.INVALID_OPERATION is generated if index is 0 and pname
// is GL.CURRENT_VERTEX_ATTRIB.
//
// GetVertexAttrib is available only if the GL version is 2.0 or greater.
//
// https://www.opengl.org/sdk/docs/man2/xhtml/glGetVertexAttribfv.xml
func (gl *GL) GetVertexAttribfv(index glbase.Attrib, pname glbase.Enum) (params float32) {
	C.gl4_3core_glGetVertexAttribfv(gl.funcs, C.GLuint(index), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params)))
	return params
}

// GetVertexAttribdv returns in params the value of a generic vertex attribute
// parameter. The generic vertex attribute to be queried is specified by
// index, and the parameter to be queried is specified by pname.
//
// The accepted parameter names are as follows:
//
//   GL.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING
//       params returns a single value, the name of the buffer object
//       currently bound to the binding point corresponding to generic vertex
//       attribute array index. If no buffer object is bound, 0 is returned.
//       The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_ENABLED
//       params returns a single value that is non-zero (true) if the vertex
//       attribute array for index is enabled and 0 (false) if it is
//       disabled. The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_SIZE
//       params returns a single value, the size of the vertex attribute
//       array for index. The size is the number of values for each element
//       of the vertex attribute array, and it will be 1, 2, 3, or 4. The
//       initial value is 4.
//
//   GL.VERTEX_ATTRIB_ARRAY_STRIDE
//       params returns a single value, the array stride for (number of bytes
//       between successive elements in) the vertex attribute array for
//       index. A value of 0 indicates that the array elements are stored
//       sequentially in memory. The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_TYPE
//       params returns a single value, a symbolic constant indicating the
//       array type for the vertex attribute array for index. Possible values
//       are GL.BYTE, GL.UNSIGNED_BYTE, GL.SHORT, GL.UNSIGNED_SHORT, GL.INT,
//       GL.UNSIGNED_INT, GL.FLOAT, and GL.DOUBLE. The initial value is
//       GL.FLOAT.
//
//   GL.VERTEX_ATTRIB_ARRAY_NORMALIZED
//       params returns a single value that is non-zero (true) if fixed-point
//       data types for the vertex attribute array indicated by index are
//       normalized when they are converted to floating point, and 0 (false)
//       otherwise. The initial value is 0.
//
//   GL.CURRENT_VERTEX_ATTRIB
//       params returns four values that represent the current value for the
//       generic vertex attribute specified by index. Generic vertex
//       attribute 0 is unique in that it has no current state, so an error
//       will be generated if index is 0. The initial value for all other
//       generic vertex attributes is (0,0,0,1).
//
// All of the parameters except GL.CURRENT_VERTEX_ATTRIB represent
// client-side state.
//
// Error GL.INVALID_VALUE is generated if index is greater than or equal to
// GL.MAX_VERTEX_ATTRIBS. GL.INVALID_ENUM is generated if pname is not an
// accepted value.  GL.INVALID_OPERATION is generated if index is 0 and pname
// is GL.CURRENT_VERTEX_ATTRIB.
//
// GetVertexAttrib is available only if the GL version is 2.0 or greater.
//
// https://www.opengl.org/sdk/docs/man2/xhtml/glGetVertexAttribdv.xml
func (gl *GL) GetVertexAttribdv(index glbase.Attrib, pname glbase.Enum) (params float64) {
	C.gl4_3core_glGetVertexAttribdv(gl.funcs, C.GLuint(index), C.GLenum(pname), (*C.GLdouble)(unsafe.Pointer(&params)))
	return params
}

// GetUniformiv returns in params the value of the specified uniform
// variable. The type of the uniform variable specified by location
// determines the number of values returned. If the uniform variable is
// defined in the shader as a boolean, int, or float, a single value will be
// returned. If it is defined as a vec2, ivec2, or bvec2, two values will be
// returned. If it is defined as a vec3, ivec3, or bvec3, three values will
// be returned, and so on. To query values stored in uniform variables
// declared as arrays, call glGetUniformiv for each element of the array. To
// query values stored in uniform variables declared as structures, call
// glGetUniformiv for each field in the structure. The values for uniform
// variables declared as a matrix will be returned in column major order.
//
// The locations assigned to uniform variables are not known until the
// program object is linked. After linking has occurred, the command
// GetUniformLocation can be used to obtain the location of a uniform
// variable. This location value can then be passed to glGetUniformiv in order
// to query the current value of the uniform variable. After a program object
// has been linked successfully, the index values for uniform variables
// remain fixed until the next link command occurs. The uniform variable
// values can only be queried after a link if the link was successful.
//
// Error GL.INVALID_VALUE is generated if program is not a value generated by
// OpenGL. GL.INVALID_OPERATION is generated if program is not a program
// object. GL.INVALID_OPERATION is generated if program has not been
// successfully linked. GL.INVALID_OPERATION is generated if location does
// not correspond to a valid uniform variable location for the specified
// program object. GL.INVALID_OPERATION is generated if glGetUniformiv is
// executed between the execution of Begin and the corresponding execution of
// End.
//
// glGetUniformiv is available only if the GL version is 2.0 or greater.
//
// See also GetActiveUniform, GetUniformLocation, GetProgram, CreateProgram,
// LinkProgram.
//
// https://www.opengl.org/sdk/docs/man2/xhtml/glGetUniformiv.xml
func (gl *GL) GetUniformiv(program glbase.Program, location glbase.Uniform, params []int32) {
	var params_c [4]int32
	C.gl4_3core_glGetUniformiv(gl.funcs, C.GLuint(program), C.GLint(location), (*C.GLint)(unsafe.Pointer(&params_c[0])))
	copy(params, params_c[:])
}

// GetUniformfv returns in params the value of the specified uniform
// variable. The type of the uniform variable specified by location
// determines the number of values returned. If the uniform variable is
// defined in the shader as a boolean, int, or float, a single value will be
// returned. If it is defined as a vec2, ivec2, or bvec2, two values will be
// returned. If it is defined as a vec3, ivec3, or bvec3, three values will
// be returned, and so on. To query values stored in uniform variables
// declared as arrays, call glGetUniformfv for each element of the array. To
// query values stored in uniform variables declared as structures, call
// glGetUniformfv for each field in the structure. The values for uniform
// variables declared as a matrix will be returned in column major order.
//
// The locations assigned to uniform variables are not known until the
// program object is linked. After linking has occurred, the command
// GetUniformLocation can be used to obtain the location of a uniform
// variable. This location value can then be passed to glGetUniformfv in order
// to query the current value of the uniform variable. After a program object
// has been linked successfully, the index values for uniform variables
// remain fixed until the next link command occurs. The uniform variable
// values can only be queried after a link if the link was successful.
//
// Error GL.INVALID_VALUE is generated if program is not a value generated by
// OpenGL. GL.INVALID_OPERATION is generated if program is not a program
// object. GL.INVALID_OPERATION is generated if program has not been
// successfully linked. GL.INVALID_OPERATION is generated if location does
// not correspond to a valid uniform variable location for the specified
// program object. GL.INVALID_OPERATION is generated if glGetUniformfv is
// executed between the execution of Begin and the corresponding execution of
// End.
//
// glGetUniformfv is available only if the GL version is 2.0 or greater.
//
// See also GetActiveUniform, GetUniformLocation, GetProgram, CreateProgram,
// LinkProgram.
//
// https://www.opengl.org/sdk/docs/man2/xhtml/glGetUniformfv.xml
func (gl *GL) GetUniformfv(program glbase.Program, location glbase.Uniform, params []float32) {
	var params_c [4]float32
	C.gl4_3core_glGetUniformfv(gl.funcs, C.GLuint(program), C.GLint(location), (*C.GLfloat)(unsafe.Pointer(&params_c[0])))
	copy(params, params_c[:])
}

// GetUniformLocation returns an integer that represents the location of a
// specific uniform variable within a program object. name must be an active
// uniform variable name in program that is not a structure, an array of
// structures, or a subcomponent of a vector or a matrix. This function
// returns -1 if name does not correspond to an active uniform variable in
// program or if name starts with the reserved prefix "gl_".
//
// Uniform variables that are structures or arrays of structures may be
// queried by calling GetUniformLocation for each field within the
// structure. The array element operator "[]" and the structure field
// operator "." may be used in name in order to select elements within an
// array or fields within a structure. The result of using these operators is
// not allowed to be another structure, an array of structures, or a
// subcomponent of a vector or a matrix. Except if the last part of name
// indicates a uniform variable array, the location of the first element of
// an array can be retrieved by using the name of the array, or by using the
// name appended by "[0]".
//
// The actual locations assigned to uniform variables are not known until the
// program object is linked successfully. After linking has occurred, the
// command GetUniformLocation can be used to obtain the location of a
// uniform variable. This location value can then be passed to glUniform to
// set the value of the uniform variable or to GetUniform in order to query
// the current value of the uniform variable. After a program object has been
// linked successfully, the index values for uniform variables remain fixed
// until the next link command occurs. Uniform variable locations and values
// can only be queried after a link if the link was successful.
//
// Error GL.INVALID_VALUE is generated if program is not a value generated by
// OpenGL. GL.INVALID_OPERATION is generated if program is not a program object.
// GL.INVALID_OPERATION is generated if program has not been successfully
// linked. GL.INVALID_OPERATION is generated if GetUniformLocation is executed
// between the execution of glBegin and the corresponding execution of glEnd.
//
// GetUniformLocation is available only if the GL version is 2.0 or greater.
//
// See also GetActiveUniform, GetProgram, GetUniform, LinkProgram.
//
// https://www.opengl.org/sdk/docs/man2/xhtml/glGetUniformLocation.xml
func (gl *GL) GetUniformLocation(program glbase.Program, name string) glbase.Uniform {
	name_cstr := C.CString(name)
	glresult := C.gl4_3core_glGetUniformLocation(gl.funcs, C.GLuint(program), (*C.GLchar)(name_cstr))
	C.free(unsafe.Pointer(name_cstr))
	return glbase.Uniform(glresult)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetShaderSource.xml
func (gl *GL) GetShaderSource(shader glbase.Shader, bufSize int32, length []int32, source []byte) {
	C.gl4_3core_glGetShaderSource(gl.funcs, C.GLuint(shader), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLchar)(unsafe.Pointer(&source[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetShaderInfoLog.xml
func (gl *GL) GetShaderInfoLog(shader glbase.Shader, bufSize int32, length []int32, infoLog []byte) {
	C.gl4_3core_glGetShaderInfoLog(gl.funcs, C.GLuint(shader), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLchar)(unsafe.Pointer(&infoLog[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetShaderiv.xml
func (gl *GL) GetShaderiv(shader glbase.Shader, pname glbase.Enum, params []int32) {
	C.gl4_3core_glGetShaderiv(gl.funcs, C.GLuint(shader), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetProgramInfoLog.xml
func (gl *GL) GetProgramInfoLog(program glbase.Program, bufSize int32, length []int32, infoLog []byte) {
	C.gl4_3core_glGetProgramInfoLog(gl.funcs, C.GLuint(program), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLchar)(unsafe.Pointer(&infoLog[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetProgramiv.xml
func (gl *GL) GetProgramiv(program glbase.Program, pname glbase.Enum, params []int32) {
	C.gl4_3core_glGetProgramiv(gl.funcs, C.GLuint(program), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// GetAttribLocation queries the previously linked program object specified
// by program for the attribute variable specified by name and returns the
// index of the generic vertex attribute that is bound to that attribute
// variable. If name is a matrix attribute variable, the index of the first
// column of the matrix is returned. If the named attribute variable is not
// an active attribute in the specified program object or if name starts with
// the reserved prefix "gl_", a value of -1 is returned.
//
// The association between an attribute variable name and a generic attribute
// index can be specified at any time by calling BindAttribLocation.
// Attribute bindings do not go into effect until LinkProgram is called.
// After a program object has been linked successfully, the index values for
// attribute variables remain fixed until the next link command occurs. The
// attribute values can only be queried after a link if the link was
// successful. GetAttribLocation returns the binding that actually went
// into effect the last time glLinkProgram was called for the specified
// program object. Attribute bindings that have been specified since the last
// link operation are not returned by GetAttribLocation.
//
// Error GL_INVALID_OPERATION is generated if program is not a value
// generated by OpenGL. GL_INVALID_OPERATION is generated if program is not
// a program object. GL_INVALID_OPERATION is generated if program has not
// been successfully linked.  GL_INVALID_OPERATION is generated if
// GetAttribLocation is executed between the execution of glBegin and the
// corresponding execution of glEnd.
//
// GetAttribLocation is available only if the GL version is 2.0 or greater.
//
// See also GetActiveAttrib, BindAttribLocation, LinkProgram, VertexAttrib,
// VertexAttribPointer.
//
// https://www.opengl.org/sdk/docs/man2/xhtml/glGetAttribLocation.xml
func (gl *GL) GetAttribLocation(program glbase.Program, name string) glbase.Attrib {
	name_cstr := C.CString(name)
	glresult := C.gl4_3core_glGetAttribLocation(gl.funcs, C.GLuint(program), (*C.GLchar)(name_cstr))
	C.free(unsafe.Pointer(name_cstr))
	return glbase.Attrib(glresult)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetAttachedShaders.xml
func (gl *GL) GetAttachedShaders(program glbase.Program, maxCount int32, count []int32, obj []uint32) {
	C.gl4_3core_glGetAttachedShaders(gl.funcs, C.GLuint(program), C.GLsizei(maxCount), (*C.GLsizei)(unsafe.Pointer(&count[0])), (*C.GLuint)(unsafe.Pointer(&obj[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetActiveUniform.xml
func (gl *GL) GetActiveUniform(program glbase.Program, index uint32, bufSize int32, length, size []int32, gltype []glbase.Enum, name []byte) {
	C.gl4_3core_glGetActiveUniform(gl.funcs, C.GLuint(program), C.GLuint(index), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLint)(unsafe.Pointer(&size[0])), (*C.GLenum)(unsafe.Pointer(&gltype[0])), (*C.GLchar)(unsafe.Pointer(&name[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetActiveAttrib.xml
func (gl *GL) GetActiveAttrib(program glbase.Program, index glbase.Attrib, bufSize int32, length, size []int32, gltype []glbase.Enum, name []byte) {
	C.gl4_3core_glGetActiveAttrib(gl.funcs, C.GLuint(program), C.GLuint(index), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLint)(unsafe.Pointer(&size[0])), (*C.GLenum)(unsafe.Pointer(&gltype[0])), (*C.GLchar)(unsafe.Pointer(&name[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEnableVertexAttribArray.xml
func (gl *GL) EnableVertexAttribArray(index glbase.Attrib) {
	C.gl4_3core_glEnableVertexAttribArray(gl.funcs, C.GLuint(index))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDisableVertexAttribArray.xml
func (gl *GL) DisableVertexAttribArray(index glbase.Attrib) {
	C.gl4_3core_glDisableVertexAttribArray(gl.funcs, C.GLuint(index))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDetachShader.xml
func (gl *GL) DetachShader(program glbase.Program, shader glbase.Shader) {
	C.gl4_3core_glDetachShader(gl.funcs, C.GLuint(program), C.GLuint(shader))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteShader.xml
func (gl *GL) DeleteShader(shader glbase.Shader) {
	C.gl4_3core_glDeleteShader(gl.funcs, C.GLuint(shader))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteProgram.xml
func (gl *GL) DeleteProgram(program glbase.Program) {
	C.gl4_3core_glDeleteProgram(gl.funcs, C.GLuint(program))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCreateShader.xml
func (gl *GL) CreateShader(gltype glbase.Enum) glbase.Shader {
	glresult := C.gl4_3core_glCreateShader(gl.funcs, C.GLenum(gltype))
	return glbase.Shader(glresult)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCreateProgram.xml
func (gl *GL) CreateProgram() glbase.Program {
	glresult := C.gl4_3core_glCreateProgram(gl.funcs)
	return glbase.Program(glresult)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCompileShader.xml
func (gl *GL) CompileShader(shader glbase.Shader) {
	C.gl4_3core_glCompileShader(gl.funcs, C.GLuint(shader))
}

// BindAttribLocation associates a user-defined attribute variable in the program
// object specified by program with a generic vertex attribute index. The name
// parameter specifies the name of the vertex shader attribute variable to
// which index is to be bound. When program is made part of the current state,
// values provided via the generic vertex attribute index will modify the
// value of the user-defined attribute variable specified by name.
//
// If name refers to a matrix attribute variable, index refers to the first
// column of the matrix. Other matrix columns are then automatically bound to
// locations index+1 for a matrix of type mat2; index+1 and index+2 for a
// matrix of type mat3; and index+1, index+2, and index+3 for a matrix of
// type mat4.
//
// This command makes it possible for vertex shaders to use descriptive names
// for attribute variables rather than generic variables that are numbered
// from 0 to GL.MAX_VERTEX_ATTRIBS-1. The values sent to each generic
// attribute index are part of current state, just like standard vertex
// attributes such as color, normal, and vertex position. If a different
// program object is made current by calling UseProgram, the generic vertex
// attributes are tracked in such a way that the same values will be observed
// by attributes in the new program object that are also bound to index.
//
// Attribute variable name-to-generic attribute index bindings for a program
// object can be explicitly assigned at any time by calling
// BindAttribLocation. Attribute bindings do not go into effect until
// LinkProgram is called. After a program object has been linked
// successfully, the index values for generic attributes remain fixed (and
// their values can be queried) until the next link command occurs.
//
// Applications are not allowed to bind any of the standard OpenGL vertex
// attributes using this command, as they are bound automatically when
// needed. Any attribute binding that occurs after the program object has
// been linked will not take effect until the next time the program object is
// linked.
//
// If name was bound previously, that information is lost. Thus you cannot
// bind one user-defined attribute variable to multiple indices, but you can
// bind multiple user-defined attribute variables to the same index.
//
// Applications are allowed to bind more than one user-defined attribute
// variable to the same generic vertex attribute index. This is called
// aliasing, and it is allowed only if just one of the aliased attributes is
// active in the executable program, or if no path through the shader
// consumes more than one attribute of a set of attributes aliased to the
// same location. The compiler and linker are allowed to assume that no
// aliasing is done and are free to employ optimizations that work only in
// the absence of aliasing. OpenGL implementations are not required to do
// error checking to detect aliasing. Because there is no way to bind
// standard attributes, it is not possible to alias generic attributes with
// conventional ones (except for generic attribute 0).
//
// BindAttribLocation can be called before any vertex shader objects are
// bound to the specified program object. It is also permissible to bind a
// generic attribute index to an attribute variable name that is never used
// in a vertex shader.
//
// Active attributes that are not explicitly bound will be bound by the
// linker when LinkProgram is called. The locations assigned can be queried
// by calling GetAttribLocation.
//
// Error GL.INVALID_VALUE is generated if index is greater than or equal to
// GL.MAX_VERTEX_ATTRIBS.
// GL.INVALID_OPERATION is generated if name starts with the reserved prefix "gl_".
// GL.INVALID_VALUE is generated if program is not a value generated by OpenGL.
// GL.INVALID_OPERATION is generated if program is not a program object.
// GL.INVALID_OPERATION is generated if BindAttribLocation is executed
// between the execution of Begin and the corresponding execution of End.
//
// BindAttribLocation is available only if the GL version is 2.0 or greater.
//
// See also GetActiveAttrib, GetAttribLocation, EnableVertexAttribArray,
// DisableVertexAttribArray, VertexAttrib, VertexAttribPointer.
//
// https://www.opengl.org/sdk/docs/man2/xhtml/glBindAttribLocation.xml
func (gl *GL) BindAttribLocation(program glbase.Program, index glbase.Attrib, name string) {
	name_cstr := C.CString(name)
	C.gl4_3core_glBindAttribLocation(gl.funcs, C.GLuint(program), C.GLuint(index), (*C.GLchar)(name_cstr))
	C.free(unsafe.Pointer(name_cstr))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glAttachShader.xml
func (gl *GL) AttachShader(program glbase.Program, shader glbase.Shader) {
	C.gl4_3core_glAttachShader(gl.funcs, C.GLuint(program), C.GLuint(shader))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glStencilMaskSeparate.xml
func (gl *GL) StencilMaskSeparate(face glbase.Enum, mask uint32) {
	C.gl4_3core_glStencilMaskSeparate(gl.funcs, C.GLenum(face), C.GLuint(mask))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glStencilFuncSeparate.xml
func (gl *GL) StencilFuncSeparate(face, glfunc glbase.Enum, ref int32, mask uint32) {
	C.gl4_3core_glStencilFuncSeparate(gl.funcs, C.GLenum(face), C.GLenum(glfunc), C.GLint(ref), C.GLuint(mask))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glStencilOpSeparate.xml
func (gl *GL) StencilOpSeparate(face, sfail, dpfail, dppass glbase.Enum) {
	C.gl4_3core_glStencilOpSeparate(gl.funcs, C.GLenum(face), C.GLenum(sfail), C.GLenum(dpfail), C.GLenum(dppass))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawBuffers.xml
func (gl *GL) DrawBuffers(n int32, bufs []glbase.Enum) {
	C.gl4_3core_glDrawBuffers(gl.funcs, C.GLsizei(n), (*C.GLenum)(unsafe.Pointer(&bufs[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBlendEquationSeparate.xml
func (gl *GL) BlendEquationSeparate(modeRGB, modeAlpha glbase.Enum) {
	C.gl4_3core_glBlendEquationSeparate(gl.funcs, C.GLenum(modeRGB), C.GLenum(modeAlpha))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsVertexArray.xml
func (gl *GL) IsVertexArray(array uint32) bool {
	glresult := C.gl4_3core_glIsVertexArray(gl.funcs, C.GLuint(array))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGenVertexArrays.xml
func (gl *GL) GenVertexArrays(n int32, arrays []uint32) {
	C.gl4_3core_glGenVertexArrays(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&arrays[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteVertexArrays.xml
func (gl *GL) DeleteVertexArrays(n int32, arrays []uint32) {
	C.gl4_3core_glDeleteVertexArrays(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&arrays[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindVertexArray.xml
func (gl *GL) BindVertexArray(array uint32) {
	C.gl4_3core_glBindVertexArray(gl.funcs, C.GLuint(array))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFlushMappedBufferRange.xml
func (gl *GL) FlushMappedBufferRange(target glbase.Enum, offset, length int) {
	C.gl4_3core_glFlushMappedBufferRange(gl.funcs, C.GLenum(target), C.GLintptr(offset), C.GLsizeiptr(length))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFramebufferTextureLayer.xml
func (gl *GL) FramebufferTextureLayer(target, attachment glbase.Enum, texture glbase.Texture, level, layer int32) {
	C.gl4_3core_glFramebufferTextureLayer(gl.funcs, C.GLenum(target), C.GLenum(attachment), C.GLuint(texture), C.GLint(level), C.GLint(layer))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRenderbufferStorageMultisample.xml
func (gl *GL) RenderbufferStorageMultisample(target glbase.Enum, samples int32, internalformat glbase.Enum, width, height int32) {
	C.gl4_3core_glRenderbufferStorageMultisample(gl.funcs, C.GLenum(target), C.GLsizei(samples), C.GLenum(internalformat), C.GLsizei(width), C.GLsizei(height))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBlitFramebuffer.xml
func (gl *GL) BlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1 int32, mask glbase.Bitfield, filter glbase.Enum) {
	C.gl4_3core_glBlitFramebuffer(gl.funcs, C.GLint(srcX0), C.GLint(srcY0), C.GLint(srcX1), C.GLint(srcY1), C.GLint(dstX0), C.GLint(dstY0), C.GLint(dstX1), C.GLint(dstY1), C.GLbitfield(mask), C.GLenum(filter))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGenerateMipmap.xml
func (gl *GL) GenerateMipmap(target glbase.Enum) {
	C.gl4_3core_glGenerateMipmap(gl.funcs, C.GLenum(target))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetFramebufferAttachmentParameteriv.xml
func (gl *GL) GetFramebufferAttachmentParameteriv(target, attachment, pname glbase.Enum, params []int32) {
	C.gl4_3core_glGetFramebufferAttachmentParameteriv(gl.funcs, C.GLenum(target), C.GLenum(attachment), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFramebufferRenderbuffer.xml
func (gl *GL) FramebufferRenderbuffer(target, attachment, renderbuffertarget glbase.Enum, renderbuffer uint32) {
	C.gl4_3core_glFramebufferRenderbuffer(gl.funcs, C.GLenum(target), C.GLenum(attachment), C.GLenum(renderbuffertarget), C.GLuint(renderbuffer))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFramebufferTexture3D.xml
func (gl *GL) FramebufferTexture3D(target, attachment, textarget glbase.Enum, texture glbase.Texture, level, zoffset int32) {
	C.gl4_3core_glFramebufferTexture3D(gl.funcs, C.GLenum(target), C.GLenum(attachment), C.GLenum(textarget), C.GLuint(texture), C.GLint(level), C.GLint(zoffset))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFramebufferTexture2D.xml
func (gl *GL) FramebufferTexture2D(target, attachment, textarget glbase.Enum, texture glbase.Texture, level int32) {
	C.gl4_3core_glFramebufferTexture2D(gl.funcs, C.GLenum(target), C.GLenum(attachment), C.GLenum(textarget), C.GLuint(texture), C.GLint(level))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFramebufferTexture1D.xml
func (gl *GL) FramebufferTexture1D(target, attachment, textarget glbase.Enum, texture glbase.Texture, level int32) {
	C.gl4_3core_glFramebufferTexture1D(gl.funcs, C.GLenum(target), C.GLenum(attachment), C.GLenum(textarget), C.GLuint(texture), C.GLint(level))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCheckFramebufferStatus.xml
func (gl *GL) CheckFramebufferStatus(target glbase.Enum) glbase.Enum {
	glresult := C.gl4_3core_glCheckFramebufferStatus(gl.funcs, C.GLenum(target))
	return glbase.Enum(glresult)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGenFramebuffers.xml
func (gl *GL) GenFramebuffers(n int32, framebuffers []uint32) {
	C.gl4_3core_glGenFramebuffers(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&framebuffers[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteFramebuffers.xml
func (gl *GL) DeleteFramebuffers(n int32, framebuffers []uint32) {
	C.gl4_3core_glDeleteFramebuffers(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&framebuffers[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindFramebuffer.xml
func (gl *GL) BindFramebuffer(target glbase.Enum, framebuffer uint32) {
	C.gl4_3core_glBindFramebuffer(gl.funcs, C.GLenum(target), C.GLuint(framebuffer))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsFramebuffer.xml
func (gl *GL) IsFramebuffer(framebuffer uint32) bool {
	glresult := C.gl4_3core_glIsFramebuffer(gl.funcs, C.GLuint(framebuffer))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetRenderbufferParameteriv.xml
func (gl *GL) GetRenderbufferParameteriv(target, pname glbase.Enum, params []int32) {
	C.gl4_3core_glGetRenderbufferParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRenderbufferStorage.xml
func (gl *GL) RenderbufferStorage(target, internalformat glbase.Enum, width, height int32) {
	C.gl4_3core_glRenderbufferStorage(gl.funcs, C.GLenum(target), C.GLenum(internalformat), C.GLsizei(width), C.GLsizei(height))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGenRenderbuffers.xml
func (gl *GL) GenRenderbuffers(n int32, renderbuffers []uint32) {
	C.gl4_3core_glGenRenderbuffers(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&renderbuffers[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteRenderbuffers.xml
func (gl *GL) DeleteRenderbuffers(n int32, renderbuffers []uint32) {
	C.gl4_3core_glDeleteRenderbuffers(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&renderbuffers[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindRenderbuffer.xml
func (gl *GL) BindRenderbuffer(target glbase.Enum, renderbuffer uint32) {
	C.gl4_3core_glBindRenderbuffer(gl.funcs, C.GLenum(target), C.GLuint(renderbuffer))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsRenderbuffer.xml
func (gl *GL) IsRenderbuffer(renderbuffer uint32) bool {
	glresult := C.gl4_3core_glIsRenderbuffer(gl.funcs, C.GLuint(renderbuffer))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClearBufferfi.xml
func (gl *GL) ClearBufferfi(buffer glbase.Enum, drawbuffer int32, depth float32, stencil int32) {
	C.gl4_3core_glClearBufferfi(gl.funcs, C.GLenum(buffer), C.GLint(drawbuffer), C.GLfloat(depth), C.GLint(stencil))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClearBufferfv.xml
func (gl *GL) ClearBufferfv(buffer glbase.Enum, drawbuffer int32, value []float32) {
	C.gl4_3core_glClearBufferfv(gl.funcs, C.GLenum(buffer), C.GLint(drawbuffer), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClearBufferuiv.xml
func (gl *GL) ClearBufferuiv(buffer glbase.Enum, drawbuffer int32, value []uint32) {
	C.gl4_3core_glClearBufferuiv(gl.funcs, C.GLenum(buffer), C.GLint(drawbuffer), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClearBufferiv.xml
func (gl *GL) ClearBufferiv(buffer glbase.Enum, drawbuffer int32, value []int32) {
	C.gl4_3core_glClearBufferiv(gl.funcs, C.GLenum(buffer), C.GLint(drawbuffer), (*C.GLint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetTexParameterIuiv.xml
func (gl *GL) GetTexParameterIuiv(target, pname glbase.Enum, params []uint32) {
	C.gl4_3core_glGetTexParameterIuiv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLuint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetTexParameterIiv.xml
func (gl *GL) GetTexParameterIiv(target, pname glbase.Enum, params []int32) {
	C.gl4_3core_glGetTexParameterIiv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexParameterIuiv.xml
func (gl *GL) TexParameterIuiv(target, pname glbase.Enum, params []uint32) {
	C.gl4_3core_glTexParameterIuiv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLuint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexParameterIiv.xml
func (gl *GL) TexParameterIiv(target, pname glbase.Enum, params []int32) {
	C.gl4_3core_glTexParameterIiv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform4ui.xml
func (gl *GL) Uniform4ui(location glbase.Uniform, v0, v1, v2, v3 uint32) {
	C.gl4_3core_glUniform4ui(gl.funcs, C.GLint(location), C.GLuint(v0), C.GLuint(v1), C.GLuint(v2), C.GLuint(v3))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform3ui.xml
func (gl *GL) Uniform3ui(location glbase.Uniform, v0, v1, v2 uint32) {
	C.gl4_3core_glUniform3ui(gl.funcs, C.GLint(location), C.GLuint(v0), C.GLuint(v1), C.GLuint(v2))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform2ui.xml
func (gl *GL) Uniform2ui(location glbase.Uniform, v0, v1 uint32) {
	C.gl4_3core_glUniform2ui(gl.funcs, C.GLint(location), C.GLuint(v0), C.GLuint(v1))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform1ui.xml
func (gl *GL) Uniform1ui(location glbase.Uniform, v0 uint32) {
	C.gl4_3core_glUniform1ui(gl.funcs, C.GLint(location), C.GLuint(v0))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetFragDataLocation.xml
func (gl *GL) GetFragDataLocation(program glbase.Program, name []byte) int32 {
	glresult := C.gl4_3core_glGetFragDataLocation(gl.funcs, C.GLuint(program), (*C.GLchar)(unsafe.Pointer(&name[0])))
	return int32(glresult)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindFragDataLocation.xml
func (gl *GL) BindFragDataLocation(program glbase.Program, color uint32, name []byte) {
	C.gl4_3core_glBindFragDataLocation(gl.funcs, C.GLuint(program), C.GLuint(color), (*C.GLchar)(unsafe.Pointer(&name[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetUniformuiv.xml
func (gl *GL) GetUniformuiv(program glbase.Program, location glbase.Uniform, params []uint32) {
	C.gl4_3core_glGetUniformuiv(gl.funcs, C.GLuint(program), C.GLint(location), (*C.GLuint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetVertexAttribIuiv.xml
func (gl *GL) GetVertexAttribIuiv(index glbase.Attrib, pname glbase.Enum, params []uint32) {
	C.gl4_3core_glGetVertexAttribIuiv(gl.funcs, C.GLuint(index), C.GLenum(pname), (*C.GLuint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetVertexAttribIiv.xml
func (gl *GL) GetVertexAttribIiv(index glbase.Attrib, pname glbase.Enum, params []int32) {
	C.gl4_3core_glGetVertexAttribIiv(gl.funcs, C.GLuint(index), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribIPointer.xml
func (gl *GL) VertexAttribIPointer(index glbase.Attrib, size int32, gltype glbase.Enum, stride int32, pointer interface{}) {
	pointer_v := reflect.ValueOf(pointer)
	if pointer_v.Kind() != reflect.Slice {
		panic("parameter pointer must be a slice")
	}
	C.gl4_3core_glVertexAttribIPointer(gl.funcs, C.GLuint(index), C.GLint(size), C.GLenum(gltype), C.GLsizei(stride), unsafe.Pointer(pointer_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEndConditionalRender.xml
func (gl *GL) EndConditionalRender() {
	C.gl4_3core_glEndConditionalRender(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBeginConditionalRender.xml
func (gl *GL) BeginConditionalRender(id uint32, mode glbase.Enum) {
	C.gl4_3core_glBeginConditionalRender(gl.funcs, C.GLuint(id), C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClampColor.xml
func (gl *GL) ClampColor(target, clamp glbase.Enum) {
	C.gl4_3core_glClampColor(gl.funcs, C.GLenum(target), C.GLenum(clamp))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetTransformFeedbackVarying.xml
func (gl *GL) GetTransformFeedbackVarying(program glbase.Program, index uint32, bufSize int32, length, size []int32, gltype []glbase.Enum, name []byte) {
	C.gl4_3core_glGetTransformFeedbackVarying(gl.funcs, C.GLuint(program), C.GLuint(index), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLsizei)(unsafe.Pointer(&size[0])), (*C.GLenum)(unsafe.Pointer(&gltype[0])), (*C.GLchar)(unsafe.Pointer(&name[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindBufferBase.xml
func (gl *GL) BindBufferBase(target glbase.Enum, index uint32, buffer glbase.Buffer) {
	C.gl4_3core_glBindBufferBase(gl.funcs, C.GLenum(target), C.GLuint(index), C.GLuint(buffer))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindBufferRange.xml
func (gl *GL) BindBufferRange(target glbase.Enum, index uint32, buffer glbase.Buffer, offset, size int) {
	C.gl4_3core_glBindBufferRange(gl.funcs, C.GLenum(target), C.GLuint(index), C.GLuint(buffer), C.GLintptr(offset), C.GLsizeiptr(size))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEndTransformFeedback.xml
func (gl *GL) EndTransformFeedback() {
	C.gl4_3core_glEndTransformFeedback(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBeginTransformFeedback.xml
func (gl *GL) BeginTransformFeedback(primitiveMode glbase.Enum) {
	C.gl4_3core_glBeginTransformFeedback(gl.funcs, C.GLenum(primitiveMode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsEnabledi.xml
func (gl *GL) IsEnabledi(target glbase.Enum, index uint32) bool {
	glresult := C.gl4_3core_glIsEnabledi(gl.funcs, C.GLenum(target), C.GLuint(index))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDisablei.xml
func (gl *GL) Disablei(target glbase.Enum, index uint32) {
	C.gl4_3core_glDisablei(gl.funcs, C.GLenum(target), C.GLuint(index))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEnablei.xml
func (gl *GL) Enablei(target glbase.Enum, index uint32) {
	C.gl4_3core_glEnablei(gl.funcs, C.GLenum(target), C.GLuint(index))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetIntegeri_v.xml
func (gl *GL) GetIntegeri_v(target glbase.Enum, index uint32, data []int32) {
	C.gl4_3core_glGetIntegeri_v(gl.funcs, C.GLenum(target), C.GLuint(index), (*C.GLint)(unsafe.Pointer(&data[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetBooleani_v.xml
func (gl *GL) GetBooleani_v(target glbase.Enum, index uint32, data []bool) {
	C.gl4_3core_glGetBooleani_v(gl.funcs, C.GLenum(target), C.GLuint(index), (*C.GLboolean)(unsafe.Pointer(&data[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColorMaski.xml
func (gl *GL) ColorMaski(index uint32, r, g, b, a bool) {
	C.gl4_3core_glColorMaski(gl.funcs, C.GLuint(index), *(*C.GLboolean)(unsafe.Pointer(&r)), *(*C.GLboolean)(unsafe.Pointer(&g)), *(*C.GLboolean)(unsafe.Pointer(&b)), *(*C.GLboolean)(unsafe.Pointer(&a)))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCopyBufferSubData.xml
func (gl *GL) CopyBufferSubData(readTarget, writeTarget glbase.Enum, readOffset, writeOffset, size int) {
	C.gl4_3core_glCopyBufferSubData(gl.funcs, C.GLenum(readTarget), C.GLenum(writeTarget), C.GLintptr(readOffset), C.GLintptr(writeOffset), C.GLsizeiptr(size))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniformBlockBinding.xml
func (gl *GL) UniformBlockBinding(program glbase.Program, uniformBlockIndex, uniformBlockBinding uint32) {
	C.gl4_3core_glUniformBlockBinding(gl.funcs, C.GLuint(program), C.GLuint(uniformBlockIndex), C.GLuint(uniformBlockBinding))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetActiveUniformBlockName.xml
func (gl *GL) GetActiveUniformBlockName(program glbase.Program, uniformBlockIndex uint32, bufSize int32, length []int32, uniformBlockName []byte) {
	C.gl4_3core_glGetActiveUniformBlockName(gl.funcs, C.GLuint(program), C.GLuint(uniformBlockIndex), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLchar)(unsafe.Pointer(&uniformBlockName[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetActiveUniformBlockiv.xml
func (gl *GL) GetActiveUniformBlockiv(program glbase.Program, uniformBlockIndex uint32, pname glbase.Enum, params []int32) {
	C.gl4_3core_glGetActiveUniformBlockiv(gl.funcs, C.GLuint(program), C.GLuint(uniformBlockIndex), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetUniformBlockIndex.xml
func (gl *GL) GetUniformBlockIndex(program glbase.Program, uniformBlockName []byte) uint32 {
	glresult := C.gl4_3core_glGetUniformBlockIndex(gl.funcs, C.GLuint(program), (*C.GLchar)(unsafe.Pointer(&uniformBlockName[0])))
	return uint32(glresult)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetActiveUniformName.xml
func (gl *GL) GetActiveUniformName(program glbase.Program, uniformIndex uint32, bufSize int32, length []int32, uniformName []byte) {
	C.gl4_3core_glGetActiveUniformName(gl.funcs, C.GLuint(program), C.GLuint(uniformIndex), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLchar)(unsafe.Pointer(&uniformName[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetActiveUniformsiv.xml
func (gl *GL) GetActiveUniformsiv(program glbase.Program, uniformCount int32, uniformIndices []uint32, pname glbase.Enum, params []int32) {
	C.gl4_3core_glGetActiveUniformsiv(gl.funcs, C.GLuint(program), C.GLsizei(uniformCount), (*C.GLuint)(unsafe.Pointer(&uniformIndices[0])), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPrimitiveRestartIndex.xml
func (gl *GL) PrimitiveRestartIndex(index uint32) {
	C.gl4_3core_glPrimitiveRestartIndex(gl.funcs, C.GLuint(index))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexBuffer.xml
func (gl *GL) TexBuffer(target, internalformat glbase.Enum, buffer glbase.Buffer) {
	C.gl4_3core_glTexBuffer(gl.funcs, C.GLenum(target), C.GLenum(internalformat), C.GLuint(buffer))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawElementsInstanced.xml
func (gl *GL) DrawElementsInstanced(mode glbase.Enum, count int32, gltype glbase.Enum, indices interface{}, instancecount int32) {
	indices_v := reflect.ValueOf(indices)
	if indices_v.Kind() != reflect.Slice {
		panic("parameter indices must be a slice")
	}
	C.gl4_3core_glDrawElementsInstanced(gl.funcs, C.GLenum(mode), C.GLsizei(count), C.GLenum(gltype), unsafe.Pointer(indices_v.Index(0).Addr().Pointer()), C.GLsizei(instancecount))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawArraysInstanced.xml
func (gl *GL) DrawArraysInstanced(mode glbase.Enum, first, count, instancecount int32) {
	C.gl4_3core_glDrawArraysInstanced(gl.funcs, C.GLenum(mode), C.GLint(first), C.GLsizei(count), C.GLsizei(instancecount))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSampleMaski.xml
func (gl *GL) SampleMaski(index uint32, mask glbase.Bitfield) {
	C.gl4_3core_glSampleMaski(gl.funcs, C.GLuint(index), C.GLbitfield(mask))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetMultisamplefv.xml
func (gl *GL) GetMultisamplefv(pname glbase.Enum, index uint32, val []float32) {
	C.gl4_3core_glGetMultisamplefv(gl.funcs, C.GLenum(pname), C.GLuint(index), (*C.GLfloat)(unsafe.Pointer(&val[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexImage3DMultisample.xml
func (gl *GL) TexImage3DMultisample(target glbase.Enum, samples, internalformat, width, height, depth int32, fixedsamplelocations bool) {
	C.gl4_3core_glTexImage3DMultisample(gl.funcs, C.GLenum(target), C.GLsizei(samples), C.GLint(internalformat), C.GLsizei(width), C.GLsizei(height), C.GLsizei(depth), *(*C.GLboolean)(unsafe.Pointer(&fixedsamplelocations)))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexImage2DMultisample.xml
func (gl *GL) TexImage2DMultisample(target glbase.Enum, samples, internalformat, width, height int32, fixedsamplelocations bool) {
	C.gl4_3core_glTexImage2DMultisample(gl.funcs, C.GLenum(target), C.GLsizei(samples), C.GLint(internalformat), C.GLsizei(width), C.GLsizei(height), *(*C.GLboolean)(unsafe.Pointer(&fixedsamplelocations)))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetSynciv.xml
func (gl *GL) GetSynciv(sync glbase.Sync, pname glbase.Enum, bufSize int32, length, values []int32) {
	C.gl4_3core_glGetSynciv(gl.funcs, C.GLsync(sync), C.GLenum(pname), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLint)(unsafe.Pointer(&values[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetInteger64v.xml
func (gl *GL) GetInteger64v(pname glbase.Enum, params []int64) {
	C.gl4_3core_glGetInteger64v(gl.funcs, C.GLenum(pname), (*C.GLint64)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glWaitSync.xml
func (gl *GL) WaitSync(sync glbase.Sync, flags glbase.Bitfield, timeout uint64) {
	C.gl4_3core_glWaitSync(gl.funcs, C.GLsync(sync), C.GLbitfield(flags), C.GLuint64(timeout))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClientWaitSync.xml
func (gl *GL) ClientWaitSync(sync glbase.Sync, flags glbase.Bitfield, timeout uint64) glbase.Enum {
	glresult := C.gl4_3core_glClientWaitSync(gl.funcs, C.GLsync(sync), C.GLbitfield(flags), C.GLuint64(timeout))
	return glbase.Enum(glresult)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteSync.xml
func (gl *GL) DeleteSync(sync glbase.Sync) {
	C.gl4_3core_glDeleteSync(gl.funcs, C.GLsync(sync))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsSync.xml
func (gl *GL) IsSync(sync glbase.Sync) bool {
	glresult := C.gl4_3core_glIsSync(gl.funcs, C.GLsync(sync))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFenceSync.xml
func (gl *GL) FenceSync(condition glbase.Enum, flags glbase.Bitfield) glbase.Sync {
	glresult := C.gl4_3core_glFenceSync(gl.funcs, C.GLenum(condition), C.GLbitfield(flags))
	return glbase.Sync(glresult)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProvokingVertex.xml
func (gl *GL) ProvokingVertex(mode glbase.Enum) {
	C.gl4_3core_glProvokingVertex(gl.funcs, C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawElementsInstancedBaseVertex.xml
func (gl *GL) DrawElementsInstancedBaseVertex(mode glbase.Enum, count int32, gltype glbase.Enum, indices interface{}, instancecount, basevertex int32) {
	indices_v := reflect.ValueOf(indices)
	if indices_v.Kind() != reflect.Slice {
		panic("parameter indices must be a slice")
	}
	C.gl4_3core_glDrawElementsInstancedBaseVertex(gl.funcs, C.GLenum(mode), C.GLsizei(count), C.GLenum(gltype), unsafe.Pointer(indices_v.Index(0).Addr().Pointer()), C.GLsizei(instancecount), C.GLint(basevertex))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawRangeElementsBaseVertex.xml
func (gl *GL) DrawRangeElementsBaseVertex(mode glbase.Enum, start, end uint32, count int32, gltype glbase.Enum, indices interface{}, basevertex int32) {
	indices_v := reflect.ValueOf(indices)
	if indices_v.Kind() != reflect.Slice {
		panic("parameter indices must be a slice")
	}
	C.gl4_3core_glDrawRangeElementsBaseVertex(gl.funcs, C.GLenum(mode), C.GLuint(start), C.GLuint(end), C.GLsizei(count), C.GLenum(gltype), unsafe.Pointer(indices_v.Index(0).Addr().Pointer()), C.GLint(basevertex))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawElementsBaseVertex.xml
func (gl *GL) DrawElementsBaseVertex(mode glbase.Enum, count int32, gltype glbase.Enum, indices interface{}, basevertex int32) {
	indices_v := reflect.ValueOf(indices)
	if indices_v.Kind() != reflect.Slice {
		panic("parameter indices must be a slice")
	}
	C.gl4_3core_glDrawElementsBaseVertex(gl.funcs, C.GLenum(mode), C.GLsizei(count), C.GLenum(gltype), unsafe.Pointer(indices_v.Index(0).Addr().Pointer()), C.GLint(basevertex))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFramebufferTexture.xml
func (gl *GL) FramebufferTexture(target, attachment glbase.Enum, texture glbase.Texture, level int32) {
	C.gl4_3core_glFramebufferTexture(gl.funcs, C.GLenum(target), C.GLenum(attachment), C.GLuint(texture), C.GLint(level))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetBufferParameteri64v.xml
func (gl *GL) GetBufferParameteri64v(target, pname glbase.Enum, params []int64) {
	C.gl4_3core_glGetBufferParameteri64v(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint64)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetInteger64i_v.xml
func (gl *GL) GetInteger64i_v(target glbase.Enum, index uint32, data []int64) {
	C.gl4_3core_glGetInteger64i_v(gl.funcs, C.GLenum(target), C.GLuint(index), (*C.GLint64)(unsafe.Pointer(&data[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribP4uiv.xml
func (gl *GL) VertexAttribP4uiv(index glbase.Attrib, gltype glbase.Enum, normalized bool, value []uint32) {
	C.gl4_3core_glVertexAttribP4uiv(gl.funcs, C.GLuint(index), C.GLenum(gltype), *(*C.GLboolean)(unsafe.Pointer(&normalized)), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribP4ui.xml
func (gl *GL) VertexAttribP4ui(index glbase.Attrib, gltype glbase.Enum, normalized bool, value uint32) {
	C.gl4_3core_glVertexAttribP4ui(gl.funcs, C.GLuint(index), C.GLenum(gltype), *(*C.GLboolean)(unsafe.Pointer(&normalized)), C.GLuint(value))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribP3uiv.xml
func (gl *GL) VertexAttribP3uiv(index glbase.Attrib, gltype glbase.Enum, normalized bool, value []uint32) {
	C.gl4_3core_glVertexAttribP3uiv(gl.funcs, C.GLuint(index), C.GLenum(gltype), *(*C.GLboolean)(unsafe.Pointer(&normalized)), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribP3ui.xml
func (gl *GL) VertexAttribP3ui(index glbase.Attrib, gltype glbase.Enum, normalized bool, value uint32) {
	C.gl4_3core_glVertexAttribP3ui(gl.funcs, C.GLuint(index), C.GLenum(gltype), *(*C.GLboolean)(unsafe.Pointer(&normalized)), C.GLuint(value))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribP2uiv.xml
func (gl *GL) VertexAttribP2uiv(index glbase.Attrib, gltype glbase.Enum, normalized bool, value []uint32) {
	C.gl4_3core_glVertexAttribP2uiv(gl.funcs, C.GLuint(index), C.GLenum(gltype), *(*C.GLboolean)(unsafe.Pointer(&normalized)), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribP2ui.xml
func (gl *GL) VertexAttribP2ui(index glbase.Attrib, gltype glbase.Enum, normalized bool, value uint32) {
	C.gl4_3core_glVertexAttribP2ui(gl.funcs, C.GLuint(index), C.GLenum(gltype), *(*C.GLboolean)(unsafe.Pointer(&normalized)), C.GLuint(value))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribP1uiv.xml
func (gl *GL) VertexAttribP1uiv(index glbase.Attrib, gltype glbase.Enum, normalized bool, value []uint32) {
	C.gl4_3core_glVertexAttribP1uiv(gl.funcs, C.GLuint(index), C.GLenum(gltype), *(*C.GLboolean)(unsafe.Pointer(&normalized)), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribP1ui.xml
func (gl *GL) VertexAttribP1ui(index glbase.Attrib, gltype glbase.Enum, normalized bool, value uint32) {
	C.gl4_3core_glVertexAttribP1ui(gl.funcs, C.GLuint(index), C.GLenum(gltype), *(*C.GLboolean)(unsafe.Pointer(&normalized)), C.GLuint(value))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSecondaryColorP3uiv.xml
func (gl *GL) SecondaryColorP3uiv(gltype glbase.Enum, color []uint32) {
	C.gl4_3core_glSecondaryColorP3uiv(gl.funcs, C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&color[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSecondaryColorP3ui.xml
func (gl *GL) SecondaryColorP3ui(gltype glbase.Enum, color uint32) {
	C.gl4_3core_glSecondaryColorP3ui(gl.funcs, C.GLenum(gltype), C.GLuint(color))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColorP4uiv.xml
func (gl *GL) ColorP4uiv(gltype glbase.Enum, color []uint32) {
	C.gl4_3core_glColorP4uiv(gl.funcs, C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&color[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColorP4ui.xml
func (gl *GL) ColorP4ui(gltype glbase.Enum, color uint32) {
	C.gl4_3core_glColorP4ui(gl.funcs, C.GLenum(gltype), C.GLuint(color))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColorP3uiv.xml
func (gl *GL) ColorP3uiv(gltype glbase.Enum, color []uint32) {
	C.gl4_3core_glColorP3uiv(gl.funcs, C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&color[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColorP3ui.xml
func (gl *GL) ColorP3ui(gltype glbase.Enum, color uint32) {
	C.gl4_3core_glColorP3ui(gl.funcs, C.GLenum(gltype), C.GLuint(color))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glNormalP3uiv.xml
func (gl *GL) NormalP3uiv(gltype glbase.Enum, coords []uint32) {
	C.gl4_3core_glNormalP3uiv(gl.funcs, C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&coords[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glNormalP3ui.xml
func (gl *GL) NormalP3ui(gltype glbase.Enum, coords uint32) {
	C.gl4_3core_glNormalP3ui(gl.funcs, C.GLenum(gltype), C.GLuint(coords))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoordP4uiv.xml
func (gl *GL) MultiTexCoordP4uiv(texture, gltype glbase.Enum, coords []uint32) {
	C.gl4_3core_glMultiTexCoordP4uiv(gl.funcs, C.GLenum(texture), C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&coords[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoordP4ui.xml
func (gl *GL) MultiTexCoordP4ui(texture, gltype glbase.Enum, coords uint32) {
	C.gl4_3core_glMultiTexCoordP4ui(gl.funcs, C.GLenum(texture), C.GLenum(gltype), C.GLuint(coords))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoordP3uiv.xml
func (gl *GL) MultiTexCoordP3uiv(texture, gltype glbase.Enum, coords []uint32) {
	C.gl4_3core_glMultiTexCoordP3uiv(gl.funcs, C.GLenum(texture), C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&coords[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoordP3ui.xml
func (gl *GL) MultiTexCoordP3ui(texture, gltype glbase.Enum, coords uint32) {
	C.gl4_3core_glMultiTexCoordP3ui(gl.funcs, C.GLenum(texture), C.GLenum(gltype), C.GLuint(coords))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoordP2uiv.xml
func (gl *GL) MultiTexCoordP2uiv(texture, gltype glbase.Enum, coords []uint32) {
	C.gl4_3core_glMultiTexCoordP2uiv(gl.funcs, C.GLenum(texture), C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&coords[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoordP2ui.xml
func (gl *GL) MultiTexCoordP2ui(texture, gltype glbase.Enum, coords uint32) {
	C.gl4_3core_glMultiTexCoordP2ui(gl.funcs, C.GLenum(texture), C.GLenum(gltype), C.GLuint(coords))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoordP1uiv.xml
func (gl *GL) MultiTexCoordP1uiv(texture, gltype glbase.Enum, coords []uint32) {
	C.gl4_3core_glMultiTexCoordP1uiv(gl.funcs, C.GLenum(texture), C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&coords[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoordP1ui.xml
func (gl *GL) MultiTexCoordP1ui(texture, gltype glbase.Enum, coords uint32) {
	C.gl4_3core_glMultiTexCoordP1ui(gl.funcs, C.GLenum(texture), C.GLenum(gltype), C.GLuint(coords))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoordP4uiv.xml
func (gl *GL) TexCoordP4uiv(gltype glbase.Enum, coords []uint32) {
	C.gl4_3core_glTexCoordP4uiv(gl.funcs, C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&coords[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoordP4ui.xml
func (gl *GL) TexCoordP4ui(gltype glbase.Enum, coords uint32) {
	C.gl4_3core_glTexCoordP4ui(gl.funcs, C.GLenum(gltype), C.GLuint(coords))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoordP3uiv.xml
func (gl *GL) TexCoordP3uiv(gltype glbase.Enum, coords []uint32) {
	C.gl4_3core_glTexCoordP3uiv(gl.funcs, C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&coords[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoordP3ui.xml
func (gl *GL) TexCoordP3ui(gltype glbase.Enum, coords uint32) {
	C.gl4_3core_glTexCoordP3ui(gl.funcs, C.GLenum(gltype), C.GLuint(coords))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoordP2uiv.xml
func (gl *GL) TexCoordP2uiv(gltype glbase.Enum, coords []uint32) {
	C.gl4_3core_glTexCoordP2uiv(gl.funcs, C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&coords[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoordP2ui.xml
func (gl *GL) TexCoordP2ui(gltype glbase.Enum, coords uint32) {
	C.gl4_3core_glTexCoordP2ui(gl.funcs, C.GLenum(gltype), C.GLuint(coords))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoordP1uiv.xml
func (gl *GL) TexCoordP1uiv(gltype glbase.Enum, coords []uint32) {
	C.gl4_3core_glTexCoordP1uiv(gl.funcs, C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&coords[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoordP1ui.xml
func (gl *GL) TexCoordP1ui(gltype glbase.Enum, coords uint32) {
	C.gl4_3core_glTexCoordP1ui(gl.funcs, C.GLenum(gltype), C.GLuint(coords))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexP4uiv.xml
func (gl *GL) VertexP4uiv(gltype glbase.Enum, value []uint32) {
	C.gl4_3core_glVertexP4uiv(gl.funcs, C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexP4ui.xml
func (gl *GL) VertexP4ui(gltype glbase.Enum, value uint32) {
	C.gl4_3core_glVertexP4ui(gl.funcs, C.GLenum(gltype), C.GLuint(value))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexP3uiv.xml
func (gl *GL) VertexP3uiv(gltype glbase.Enum, value []uint32) {
	C.gl4_3core_glVertexP3uiv(gl.funcs, C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexP3ui.xml
func (gl *GL) VertexP3ui(gltype glbase.Enum, value uint32) {
	C.gl4_3core_glVertexP3ui(gl.funcs, C.GLenum(gltype), C.GLuint(value))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexP2uiv.xml
func (gl *GL) VertexP2uiv(gltype glbase.Enum, value []uint32) {
	C.gl4_3core_glVertexP2uiv(gl.funcs, C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexP2ui.xml
func (gl *GL) VertexP2ui(gltype glbase.Enum, value uint32) {
	C.gl4_3core_glVertexP2ui(gl.funcs, C.GLenum(gltype), C.GLuint(value))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetQueryObjectui64v.xml
func (gl *GL) GetQueryObjectui64v(id uint32, pname glbase.Enum, params []uint64) {
	C.gl4_3core_glGetQueryObjectui64v(gl.funcs, C.GLuint(id), C.GLenum(pname), (*C.GLuint64)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetQueryObjecti64v.xml
func (gl *GL) GetQueryObjecti64v(id uint32, pname glbase.Enum, params []int64) {
	C.gl4_3core_glGetQueryObjecti64v(gl.funcs, C.GLuint(id), C.GLenum(pname), (*C.GLint64)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glQueryCounter.xml
func (gl *GL) QueryCounter(id uint32, target glbase.Enum) {
	C.gl4_3core_glQueryCounter(gl.funcs, C.GLuint(id), C.GLenum(target))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetSamplerParameterIuiv.xml
func (gl *GL) GetSamplerParameterIuiv(sampler uint32, pname glbase.Enum, params []uint32) {
	C.gl4_3core_glGetSamplerParameterIuiv(gl.funcs, C.GLuint(sampler), C.GLenum(pname), (*C.GLuint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetSamplerParameterfv.xml
func (gl *GL) GetSamplerParameterfv(sampler uint32, pname glbase.Enum, params []float32) {
	C.gl4_3core_glGetSamplerParameterfv(gl.funcs, C.GLuint(sampler), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetSamplerParameterIiv.xml
func (gl *GL) GetSamplerParameterIiv(sampler uint32, pname glbase.Enum, params []int32) {
	C.gl4_3core_glGetSamplerParameterIiv(gl.funcs, C.GLuint(sampler), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetSamplerParameteriv.xml
func (gl *GL) GetSamplerParameteriv(sampler uint32, pname glbase.Enum, params []int32) {
	C.gl4_3core_glGetSamplerParameteriv(gl.funcs, C.GLuint(sampler), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSamplerParameterIuiv.xml
func (gl *GL) SamplerParameterIuiv(sampler uint32, pname glbase.Enum, param []uint32) {
	C.gl4_3core_glSamplerParameterIuiv(gl.funcs, C.GLuint(sampler), C.GLenum(pname), (*C.GLuint)(unsafe.Pointer(&param[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSamplerParameterIiv.xml
func (gl *GL) SamplerParameterIiv(sampler uint32, pname glbase.Enum, param []int32) {
	C.gl4_3core_glSamplerParameterIiv(gl.funcs, C.GLuint(sampler), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&param[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSamplerParameterfv.xml
func (gl *GL) SamplerParameterfv(sampler uint32, pname glbase.Enum, param []float32) {
	C.gl4_3core_glSamplerParameterfv(gl.funcs, C.GLuint(sampler), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&param[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSamplerParameterf.xml
func (gl *GL) SamplerParameterf(sampler uint32, pname glbase.Enum, param float32) {
	C.gl4_3core_glSamplerParameterf(gl.funcs, C.GLuint(sampler), C.GLenum(pname), C.GLfloat(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSamplerParameteriv.xml
func (gl *GL) SamplerParameteriv(sampler uint32, pname glbase.Enum, param []int32) {
	C.gl4_3core_glSamplerParameteriv(gl.funcs, C.GLuint(sampler), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&param[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSamplerParameteri.xml
func (gl *GL) SamplerParameteri(sampler uint32, pname glbase.Enum, param int32) {
	C.gl4_3core_glSamplerParameteri(gl.funcs, C.GLuint(sampler), C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindSampler.xml
func (gl *GL) BindSampler(unit, sampler uint32) {
	C.gl4_3core_glBindSampler(gl.funcs, C.GLuint(unit), C.GLuint(sampler))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsSampler.xml
func (gl *GL) IsSampler(sampler uint32) bool {
	glresult := C.gl4_3core_glIsSampler(gl.funcs, C.GLuint(sampler))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteSamplers.xml
func (gl *GL) DeleteSamplers(count int32, samplers []uint32) {
	C.gl4_3core_glDeleteSamplers(gl.funcs, C.GLsizei(count), (*C.GLuint)(unsafe.Pointer(&samplers[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGenSamplers.xml
func (gl *GL) GenSamplers(count int32, samplers []uint32) {
	C.gl4_3core_glGenSamplers(gl.funcs, C.GLsizei(count), (*C.GLuint)(unsafe.Pointer(&samplers[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetFragDataIndex.xml
func (gl *GL) GetFragDataIndex(program glbase.Program, name []byte) int32 {
	glresult := C.gl4_3core_glGetFragDataIndex(gl.funcs, C.GLuint(program), (*C.GLchar)(unsafe.Pointer(&name[0])))
	return int32(glresult)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindFragDataLocationIndexed.xml
func (gl *GL) BindFragDataLocationIndexed(program glbase.Program, colorNumber, index uint32, name []byte) {
	C.gl4_3core_glBindFragDataLocationIndexed(gl.funcs, C.GLuint(program), C.GLuint(colorNumber), C.GLuint(index), (*C.GLchar)(unsafe.Pointer(&name[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribDivisor.xml
func (gl *GL) VertexAttribDivisor(index glbase.Attrib, divisor uint32) {
	C.gl4_3core_glVertexAttribDivisor(gl.funcs, C.GLuint(index), C.GLuint(divisor))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetQueryIndexediv.xml
func (gl *GL) GetQueryIndexediv(target glbase.Enum, index uint32, pname glbase.Enum, params []int32) {
	C.gl4_3core_glGetQueryIndexediv(gl.funcs, C.GLenum(target), C.GLuint(index), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEndQueryIndexed.xml
func (gl *GL) EndQueryIndexed(target glbase.Enum, index uint32) {
	C.gl4_3core_glEndQueryIndexed(gl.funcs, C.GLenum(target), C.GLuint(index))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBeginQueryIndexed.xml
func (gl *GL) BeginQueryIndexed(target glbase.Enum, index, id uint32) {
	C.gl4_3core_glBeginQueryIndexed(gl.funcs, C.GLenum(target), C.GLuint(index), C.GLuint(id))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawTransformFeedbackStream.xml
func (gl *GL) DrawTransformFeedbackStream(mode glbase.Enum, id, stream uint32) {
	C.gl4_3core_glDrawTransformFeedbackStream(gl.funcs, C.GLenum(mode), C.GLuint(id), C.GLuint(stream))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawTransformFeedback.xml
func (gl *GL) DrawTransformFeedback(mode glbase.Enum, id uint32) {
	C.gl4_3core_glDrawTransformFeedback(gl.funcs, C.GLenum(mode), C.GLuint(id))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glResumeTransformFeedback.xml
func (gl *GL) ResumeTransformFeedback() {
	C.gl4_3core_glResumeTransformFeedback(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPauseTransformFeedback.xml
func (gl *GL) PauseTransformFeedback() {
	C.gl4_3core_glPauseTransformFeedback(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsTransformFeedback.xml
func (gl *GL) IsTransformFeedback(id uint32) bool {
	glresult := C.gl4_3core_glIsTransformFeedback(gl.funcs, C.GLuint(id))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGenTransformFeedbacks.xml
func (gl *GL) GenTransformFeedbacks(n int32, ids []uint32) {
	C.gl4_3core_glGenTransformFeedbacks(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&ids[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteTransformFeedbacks.xml
func (gl *GL) DeleteTransformFeedbacks(n int32, ids []uint32) {
	C.gl4_3core_glDeleteTransformFeedbacks(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&ids[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindTransformFeedback.xml
func (gl *GL) BindTransformFeedback(target glbase.Enum, id uint32) {
	C.gl4_3core_glBindTransformFeedback(gl.funcs, C.GLenum(target), C.GLuint(id))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPatchParameterfv.xml
func (gl *GL) PatchParameterfv(pname glbase.Enum, values []float32) {
	C.gl4_3core_glPatchParameterfv(gl.funcs, C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&values[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPatchParameteri.xml
func (gl *GL) PatchParameteri(pname glbase.Enum, value int32) {
	C.gl4_3core_glPatchParameteri(gl.funcs, C.GLenum(pname), C.GLint(value))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetProgramStageiv.xml
func (gl *GL) GetProgramStageiv(program glbase.Program, shadertype, pname glbase.Enum, values []int32) {
	C.gl4_3core_glGetProgramStageiv(gl.funcs, C.GLuint(program), C.GLenum(shadertype), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&values[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetUniformSubroutineuiv.xml
func (gl *GL) GetUniformSubroutineuiv(shadertype glbase.Enum, location glbase.Uniform, params []uint32) {
	C.gl4_3core_glGetUniformSubroutineuiv(gl.funcs, C.GLenum(shadertype), C.GLint(location), (*C.GLuint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetActiveSubroutineName.xml
func (gl *GL) GetActiveSubroutineName(program glbase.Program, shadertype glbase.Enum, index uint32, bufsize int32, length []int32, name []byte) {
	C.gl4_3core_glGetActiveSubroutineName(gl.funcs, C.GLuint(program), C.GLenum(shadertype), C.GLuint(index), C.GLsizei(bufsize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLchar)(unsafe.Pointer(&name[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetActiveSubroutineUniformName.xml
func (gl *GL) GetActiveSubroutineUniformName(program glbase.Program, shadertype glbase.Enum, index uint32, bufsize int32, length []int32, name []byte) {
	C.gl4_3core_glGetActiveSubroutineUniformName(gl.funcs, C.GLuint(program), C.GLenum(shadertype), C.GLuint(index), C.GLsizei(bufsize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLchar)(unsafe.Pointer(&name[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetActiveSubroutineUniformiv.xml
func (gl *GL) GetActiveSubroutineUniformiv(program glbase.Program, shadertype glbase.Enum, index uint32, pname glbase.Enum, values []int32) {
	C.gl4_3core_glGetActiveSubroutineUniformiv(gl.funcs, C.GLuint(program), C.GLenum(shadertype), C.GLuint(index), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&values[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetSubroutineIndex.xml
func (gl *GL) GetSubroutineIndex(program glbase.Program, shadertype glbase.Enum, name []byte) uint32 {
	glresult := C.gl4_3core_glGetSubroutineIndex(gl.funcs, C.GLuint(program), C.GLenum(shadertype), (*C.GLchar)(unsafe.Pointer(&name[0])))
	return uint32(glresult)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetSubroutineUniformLocation.xml
func (gl *GL) GetSubroutineUniformLocation(program glbase.Program, shadertype glbase.Enum, name []byte) int32 {
	glresult := C.gl4_3core_glGetSubroutineUniformLocation(gl.funcs, C.GLuint(program), C.GLenum(shadertype), (*C.GLchar)(unsafe.Pointer(&name[0])))
	return int32(glresult)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetUniformdv.xml
func (gl *GL) GetUniformdv(program glbase.Program, location glbase.Uniform, params []float64) {
	C.gl4_3core_glGetUniformdv(gl.funcs, C.GLuint(program), C.GLint(location), (*C.GLdouble)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform4d.xml
func (gl *GL) Uniform4d(location glbase.Uniform, x, y, z, w float64) {
	C.gl4_3core_glUniform4d(gl.funcs, C.GLint(location), C.GLdouble(x), C.GLdouble(y), C.GLdouble(z), C.GLdouble(w))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform3d.xml
func (gl *GL) Uniform3d(location glbase.Uniform, x, y, z float64) {
	C.gl4_3core_glUniform3d(gl.funcs, C.GLint(location), C.GLdouble(x), C.GLdouble(y), C.GLdouble(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform2d.xml
func (gl *GL) Uniform2d(location glbase.Uniform, x, y float64) {
	C.gl4_3core_glUniform2d(gl.funcs, C.GLint(location), C.GLdouble(x), C.GLdouble(y))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform1d.xml
func (gl *GL) Uniform1d(location glbase.Uniform, x float64) {
	C.gl4_3core_glUniform1d(gl.funcs, C.GLint(location), C.GLdouble(x))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawElementsIndirect.xml
func (gl *GL) DrawElementsIndirect(mode, gltype glbase.Enum, indirect interface{}) {
	indirect_v := reflect.ValueOf(indirect)
	if indirect_v.Kind() != reflect.Slice {
		panic("parameter indirect must be a slice")
	}
	C.gl4_3core_glDrawElementsIndirect(gl.funcs, C.GLenum(mode), C.GLenum(gltype), unsafe.Pointer(indirect_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawArraysIndirect.xml
func (gl *GL) DrawArraysIndirect(mode glbase.Enum, indirect interface{}) {
	indirect_v := reflect.ValueOf(indirect)
	if indirect_v.Kind() != reflect.Slice {
		panic("parameter indirect must be a slice")
	}
	C.gl4_3core_glDrawArraysIndirect(gl.funcs, C.GLenum(mode), unsafe.Pointer(indirect_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBlendFuncSeparatei.xml
func (gl *GL) BlendFuncSeparatei(buf uint32, srcRGB, dstRGB, srcAlpha, dstAlpha glbase.Enum) {
	C.gl4_3core_glBlendFuncSeparatei(gl.funcs, C.GLuint(buf), C.GLenum(srcRGB), C.GLenum(dstRGB), C.GLenum(srcAlpha), C.GLenum(dstAlpha))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBlendFunci.xml
func (gl *GL) BlendFunci(buf uint32, src, dst glbase.Enum) {
	C.gl4_3core_glBlendFunci(gl.funcs, C.GLuint(buf), C.GLenum(src), C.GLenum(dst))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBlendEquationSeparatei.xml
func (gl *GL) BlendEquationSeparatei(buf uint32, modeRGB, modeAlpha glbase.Enum) {
	C.gl4_3core_glBlendEquationSeparatei(gl.funcs, C.GLuint(buf), C.GLenum(modeRGB), C.GLenum(modeAlpha))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBlendEquationi.xml
func (gl *GL) BlendEquationi(buf uint32, mode glbase.Enum) {
	C.gl4_3core_glBlendEquationi(gl.funcs, C.GLuint(buf), C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMinSampleShading.xml
func (gl *GL) MinSampleShading(value float32) {
	C.gl4_3core_glMinSampleShading(gl.funcs, C.GLfloat(value))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetDoublei_v.xml
func (gl *GL) GetDoublei_v(target glbase.Enum, index uint32, data []float64) {
	C.gl4_3core_glGetDoublei_v(gl.funcs, C.GLenum(target), C.GLuint(index), (*C.GLdouble)(unsafe.Pointer(&data[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetFloati_v.xml
func (gl *GL) GetFloati_v(target glbase.Enum, index uint32, data []float32) {
	C.gl4_3core_glGetFloati_v(gl.funcs, C.GLenum(target), C.GLuint(index), (*C.GLfloat)(unsafe.Pointer(&data[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDepthRangeIndexed.xml
func (gl *GL) DepthRangeIndexed(index uint32, n, f float64) {
	C.gl4_3core_glDepthRangeIndexed(gl.funcs, C.GLuint(index), C.GLdouble(n), C.GLdouble(f))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDepthRangeArrayv.xml
func (gl *GL) DepthRangeArrayv(first uint32, count int32, v []float64) {
	C.gl4_3core_glDepthRangeArrayv(gl.funcs, C.GLuint(first), C.GLsizei(count), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glScissorIndexedv.xml
func (gl *GL) ScissorIndexedv(index uint32, v []int32) {
	C.gl4_3core_glScissorIndexedv(gl.funcs, C.GLuint(index), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glScissorIndexed.xml
func (gl *GL) ScissorIndexed(index uint32, left, bottom, width, height int32) {
	C.gl4_3core_glScissorIndexed(gl.funcs, C.GLuint(index), C.GLint(left), C.GLint(bottom), C.GLsizei(width), C.GLsizei(height))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glScissorArrayv.xml
func (gl *GL) ScissorArrayv(first uint32, count int32, v []int32) {
	C.gl4_3core_glScissorArrayv(gl.funcs, C.GLuint(first), C.GLsizei(count), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glViewportIndexedfv.xml
func (gl *GL) ViewportIndexedfv(index uint32, v []float32) {
	C.gl4_3core_glViewportIndexedfv(gl.funcs, C.GLuint(index), (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glViewportIndexedf.xml
func (gl *GL) ViewportIndexedf(index uint32, x, y, w, h float32) {
	C.gl4_3core_glViewportIndexedf(gl.funcs, C.GLuint(index), C.GLfloat(x), C.GLfloat(y), C.GLfloat(w), C.GLfloat(h))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glViewportArrayv.xml
func (gl *GL) ViewportArrayv(first uint32, count int32, v []float32) {
	C.gl4_3core_glViewportArrayv(gl.funcs, C.GLuint(first), C.GLsizei(count), (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetVertexAttribLdv.xml
func (gl *GL) GetVertexAttribLdv(index glbase.Attrib, pname glbase.Enum, params []float64) {
	C.gl4_3core_glGetVertexAttribLdv(gl.funcs, C.GLuint(index), C.GLenum(pname), (*C.GLdouble)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribLPointer.xml
func (gl *GL) VertexAttribLPointer(index glbase.Attrib, size int32, gltype glbase.Enum, stride int32, pointer interface{}) {
	pointer_v := reflect.ValueOf(pointer)
	if pointer_v.Kind() != reflect.Slice {
		panic("parameter pointer must be a slice")
	}
	C.gl4_3core_glVertexAttribLPointer(gl.funcs, C.GLuint(index), C.GLint(size), C.GLenum(gltype), C.GLsizei(stride), unsafe.Pointer(pointer_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribL4dv.xml
func (gl *GL) VertexAttribL4dv(index glbase.Attrib, v []float64) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_3core_glVertexAttribL4dv(gl.funcs, C.GLuint(index), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribL3dv.xml
func (gl *GL) VertexAttribL3dv(index glbase.Attrib, v []float64) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_3core_glVertexAttribL3dv(gl.funcs, C.GLuint(index), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribL2dv.xml
func (gl *GL) VertexAttribL2dv(index glbase.Attrib, v []float64) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl4_3core_glVertexAttribL2dv(gl.funcs, C.GLuint(index), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribL1dv.xml
func (gl *GL) VertexAttribL1dv(index glbase.Attrib, v []float64) {
	C.gl4_3core_glVertexAttribL1dv(gl.funcs, C.GLuint(index), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribL4d.xml
func (gl *GL) VertexAttribL4d(index glbase.Attrib, x, y, z, w float64) {
	C.gl4_3core_glVertexAttribL4d(gl.funcs, C.GLuint(index), C.GLdouble(x), C.GLdouble(y), C.GLdouble(z), C.GLdouble(w))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribL3d.xml
func (gl *GL) VertexAttribL3d(index glbase.Attrib, x, y, z float64) {
	C.gl4_3core_glVertexAttribL3d(gl.funcs, C.GLuint(index), C.GLdouble(x), C.GLdouble(y), C.GLdouble(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribL2d.xml
func (gl *GL) VertexAttribL2d(index glbase.Attrib, x, y float64) {
	C.gl4_3core_glVertexAttribL2d(gl.funcs, C.GLuint(index), C.GLdouble(x), C.GLdouble(y))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribL1d.xml
func (gl *GL) VertexAttribL1d(index glbase.Attrib, x float64) {
	C.gl4_3core_glVertexAttribL1d(gl.funcs, C.GLuint(index), C.GLdouble(x))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetProgramPipelineInfoLog.xml
func (gl *GL) GetProgramPipelineInfoLog(pipeline uint32, bufSize int32, length []int32, infoLog []byte) {
	C.gl4_3core_glGetProgramPipelineInfoLog(gl.funcs, C.GLuint(pipeline), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLchar)(unsafe.Pointer(&infoLog[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glValidateProgramPipeline.xml
func (gl *GL) ValidateProgramPipeline(pipeline uint32) {
	C.gl4_3core_glValidateProgramPipeline(gl.funcs, C.GLuint(pipeline))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix4x3dv.xml
func (gl *GL) ProgramUniformMatrix4x3dv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float64) {
	if len(value) != 3 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniformMatrix4x3dv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLdouble)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix3x4dv.xml
func (gl *GL) ProgramUniformMatrix3x4dv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float64) {
	if len(value) != 4 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniformMatrix3x4dv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLdouble)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix4x2dv.xml
func (gl *GL) ProgramUniformMatrix4x2dv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float64) {
	if len(value) != 2 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniformMatrix4x2dv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLdouble)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix2x4dv.xml
func (gl *GL) ProgramUniformMatrix2x4dv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float64) {
	if len(value) != 4 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniformMatrix2x4dv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLdouble)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix3x2dv.xml
func (gl *GL) ProgramUniformMatrix3x2dv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float64) {
	if len(value) != 2 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniformMatrix3x2dv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLdouble)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix2x3dv.xml
func (gl *GL) ProgramUniformMatrix2x3dv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float64) {
	if len(value) != 3 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniformMatrix2x3dv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLdouble)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix4x3fv.xml
func (gl *GL) ProgramUniformMatrix4x3fv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float32) {
	if len(value) != 3 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniformMatrix4x3fv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix3x4fv.xml
func (gl *GL) ProgramUniformMatrix3x4fv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float32) {
	if len(value) != 4 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniformMatrix3x4fv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix4x2fv.xml
func (gl *GL) ProgramUniformMatrix4x2fv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float32) {
	if len(value) != 2 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniformMatrix4x2fv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix2x4fv.xml
func (gl *GL) ProgramUniformMatrix2x4fv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float32) {
	if len(value) != 4 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniformMatrix2x4fv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix3x2fv.xml
func (gl *GL) ProgramUniformMatrix3x2fv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float32) {
	if len(value) != 2 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniformMatrix3x2fv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix2x3fv.xml
func (gl *GL) ProgramUniformMatrix2x3fv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float32) {
	if len(value) != 3 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniformMatrix2x3fv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix4dv.xml
func (gl *GL) ProgramUniformMatrix4dv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float64) {
	if len(value) != 4 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniformMatrix4dv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLdouble)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix3dv.xml
func (gl *GL) ProgramUniformMatrix3dv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float64) {
	if len(value) != 3 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniformMatrix3dv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLdouble)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix2dv.xml
func (gl *GL) ProgramUniformMatrix2dv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float64) {
	if len(value) != 2 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniformMatrix2dv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLdouble)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix4fv.xml
func (gl *GL) ProgramUniformMatrix4fv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float32) {
	if len(value) != 4 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniformMatrix4fv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix3fv.xml
func (gl *GL) ProgramUniformMatrix3fv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float32) {
	if len(value) != 3 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniformMatrix3fv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix2fv.xml
func (gl *GL) ProgramUniformMatrix2fv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float32) {
	if len(value) != 2 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniformMatrix2fv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform4uiv.xml
func (gl *GL) ProgramUniform4uiv(program glbase.Program, location glbase.Uniform, count int32, value []uint32) {
	C.gl4_3core_glProgramUniform4uiv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform4ui.xml
func (gl *GL) ProgramUniform4ui(program glbase.Program, location glbase.Uniform, v0, v1, v2, v3 uint32) {
	C.gl4_3core_glProgramUniform4ui(gl.funcs, C.GLuint(program), C.GLint(location), C.GLuint(v0), C.GLuint(v1), C.GLuint(v2), C.GLuint(v3))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform4dv.xml
func (gl *GL) ProgramUniform4dv(program glbase.Program, location glbase.Uniform, count int32, value []float64) {
	if len(value) != 4 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniform4dv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLdouble)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform4d.xml
func (gl *GL) ProgramUniform4d(program glbase.Program, location glbase.Uniform, v0, v1, v2, v3 float64) {
	C.gl4_3core_glProgramUniform4d(gl.funcs, C.GLuint(program), C.GLint(location), C.GLdouble(v0), C.GLdouble(v1), C.GLdouble(v2), C.GLdouble(v3))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform4fv.xml
func (gl *GL) ProgramUniform4fv(program glbase.Program, location glbase.Uniform, count int32, value []float32) {
	if len(value) != 4 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniform4fv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform4f.xml
func (gl *GL) ProgramUniform4f(program glbase.Program, location glbase.Uniform, v0, v1, v2, v3 float32) {
	C.gl4_3core_glProgramUniform4f(gl.funcs, C.GLuint(program), C.GLint(location), C.GLfloat(v0), C.GLfloat(v1), C.GLfloat(v2), C.GLfloat(v3))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform4iv.xml
func (gl *GL) ProgramUniform4iv(program glbase.Program, location glbase.Uniform, count int32, value []int32) {
	if len(value) != 4 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniform4iv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform4i.xml
func (gl *GL) ProgramUniform4i(program glbase.Program, location glbase.Uniform, v0, v1, v2, v3 int32) {
	C.gl4_3core_glProgramUniform4i(gl.funcs, C.GLuint(program), C.GLint(location), C.GLint(v0), C.GLint(v1), C.GLint(v2), C.GLint(v3))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform3uiv.xml
func (gl *GL) ProgramUniform3uiv(program glbase.Program, location glbase.Uniform, count int32, value []uint32) {
	C.gl4_3core_glProgramUniform3uiv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform3ui.xml
func (gl *GL) ProgramUniform3ui(program glbase.Program, location glbase.Uniform, v0, v1, v2 uint32) {
	C.gl4_3core_glProgramUniform3ui(gl.funcs, C.GLuint(program), C.GLint(location), C.GLuint(v0), C.GLuint(v1), C.GLuint(v2))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform3dv.xml
func (gl *GL) ProgramUniform3dv(program glbase.Program, location glbase.Uniform, count int32, value []float64) {
	if len(value) != 3 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniform3dv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLdouble)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform3d.xml
func (gl *GL) ProgramUniform3d(program glbase.Program, location glbase.Uniform, v0, v1, v2 float64) {
	C.gl4_3core_glProgramUniform3d(gl.funcs, C.GLuint(program), C.GLint(location), C.GLdouble(v0), C.GLdouble(v1), C.GLdouble(v2))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform3fv.xml
func (gl *GL) ProgramUniform3fv(program glbase.Program, location glbase.Uniform, count int32, value []float32) {
	if len(value) != 3 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniform3fv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform3f.xml
func (gl *GL) ProgramUniform3f(program glbase.Program, location glbase.Uniform, v0, v1, v2 float32) {
	C.gl4_3core_glProgramUniform3f(gl.funcs, C.GLuint(program), C.GLint(location), C.GLfloat(v0), C.GLfloat(v1), C.GLfloat(v2))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform3iv.xml
func (gl *GL) ProgramUniform3iv(program glbase.Program, location glbase.Uniform, count int32, value []int32) {
	if len(value) != 3 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniform3iv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform3i.xml
func (gl *GL) ProgramUniform3i(program glbase.Program, location glbase.Uniform, v0, v1, v2 int32) {
	C.gl4_3core_glProgramUniform3i(gl.funcs, C.GLuint(program), C.GLint(location), C.GLint(v0), C.GLint(v1), C.GLint(v2))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform2uiv.xml
func (gl *GL) ProgramUniform2uiv(program glbase.Program, location glbase.Uniform, count int32, value []uint32) {
	C.gl4_3core_glProgramUniform2uiv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform2ui.xml
func (gl *GL) ProgramUniform2ui(program glbase.Program, location glbase.Uniform, v0, v1 uint32) {
	C.gl4_3core_glProgramUniform2ui(gl.funcs, C.GLuint(program), C.GLint(location), C.GLuint(v0), C.GLuint(v1))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform2dv.xml
func (gl *GL) ProgramUniform2dv(program glbase.Program, location glbase.Uniform, count int32, value []float64) {
	if len(value) != 2 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniform2dv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLdouble)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform2d.xml
func (gl *GL) ProgramUniform2d(program glbase.Program, location glbase.Uniform, v0, v1 float64) {
	C.gl4_3core_glProgramUniform2d(gl.funcs, C.GLuint(program), C.GLint(location), C.GLdouble(v0), C.GLdouble(v1))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform2fv.xml
func (gl *GL) ProgramUniform2fv(program glbase.Program, location glbase.Uniform, count int32, value []float32) {
	if len(value) != 2 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniform2fv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform2f.xml
func (gl *GL) ProgramUniform2f(program glbase.Program, location glbase.Uniform, v0, v1 float32) {
	C.gl4_3core_glProgramUniform2f(gl.funcs, C.GLuint(program), C.GLint(location), C.GLfloat(v0), C.GLfloat(v1))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform2iv.xml
func (gl *GL) ProgramUniform2iv(program glbase.Program, location glbase.Uniform, count int32, value []int32) {
	if len(value) != 2 {
		panic("parameter value has incorrect length")
	}
	C.gl4_3core_glProgramUniform2iv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform2i.xml
func (gl *GL) ProgramUniform2i(program glbase.Program, location glbase.Uniform, v0, v1 int32) {
	C.gl4_3core_glProgramUniform2i(gl.funcs, C.GLuint(program), C.GLint(location), C.GLint(v0), C.GLint(v1))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform1uiv.xml
func (gl *GL) ProgramUniform1uiv(program glbase.Program, location glbase.Uniform, count int32, value []uint32) {
	C.gl4_3core_glProgramUniform1uiv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform1ui.xml
func (gl *GL) ProgramUniform1ui(program glbase.Program, location glbase.Uniform, v0 uint32) {
	C.gl4_3core_glProgramUniform1ui(gl.funcs, C.GLuint(program), C.GLint(location), C.GLuint(v0))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform1dv.xml
func (gl *GL) ProgramUniform1dv(program glbase.Program, location glbase.Uniform, count int32, value []float64) {
	C.gl4_3core_glProgramUniform1dv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLdouble)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform1d.xml
func (gl *GL) ProgramUniform1d(program glbase.Program, location glbase.Uniform, v0 float64) {
	C.gl4_3core_glProgramUniform1d(gl.funcs, C.GLuint(program), C.GLint(location), C.GLdouble(v0))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform1fv.xml
func (gl *GL) ProgramUniform1fv(program glbase.Program, location glbase.Uniform, count int32, value []float32) {
	C.gl4_3core_glProgramUniform1fv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform1f.xml
func (gl *GL) ProgramUniform1f(program glbase.Program, location glbase.Uniform, v0 float32) {
	C.gl4_3core_glProgramUniform1f(gl.funcs, C.GLuint(program), C.GLint(location), C.GLfloat(v0))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform1iv.xml
func (gl *GL) ProgramUniform1iv(program glbase.Program, location glbase.Uniform, count int32, value []int32) {
	C.gl4_3core_glProgramUniform1iv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform1i.xml
func (gl *GL) ProgramUniform1i(program glbase.Program, location glbase.Uniform, v0 int32) {
	C.gl4_3core_glProgramUniform1i(gl.funcs, C.GLuint(program), C.GLint(location), C.GLint(v0))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetProgramPipelineiv.xml
func (gl *GL) GetProgramPipelineiv(pipeline uint32, pname glbase.Enum, params []int32) {
	C.gl4_3core_glGetProgramPipelineiv(gl.funcs, C.GLuint(pipeline), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsProgramPipeline.xml
func (gl *GL) IsProgramPipeline(pipeline uint32) bool {
	glresult := C.gl4_3core_glIsProgramPipeline(gl.funcs, C.GLuint(pipeline))
	return *(*bool)(unsafe.Pointer(&glresult))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGenProgramPipelines.xml
func (gl *GL) GenProgramPipelines(n int32, pipelines []uint32) {
	C.gl4_3core_glGenProgramPipelines(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&pipelines[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteProgramPipelines.xml
func (gl *GL) DeleteProgramPipelines(n int32, pipelines []uint32) {
	C.gl4_3core_glDeleteProgramPipelines(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&pipelines[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindProgramPipeline.xml
func (gl *GL) BindProgramPipeline(pipeline uint32) {
	C.gl4_3core_glBindProgramPipeline(gl.funcs, C.GLuint(pipeline))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glActiveShaderProgram.xml
func (gl *GL) ActiveShaderProgram(pipeline uint32, program glbase.Program) {
	C.gl4_3core_glActiveShaderProgram(gl.funcs, C.GLuint(pipeline), C.GLuint(program))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUseProgramStages.xml
func (gl *GL) UseProgramStages(pipeline uint32, stages glbase.Bitfield, program glbase.Program) {
	C.gl4_3core_glUseProgramStages(gl.funcs, C.GLuint(pipeline), C.GLbitfield(stages), C.GLuint(program))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramParameteri.xml
func (gl *GL) ProgramParameteri(program glbase.Program, pname glbase.Enum, value int32) {
	C.gl4_3core_glProgramParameteri(gl.funcs, C.GLuint(program), C.GLenum(pname), C.GLint(value))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramBinary.xml
func (gl *GL) ProgramBinary(program glbase.Program, binaryFormat glbase.Enum, binary interface{}, length int32) {
	binary_v := reflect.ValueOf(binary)
	if binary_v.Kind() != reflect.Slice {
		panic("parameter binary must be a slice")
	}
	C.gl4_3core_glProgramBinary(gl.funcs, C.GLuint(program), C.GLenum(binaryFormat), unsafe.Pointer(binary_v.Index(0).Addr().Pointer()), C.GLsizei(length))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetProgramBinary.xml
func (gl *GL) GetProgramBinary(program glbase.Program, bufSize int32, length []int32, binaryFormat []glbase.Enum, binary interface{}) {
	binary_v := reflect.ValueOf(binary)
	if binary_v.Kind() != reflect.Slice {
		panic("parameter binary must be a slice")
	}
	C.gl4_3core_glGetProgramBinary(gl.funcs, C.GLuint(program), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLenum)(unsafe.Pointer(&binaryFormat[0])), unsafe.Pointer(binary_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClearDepthf.xml
func (gl *GL) ClearDepthf(dd float32) {
	C.gl4_3core_glClearDepthf(gl.funcs, C.GLfloat(dd))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDepthRangef.xml
func (gl *GL) DepthRangef(n, f float32) {
	C.gl4_3core_glDepthRangef(gl.funcs, C.GLfloat(n), C.GLfloat(f))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetShaderPrecisionFormat.xml
func (gl *GL) GetShaderPrecisionFormat(shadertype, precisiontype glbase.Enum, range_, precision []int32) {
	C.gl4_3core_glGetShaderPrecisionFormat(gl.funcs, C.GLenum(shadertype), C.GLenum(precisiontype), (*C.GLint)(unsafe.Pointer(&range_[0])), (*C.GLint)(unsafe.Pointer(&precision[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glShaderBinary.xml
func (gl *GL) ShaderBinary(count int32, shaders []uint32, binaryformat glbase.Enum, binary interface{}, length int32) {
	binary_v := reflect.ValueOf(binary)
	if binary_v.Kind() != reflect.Slice {
		panic("parameter binary must be a slice")
	}
	C.gl4_3core_glShaderBinary(gl.funcs, C.GLsizei(count), (*C.GLuint)(unsafe.Pointer(&shaders[0])), C.GLenum(binaryformat), unsafe.Pointer(binary_v.Index(0).Addr().Pointer()), C.GLsizei(length))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glReleaseShaderCompiler.xml
func (gl *GL) ReleaseShaderCompiler() {
	C.gl4_3core_glReleaseShaderCompiler(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexStorage3D.xml
func (gl *GL) TexStorage3D(target glbase.Enum, levels int32, internalformat glbase.Enum, width, height, depth int32) {
	C.gl4_3core_glTexStorage3D(gl.funcs, C.GLenum(target), C.GLsizei(levels), C.GLenum(internalformat), C.GLsizei(width), C.GLsizei(height), C.GLsizei(depth))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexStorage2D.xml
func (gl *GL) TexStorage2D(target glbase.Enum, levels int32, internalformat glbase.Enum, width, height int32) {
	C.gl4_3core_glTexStorage2D(gl.funcs, C.GLenum(target), C.GLsizei(levels), C.GLenum(internalformat), C.GLsizei(width), C.GLsizei(height))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexStorage1D.xml
func (gl *GL) TexStorage1D(target glbase.Enum, levels int32, internalformat glbase.Enum, width int32) {
	C.gl4_3core_glTexStorage1D(gl.funcs, C.GLenum(target), C.GLsizei(levels), C.GLenum(internalformat), C.GLsizei(width))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMemoryBarrier.xml
func (gl *GL) MemoryBarrier(barriers glbase.Bitfield) {
	C.gl4_3core_glMemoryBarrier(gl.funcs, C.GLbitfield(barriers))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindImageTexture.xml
func (gl *GL) BindImageTexture(unit uint32, texture glbase.Texture, level int32, layered bool, layer int32, access, format glbase.Enum) {
	C.gl4_3core_glBindImageTexture(gl.funcs, C.GLuint(unit), C.GLuint(texture), C.GLint(level), *(*C.GLboolean)(unsafe.Pointer(&layered)), C.GLint(layer), C.GLenum(access), C.GLenum(format))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetActiveAtomicCounterBufferiv.xml
func (gl *GL) GetActiveAtomicCounterBufferiv(program glbase.Program, bufferIndex uint32, pname glbase.Enum, params []int32) {
	C.gl4_3core_glGetActiveAtomicCounterBufferiv(gl.funcs, C.GLuint(program), C.GLuint(bufferIndex), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetInternalformativ.xml
func (gl *GL) GetInternalformativ(target, internalformat, pname glbase.Enum, bufSize int32, params []int32) {
	C.gl4_3core_glGetInternalformativ(gl.funcs, C.GLenum(target), C.GLenum(internalformat), C.GLenum(pname), C.GLsizei(bufSize), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawTransformFeedbackStreamInstanced.xml
func (gl *GL) DrawTransformFeedbackStreamInstanced(mode glbase.Enum, id, stream uint32, instancecount int32) {
	C.gl4_3core_glDrawTransformFeedbackStreamInstanced(gl.funcs, C.GLenum(mode), C.GLuint(id), C.GLuint(stream), C.GLsizei(instancecount))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawTransformFeedbackInstanced.xml
func (gl *GL) DrawTransformFeedbackInstanced(mode glbase.Enum, id uint32, instancecount int32) {
	C.gl4_3core_glDrawTransformFeedbackInstanced(gl.funcs, C.GLenum(mode), C.GLuint(id), C.GLsizei(instancecount))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawElementsInstancedBaseVertexBaseInstance.xml
func (gl *GL) DrawElementsInstancedBaseVertexBaseInstance(mode glbase.Enum, count int32, gltype glbase.Enum, indices interface{}, instancecount, basevertex int32, baseinstance uint32) {
	indices_v := reflect.ValueOf(indices)
	if indices_v.Kind() != reflect.Slice {
		panic("parameter indices must be a slice")
	}
	C.gl4_3core_glDrawElementsInstancedBaseVertexBaseInstance(gl.funcs, C.GLenum(mode), C.GLsizei(count), C.GLenum(gltype), unsafe.Pointer(indices_v.Index(0).Addr().Pointer()), C.GLsizei(instancecount), C.GLint(basevertex), C.GLuint(baseinstance))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawElementsInstancedBaseInstance.xml
func (gl *GL) DrawElementsInstancedBaseInstance(mode glbase.Enum, count int32, gltype glbase.Enum, indices interface{}, instancecount int32, baseinstance uint32) {
	indices_v := reflect.ValueOf(indices)
	if indices_v.Kind() != reflect.Slice {
		panic("parameter indices must be a slice")
	}
	C.gl4_3core_glDrawElementsInstancedBaseInstance(gl.funcs, C.GLenum(mode), C.GLsizei(count), C.GLenum(gltype), unsafe.Pointer(indices_v.Index(0).Addr().Pointer()), C.GLsizei(instancecount), C.GLuint(baseinstance))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawArraysInstancedBaseInstance.xml
func (gl *GL) DrawArraysInstancedBaseInstance(mode glbase.Enum, first, count, instancecount int32, baseinstance uint32) {
	C.gl4_3core_glDrawArraysInstancedBaseInstance(gl.funcs, C.GLenum(mode), C.GLint(first), C.GLsizei(count), C.GLsizei(instancecount), C.GLuint(baseinstance))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexStorage3DMultisample.xml
func (gl *GL) TexStorage3DMultisample(target glbase.Enum, samples int32, internalformat glbase.Enum, width, height, depth int32, fixedsamplelocations bool) {
	C.gl4_3core_glTexStorage3DMultisample(gl.funcs, C.GLenum(target), C.GLsizei(samples), C.GLenum(internalformat), C.GLsizei(width), C.GLsizei(height), C.GLsizei(depth), *(*C.GLboolean)(unsafe.Pointer(&fixedsamplelocations)))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexStorage2DMultisample.xml
func (gl *GL) TexStorage2DMultisample(target glbase.Enum, samples int32, internalformat glbase.Enum, width, height int32, fixedsamplelocations bool) {
	C.gl4_3core_glTexStorage2DMultisample(gl.funcs, C.GLenum(target), C.GLsizei(samples), C.GLenum(internalformat), C.GLsizei(width), C.GLsizei(height), *(*C.GLboolean)(unsafe.Pointer(&fixedsamplelocations)))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexBufferRange.xml
func (gl *GL) TexBufferRange(target, internalformat glbase.Enum, buffer glbase.Buffer, offset, size int) {
	C.gl4_3core_glTexBufferRange(gl.funcs, C.GLenum(target), C.GLenum(internalformat), C.GLuint(buffer), C.GLintptr(offset), C.GLsizeiptr(size))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glShaderStorageBlockBinding.xml
func (gl *GL) ShaderStorageBlockBinding(program glbase.Program, storageBlockIndex, storageBlockBinding uint32) {
	C.gl4_3core_glShaderStorageBlockBinding(gl.funcs, C.GLuint(program), C.GLuint(storageBlockIndex), C.GLuint(storageBlockBinding))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetProgramResourceLocationIndex.xml
func (gl *GL) GetProgramResourceLocationIndex(program glbase.Program, programInterface glbase.Enum, name []byte) int32 {
	glresult := C.gl4_3core_glGetProgramResourceLocationIndex(gl.funcs, C.GLuint(program), C.GLenum(programInterface), (*C.GLchar)(unsafe.Pointer(&name[0])))
	return int32(glresult)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetProgramResourceLocation.xml
func (gl *GL) GetProgramResourceLocation(program glbase.Program, programInterface glbase.Enum, name []byte) int32 {
	glresult := C.gl4_3core_glGetProgramResourceLocation(gl.funcs, C.GLuint(program), C.GLenum(programInterface), (*C.GLchar)(unsafe.Pointer(&name[0])))
	return int32(glresult)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetProgramResourceiv.xml
func (gl *GL) GetProgramResourceiv(program glbase.Program, programInterface glbase.Enum, index uint32, propCount int32, props []glbase.Enum, bufSize int32, length, params []int32) {
	C.gl4_3core_glGetProgramResourceiv(gl.funcs, C.GLuint(program), C.GLenum(programInterface), C.GLuint(index), C.GLsizei(propCount), (*C.GLenum)(unsafe.Pointer(&props[0])), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetProgramResourceName.xml
func (gl *GL) GetProgramResourceName(program glbase.Program, programInterface glbase.Enum, index uint32, bufSize int32, length []int32, name []byte) {
	C.gl4_3core_glGetProgramResourceName(gl.funcs, C.GLuint(program), C.GLenum(programInterface), C.GLuint(index), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLchar)(unsafe.Pointer(&name[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetProgramResourceIndex.xml
func (gl *GL) GetProgramResourceIndex(program glbase.Program, programInterface glbase.Enum, name []byte) uint32 {
	glresult := C.gl4_3core_glGetProgramResourceIndex(gl.funcs, C.GLuint(program), C.GLenum(programInterface), (*C.GLchar)(unsafe.Pointer(&name[0])))
	return uint32(glresult)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetProgramInterfaceiv.xml
func (gl *GL) GetProgramInterfaceiv(program glbase.Program, programInterface, pname glbase.Enum, params []int32) {
	C.gl4_3core_glGetProgramInterfaceiv(gl.funcs, C.GLuint(program), C.GLenum(programInterface), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiDrawElementsIndirect.xml
func (gl *GL) MultiDrawElementsIndirect(mode, gltype glbase.Enum, indirect interface{}, drawcount, stride int32) {
	indirect_v := reflect.ValueOf(indirect)
	if indirect_v.Kind() != reflect.Slice {
		panic("parameter indirect must be a slice")
	}
	C.gl4_3core_glMultiDrawElementsIndirect(gl.funcs, C.GLenum(mode), C.GLenum(gltype), unsafe.Pointer(indirect_v.Index(0).Addr().Pointer()), C.GLsizei(drawcount), C.GLsizei(stride))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiDrawArraysIndirect.xml
func (gl *GL) MultiDrawArraysIndirect(mode glbase.Enum, indirect interface{}, drawcount, stride int32) {
	indirect_v := reflect.ValueOf(indirect)
	if indirect_v.Kind() != reflect.Slice {
		panic("parameter indirect must be a slice")
	}
	C.gl4_3core_glMultiDrawArraysIndirect(gl.funcs, C.GLenum(mode), unsafe.Pointer(indirect_v.Index(0).Addr().Pointer()), C.GLsizei(drawcount), C.GLsizei(stride))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glInvalidateSubFramebuffer.xml
func (gl *GL) InvalidateSubFramebuffer(target glbase.Enum, numAttachments int32, attachments []glbase.Enum, x, y, width, height int32) {
	C.gl4_3core_glInvalidateSubFramebuffer(gl.funcs, C.GLenum(target), C.GLsizei(numAttachments), (*C.GLenum)(unsafe.Pointer(&attachments[0])), C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glInvalidateFramebuffer.xml
func (gl *GL) InvalidateFramebuffer(target glbase.Enum, numAttachments int32, attachments []glbase.Enum) {
	C.gl4_3core_glInvalidateFramebuffer(gl.funcs, C.GLenum(target), C.GLsizei(numAttachments), (*C.GLenum)(unsafe.Pointer(&attachments[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glInvalidateBufferData.xml
func (gl *GL) InvalidateBufferData(buffer glbase.Buffer) {
	C.gl4_3core_glInvalidateBufferData(gl.funcs, C.GLuint(buffer))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glInvalidateBufferSubData.xml
func (gl *GL) InvalidateBufferSubData(buffer glbase.Buffer, offset, length int) {
	C.gl4_3core_glInvalidateBufferSubData(gl.funcs, C.GLuint(buffer), C.GLintptr(offset), C.GLsizeiptr(length))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glInvalidateTexImage.xml
func (gl *GL) InvalidateTexImage(texture glbase.Texture, level int32) {
	C.gl4_3core_glInvalidateTexImage(gl.funcs, C.GLuint(texture), C.GLint(level))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glInvalidateTexSubImage.xml
func (gl *GL) InvalidateTexSubImage(texture glbase.Texture, level, xoffset, yoffset, zoffset, width, height, depth int32) {
	C.gl4_3core_glInvalidateTexSubImage(gl.funcs, C.GLuint(texture), C.GLint(level), C.GLint(xoffset), C.GLint(yoffset), C.GLint(zoffset), C.GLsizei(width), C.GLsizei(height), C.GLsizei(depth))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetInternalformati64v.xml
func (gl *GL) GetInternalformati64v(target, internalformat, pname glbase.Enum, bufSize int32, params []int64) {
	C.gl4_3core_glGetInternalformati64v(gl.funcs, C.GLenum(target), C.GLenum(internalformat), C.GLenum(pname), C.GLsizei(bufSize), (*C.GLint64)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetFramebufferParameteriv.xml
func (gl *GL) GetFramebufferParameteriv(target, pname glbase.Enum, params []int32) {
	C.gl4_3core_glGetFramebufferParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFramebufferParameteri.xml
func (gl *GL) FramebufferParameteri(target, pname glbase.Enum, param int32) {
	C.gl4_3core_glFramebufferParameteri(gl.funcs, C.GLenum(target), C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexBindingDivisor.xml
func (gl *GL) VertexBindingDivisor(bindingindex, divisor uint32) {
	C.gl4_3core_glVertexBindingDivisor(gl.funcs, C.GLuint(bindingindex), C.GLuint(divisor))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribBinding.xml
func (gl *GL) VertexAttribBinding(attribindex, bindingindex uint32) {
	C.gl4_3core_glVertexAttribBinding(gl.funcs, C.GLuint(attribindex), C.GLuint(bindingindex))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribLFormat.xml
func (gl *GL) VertexAttribLFormat(attribindex uint32, size int32, gltype glbase.Enum, relativeoffset uint32) {
	C.gl4_3core_glVertexAttribLFormat(gl.funcs, C.GLuint(attribindex), C.GLint(size), C.GLenum(gltype), C.GLuint(relativeoffset))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribIFormat.xml
func (gl *GL) VertexAttribIFormat(attribindex uint32, size int32, gltype glbase.Enum, relativeoffset uint32) {
	C.gl4_3core_glVertexAttribIFormat(gl.funcs, C.GLuint(attribindex), C.GLint(size), C.GLenum(gltype), C.GLuint(relativeoffset))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribFormat.xml
func (gl *GL) VertexAttribFormat(attribindex uint32, size int32, gltype glbase.Enum, normalized bool, relativeoffset uint32) {
	C.gl4_3core_glVertexAttribFormat(gl.funcs, C.GLuint(attribindex), C.GLint(size), C.GLenum(gltype), *(*C.GLboolean)(unsafe.Pointer(&normalized)), C.GLuint(relativeoffset))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindVertexBuffer.xml
func (gl *GL) BindVertexBuffer(bindingindex uint32, buffer glbase.Buffer, offset int, stride int32) {
	C.gl4_3core_glBindVertexBuffer(gl.funcs, C.GLuint(bindingindex), C.GLuint(buffer), C.GLintptr(offset), C.GLsizei(stride))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTextureView.xml
func (gl *GL) TextureView(texture glbase.Texture, target glbase.Enum, origtexture uint32, internalformat glbase.Enum, minlevel, numlevels, minlayer, numlayers uint32) {
	C.gl4_3core_glTextureView(gl.funcs, C.GLuint(texture), C.GLenum(target), C.GLuint(origtexture), C.GLenum(internalformat), C.GLuint(minlevel), C.GLuint(numlevels), C.GLuint(minlayer), C.GLuint(numlayers))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCopyImageSubData.xml
func (gl *GL) CopyImageSubData(srcName uint32, srcTarget glbase.Enum, srcLevel, srcX, srcY, srcZ int32, dstName uint32, dstTarget glbase.Enum, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth int32) {
	C.gl4_3core_glCopyImageSubData(gl.funcs, C.GLuint(srcName), C.GLenum(srcTarget), C.GLint(srcLevel), C.GLint(srcX), C.GLint(srcY), C.GLint(srcZ), C.GLuint(dstName), C.GLenum(dstTarget), C.GLint(dstLevel), C.GLint(dstX), C.GLint(dstY), C.GLint(dstZ), C.GLsizei(srcWidth), C.GLsizei(srcHeight), C.GLsizei(srcDepth))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDispatchComputeIndirect.xml
func (gl *GL) DispatchComputeIndirect(indirect int) {
	C.gl4_3core_glDispatchComputeIndirect(gl.funcs, C.GLintptr(indirect))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDispatchCompute.xml
func (gl *GL) DispatchCompute(num_groups_x, num_groups_y, num_groups_z uint32) {
	C.gl4_3core_glDispatchCompute(gl.funcs, C.GLuint(num_groups_x), C.GLuint(num_groups_y), C.GLuint(num_groups_z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClearBufferSubData.xml
func (gl *GL) ClearBufferSubData(target, internalformat glbase.Enum, offset, size int, format, gltype glbase.Enum, data interface{}) {
	data_v := reflect.ValueOf(data)
	if data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	C.gl4_3core_glClearBufferSubData(gl.funcs, C.GLenum(target), C.GLenum(internalformat), C.GLintptr(offset), C.GLsizeiptr(size), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(data_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClearBufferData.xml
func (gl *GL) ClearBufferData(target, internalformat, format, gltype glbase.Enum, data interface{}) {
	data_v := reflect.ValueOf(data)
	if data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	C.gl4_3core_glClearBufferData(gl.funcs, C.GLenum(target), C.GLenum(internalformat), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(data_v.Index(0).Addr().Pointer()))
}
