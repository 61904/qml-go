// ** file automatically generated by glgen -- do not edit manually **

package GL

// #cgo CXXFLAGS: -std=c++0x -pedantic-errors -Wall -fno-strict-aliasing
// #cgo LDFLAGS: -lstdc++
// #cgo pkg-config: Qt5Core Qt5OpenGL
//
// #include "funcs.h"
//
// void free(void*);
//
import "C"

import (
	"fmt"
	"reflect"
	"unsafe"

	"gopkg.in/qml.v1/gl/glbase"
)

// API returns a value that offers methods matching the OpenGL version 4.2 API.
//
// The returned API must not be used after the provided OpenGL context becomes invalid.
func API(context glbase.Contexter) *GL {
	gl := &GL{}
	gl.funcs = C.gl4_2compat_funcs()
	if gl.funcs == nil {
		panic(fmt.Errorf("OpenGL version 4.2 is not available"))
	}
	return gl
}

// GL implements the OpenGL version 4.2 API. Values of this
// type must be created via the API function, and it must not be used after
// the associated OpenGL context becomes invalid.
type GL struct {
	funcs unsafe.Pointer
}

const ()

// https://www.opengl.org/sdk/docs/man2/xhtml/glViewport.xml
func (gl *GL) Viewport(x, y, width, height int32) {
	C.gl4_2compat_glViewport(gl.funcs, C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height))
}

// DepthRange specifies the mapping of depth values from normalized device
// coordinates to window coordinates.
//
// Parameter nearVal specifies the mapping of the near clipping plane to window
// coordinates (defaults to 0), while farVal specifies the mapping of the far
// clipping plane to window coordinates (defaults to 1).
//
// After clipping and division by w, depth coordinates range from -1 to 1,
// corresponding to the near and far clipping planes. DepthRange specifies a
// linear mapping of the normalized depth coordinates in this range to window
// depth coordinates. Regardless of the actual depth buffer implementation,
// window coordinate depth values are treated as though they range from 0 through 1
// (like color components). Thus, the values accepted by DepthRange are both
// clamped to this range before they are accepted.
//
// The default setting of (0, 1) maps the near plane to 0 and the far plane to 1.
// With this mapping, the depth buffer range is fully utilized.
//
// It is not necessary that nearVal be less than farVal. Reverse mappings such as
// nearVal 1, and farVal 0 are acceptable.
//
// GL.INVALID_OPERATION is generated if DepthRange is executed between the
// execution of Begin and the corresponding execution of End.
//
// See also DepthFunc, PolygonOffset, Viewport.
//
// https://www.opengl.org/sdk/docs/man2/xhtml/glDepthRange.xml
func (gl *GL) DepthRange(nearVal, farVal float64) {
	C.gl4_2compat_glDepthRange(gl.funcs, C.GLdouble(nearVal), C.GLdouble(farVal))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsEnabled.xml
func (gl *GL) IsEnabled(cap glbase.Enum) bool {
	result := C.gl4_2compat_glIsEnabled(gl.funcs, C.GLenum(cap))
	return *(*bool)(unsafe.Pointer(&result))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetTexLevelParameteriv.xml
func (gl *GL) GetTexLevelParameteriv(target glbase.Enum, level int32, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetTexLevelParameteriv(gl.funcs, C.GLenum(target), C.GLint(level), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetTexLevelParameterfv.xml
func (gl *GL) GetTexLevelParameterfv(target glbase.Enum, level int32, pname glbase.Enum, params []float32) {
	C.gl4_2compat_glGetTexLevelParameterfv(gl.funcs, C.GLenum(target), C.GLint(level), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetTexParameteriv.xml
func (gl *GL) GetTexParameteriv(target, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetTexParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetTexParameterfv.xml
func (gl *GL) GetTexParameterfv(target, pname glbase.Enum, params []float32) {
	C.gl4_2compat_glGetTexParameterfv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetTexImage.xml
func (gl *GL) GetTexImage(target glbase.Enum, level int32, format, gltype glbase.Enum, pixels interface{}) {
	pixels_v := reflect.ValueOf(pixels)
	if pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	C.gl4_2compat_glGetTexImage(gl.funcs, C.GLenum(target), C.GLint(level), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(pixels_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetIntegerv.xml
func (gl *GL) GetIntegerv(pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetIntegerv(gl.funcs, C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetFloatv.xml
func (gl *GL) GetFloatv(pname glbase.Enum, params []float32) {
	C.gl4_2compat_glGetFloatv(gl.funcs, C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetError.xml
func (gl *GL) GetError() glbase.Enum {
	result := C.gl4_2compat_glGetError(gl.funcs)
	return glbase.Enum(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetDoublev.xml
func (gl *GL) GetDoublev(pname glbase.Enum, params []float64) {
	C.gl4_2compat_glGetDoublev(gl.funcs, C.GLenum(pname), (*C.GLdouble)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetBooleanv.xml
func (gl *GL) GetBooleanv(pname glbase.Enum, params []bool) {
	C.gl4_2compat_glGetBooleanv(gl.funcs, C.GLenum(pname), (*C.GLboolean)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glReadPixels.xml
func (gl *GL) ReadPixels(x, y, width, height int32, format, gltype glbase.Enum, pixels interface{}) {
	pixels_v := reflect.ValueOf(pixels)
	if pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	C.gl4_2compat_glReadPixels(gl.funcs, C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(pixels_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glReadBuffer.xml
func (gl *GL) ReadBuffer(mode glbase.Enum) {
	C.gl4_2compat_glReadBuffer(gl.funcs, C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPixelStorei.xml
func (gl *GL) PixelStorei(pname glbase.Enum, param int32) {
	C.gl4_2compat_glPixelStorei(gl.funcs, C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPixelStoref.xml
func (gl *GL) PixelStoref(pname glbase.Enum, param float32) {
	C.gl4_2compat_glPixelStoref(gl.funcs, C.GLenum(pname), C.GLfloat(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDepthFunc.xml
func (gl *GL) DepthFunc(glfunc glbase.Enum) {
	C.gl4_2compat_glDepthFunc(gl.funcs, C.GLenum(glfunc))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glStencilOp.xml
func (gl *GL) StencilOp(fail, zfail, zpass glbase.Enum) {
	C.gl4_2compat_glStencilOp(gl.funcs, C.GLenum(fail), C.GLenum(zfail), C.GLenum(zpass))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glStencilFunc.xml
func (gl *GL) StencilFunc(glfunc glbase.Enum, ref int32, mask uint32) {
	C.gl4_2compat_glStencilFunc(gl.funcs, C.GLenum(glfunc), C.GLint(ref), C.GLuint(mask))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glLogicOp.xml
func (gl *GL) LogicOp(opcode glbase.Enum) {
	C.gl4_2compat_glLogicOp(gl.funcs, C.GLenum(opcode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBlendFunc.xml
func (gl *GL) BlendFunc(sfactor, dfactor glbase.Enum) {
	C.gl4_2compat_glBlendFunc(gl.funcs, C.GLenum(sfactor), C.GLenum(dfactor))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFlush.xml
func (gl *GL) Flush() {
	C.gl4_2compat_glFlush(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFinish.xml
func (gl *GL) Finish() {
	C.gl4_2compat_glFinish(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEnable.xml
func (gl *GL) Enable(cap glbase.Enum) {
	C.gl4_2compat_glEnable(gl.funcs, C.GLenum(cap))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDisable.xml
func (gl *GL) Disable(cap glbase.Enum) {
	C.gl4_2compat_glDisable(gl.funcs, C.GLenum(cap))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDepthMask.xml
func (gl *GL) DepthMask(flag bool) {
	C.gl4_2compat_glDepthMask(gl.funcs, *(*C.GLboolean)(unsafe.Pointer(&flag)))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColorMask.xml
func (gl *GL) ColorMask(red, green, blue, alpha bool) {
	C.gl4_2compat_glColorMask(gl.funcs, *(*C.GLboolean)(unsafe.Pointer(&red)), *(*C.GLboolean)(unsafe.Pointer(&green)), *(*C.GLboolean)(unsafe.Pointer(&blue)), *(*C.GLboolean)(unsafe.Pointer(&alpha)))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glStencilMask.xml
func (gl *GL) StencilMask(mask uint32) {
	C.gl4_2compat_glStencilMask(gl.funcs, C.GLuint(mask))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClearDepth.xml
func (gl *GL) ClearDepth(depth float64) {
	C.gl4_2compat_glClearDepth(gl.funcs, C.GLdouble(depth))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClearStencil.xml
func (gl *GL) ClearStencil(s int32) {
	C.gl4_2compat_glClearStencil(gl.funcs, C.GLint(s))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClearColor.xml
func (gl *GL) ClearColor(red, green, blue, alpha float32) {
	C.gl4_2compat_glClearColor(gl.funcs, C.GLfloat(red), C.GLfloat(green), C.GLfloat(blue), C.GLfloat(alpha))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClear.xml
func (gl *GL) Clear(mask glbase.Bitfield) {
	C.gl4_2compat_glClear(gl.funcs, C.GLbitfield(mask))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawBuffer.xml
func (gl *GL) DrawBuffer(mode glbase.Enum) {
	C.gl4_2compat_glDrawBuffer(gl.funcs, C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexImage2D.xml
func (gl *GL) TexImage2D(target glbase.Enum, level, internalformat, width, height, border int32, format, gltype glbase.Enum, pixels interface{}) {
	pixels_v := reflect.ValueOf(pixels)
	if pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	C.gl4_2compat_glTexImage2D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(internalformat), C.GLsizei(width), C.GLsizei(height), C.GLint(border), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(pixels_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexImage1D.xml
func (gl *GL) TexImage1D(target glbase.Enum, level, internalformat, width, border int32, format, gltype glbase.Enum, pixels interface{}) {
	pixels_v := reflect.ValueOf(pixels)
	if pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	C.gl4_2compat_glTexImage1D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(internalformat), C.GLsizei(width), C.GLint(border), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(pixels_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexParameteriv.xml
func (gl *GL) TexParameteriv(target, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glTexParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexParameteri.xml
func (gl *GL) TexParameteri(target, pname glbase.Enum, param int32) {
	C.gl4_2compat_glTexParameteri(gl.funcs, C.GLenum(target), C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexParameterfv.xml
func (gl *GL) TexParameterfv(target, pname glbase.Enum, params []float32) {
	C.gl4_2compat_glTexParameterfv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexParameterf.xml
func (gl *GL) TexParameterf(target, pname glbase.Enum, param float32) {
	C.gl4_2compat_glTexParameterf(gl.funcs, C.GLenum(target), C.GLenum(pname), C.GLfloat(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glScissor.xml
func (gl *GL) Scissor(x, y, width, height int32) {
	C.gl4_2compat_glScissor(gl.funcs, C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPolygonMode.xml
func (gl *GL) PolygonMode(face, mode glbase.Enum) {
	C.gl4_2compat_glPolygonMode(gl.funcs, C.GLenum(face), C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPointSize.xml
func (gl *GL) PointSize(size float32) {
	C.gl4_2compat_glPointSize(gl.funcs, C.GLfloat(size))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glLineWidth.xml
func (gl *GL) LineWidth(width float32) {
	C.gl4_2compat_glLineWidth(gl.funcs, C.GLfloat(width))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glHint.xml
func (gl *GL) Hint(target, mode glbase.Enum) {
	C.gl4_2compat_glHint(gl.funcs, C.GLenum(target), C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFrontFace.xml
func (gl *GL) FrontFace(mode glbase.Enum) {
	C.gl4_2compat_glFrontFace(gl.funcs, C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCullFace.xml
func (gl *GL) CullFace(mode glbase.Enum) {
	C.gl4_2compat_glCullFace(gl.funcs, C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIndexubv.xml
func (gl *GL) Indexubv(c []uint8) {
	C.gl4_2compat_glIndexubv(gl.funcs, (*C.GLubyte)(unsafe.Pointer(&c[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIndexub.xml
func (gl *GL) Indexub(c uint8) {
	C.gl4_2compat_glIndexub(gl.funcs, C.GLubyte(c))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsTexture.xml
func (gl *GL) IsTexture(texture glbase.Texture) bool {
	result := C.gl4_2compat_glIsTexture(gl.funcs, C.GLuint(texture))
	return *(*bool)(unsafe.Pointer(&result))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGenTextures.xml
func (gl *GL) GenTextures(n int32, textures []uint32) {
	C.gl4_2compat_glGenTextures(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&textures[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteTextures.xml
func (gl *GL) DeleteTextures(n int32, textures []uint32) {
	C.gl4_2compat_glDeleteTextures(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&textures[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindTexture.xml
func (gl *GL) BindTexture(target glbase.Enum, texture glbase.Texture) {
	C.gl4_2compat_glBindTexture(gl.funcs, C.GLenum(target), C.GLuint(texture))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexSubImage2D.xml
func (gl *GL) TexSubImage2D(target glbase.Enum, level, xoffset, yoffset, width, height int32, format, gltype glbase.Enum, pixels interface{}) {
	pixels_v := reflect.ValueOf(pixels)
	if pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	C.gl4_2compat_glTexSubImage2D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLint(yoffset), C.GLsizei(width), C.GLsizei(height), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(pixels_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexSubImage1D.xml
func (gl *GL) TexSubImage1D(target glbase.Enum, level, xoffset, width int32, format, gltype glbase.Enum, pixels interface{}) {
	pixels_v := reflect.ValueOf(pixels)
	if pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	C.gl4_2compat_glTexSubImage1D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLsizei(width), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(pixels_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCopyTexSubImage2D.xml
func (gl *GL) CopyTexSubImage2D(target glbase.Enum, level, xoffset, yoffset, x, y, width, height int32) {
	C.gl4_2compat_glCopyTexSubImage2D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLint(yoffset), C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCopyTexSubImage1D.xml
func (gl *GL) CopyTexSubImage1D(target glbase.Enum, level, xoffset, x, y, width int32) {
	C.gl4_2compat_glCopyTexSubImage1D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLint(x), C.GLint(y), C.GLsizei(width))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCopyTexImage2D.xml
func (gl *GL) CopyTexImage2D(target glbase.Enum, level int32, internalformat glbase.Enum, x, y, width, height, border int32) {
	C.gl4_2compat_glCopyTexImage2D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLenum(internalformat), C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height), C.GLint(border))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCopyTexImage1D.xml
func (gl *GL) CopyTexImage1D(target glbase.Enum, level int32, internalformat glbase.Enum, x, y, width, border int32) {
	C.gl4_2compat_glCopyTexImage1D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLenum(internalformat), C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLint(border))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPolygonOffset.xml
func (gl *GL) PolygonOffset(factor, units float32) {
	C.gl4_2compat_glPolygonOffset(gl.funcs, C.GLfloat(factor), C.GLfloat(units))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawElements.xml
func (gl *GL) DrawElements(mode glbase.Enum, count int32, gltype glbase.Enum, indices interface{}) {
	indices_v := reflect.ValueOf(indices)
	if indices_v.Kind() != reflect.Slice {
		panic("parameter indices must be a slice")
	}
	C.gl4_2compat_glDrawElements(gl.funcs, C.GLenum(mode), C.GLsizei(count), C.GLenum(gltype), unsafe.Pointer(indices_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawArrays.xml
func (gl *GL) DrawArrays(mode glbase.Enum, first, count int32) {
	C.gl4_2compat_glDrawArrays(gl.funcs, C.GLenum(mode), C.GLint(first), C.GLsizei(count))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCopyTexSubImage3D.xml
func (gl *GL) CopyTexSubImage3D(target glbase.Enum, level, xoffset, yoffset, zoffset, x, y, width, height int32) {
	C.gl4_2compat_glCopyTexSubImage3D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLint(yoffset), C.GLint(zoffset), C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexSubImage3D.xml
func (gl *GL) TexSubImage3D(target glbase.Enum, level, xoffset, yoffset, zoffset, width, height, depth int32, format, gltype glbase.Enum, pixels interface{}) {
	pixels_v := reflect.ValueOf(pixels)
	if pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	C.gl4_2compat_glTexSubImage3D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLint(yoffset), C.GLint(zoffset), C.GLsizei(width), C.GLsizei(height), C.GLsizei(depth), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(pixels_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexImage3D.xml
func (gl *GL) TexImage3D(target glbase.Enum, level, internalformat, width, height, depth, border int32, format, gltype glbase.Enum, pixels interface{}) {
	pixels_v := reflect.ValueOf(pixels)
	if pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	C.gl4_2compat_glTexImage3D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(internalformat), C.GLsizei(width), C.GLsizei(height), C.GLsizei(depth), C.GLint(border), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(pixels_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawRangeElements.xml
func (gl *GL) DrawRangeElements(mode glbase.Enum, start, end uint32, count int32, gltype glbase.Enum, indices interface{}) {
	indices_v := reflect.ValueOf(indices)
	if indices_v.Kind() != reflect.Slice {
		panic("parameter indices must be a slice")
	}
	C.gl4_2compat_glDrawRangeElements(gl.funcs, C.GLenum(mode), C.GLuint(start), C.GLuint(end), C.GLsizei(count), C.GLenum(gltype), unsafe.Pointer(indices_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBlendEquation.xml
func (gl *GL) BlendEquation(mode glbase.Enum) {
	C.gl4_2compat_glBlendEquation(gl.funcs, C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBlendColor.xml
func (gl *GL) BlendColor(red, green, blue, alpha float32) {
	C.gl4_2compat_glBlendColor(gl.funcs, C.GLfloat(red), C.GLfloat(green), C.GLfloat(blue), C.GLfloat(alpha))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetCompressedTexImage.xml
func (gl *GL) GetCompressedTexImage(target glbase.Enum, level int32, img interface{}) {
	img_v := reflect.ValueOf(img)
	if img_v.Kind() != reflect.Slice {
		panic("parameter img must be a slice")
	}
	C.gl4_2compat_glGetCompressedTexImage(gl.funcs, C.GLenum(target), C.GLint(level), unsafe.Pointer(img_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCompressedTexSubImage1D.xml
func (gl *GL) CompressedTexSubImage1D(target glbase.Enum, level, xoffset, width int32, format glbase.Enum, imageSize int32, data interface{}) {
	data_v := reflect.ValueOf(data)
	if data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	C.gl4_2compat_glCompressedTexSubImage1D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLsizei(width), C.GLenum(format), C.GLsizei(imageSize), unsafe.Pointer(data_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCompressedTexSubImage2D.xml
func (gl *GL) CompressedTexSubImage2D(target glbase.Enum, level, xoffset, yoffset, width, height int32, format glbase.Enum, imageSize int32, data interface{}) {
	data_v := reflect.ValueOf(data)
	if data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	C.gl4_2compat_glCompressedTexSubImage2D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLint(yoffset), C.GLsizei(width), C.GLsizei(height), C.GLenum(format), C.GLsizei(imageSize), unsafe.Pointer(data_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCompressedTexSubImage3D.xml
func (gl *GL) CompressedTexSubImage3D(target glbase.Enum, level, xoffset, yoffset, zoffset, width, height, depth int32, format glbase.Enum, imageSize int32, data interface{}) {
	data_v := reflect.ValueOf(data)
	if data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	C.gl4_2compat_glCompressedTexSubImage3D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLint(yoffset), C.GLint(zoffset), C.GLsizei(width), C.GLsizei(height), C.GLsizei(depth), C.GLenum(format), C.GLsizei(imageSize), unsafe.Pointer(data_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCompressedTexImage1D.xml
func (gl *GL) CompressedTexImage1D(target glbase.Enum, level int32, internalformat glbase.Enum, width, border, imageSize int32, data interface{}) {
	data_v := reflect.ValueOf(data)
	if data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	C.gl4_2compat_glCompressedTexImage1D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLenum(internalformat), C.GLsizei(width), C.GLint(border), C.GLsizei(imageSize), unsafe.Pointer(data_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCompressedTexImage2D.xml
func (gl *GL) CompressedTexImage2D(target glbase.Enum, level int32, internalformat glbase.Enum, width, height, border, imageSize int32, data interface{}) {
	data_v := reflect.ValueOf(data)
	if data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	C.gl4_2compat_glCompressedTexImage2D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLenum(internalformat), C.GLsizei(width), C.GLsizei(height), C.GLint(border), C.GLsizei(imageSize), unsafe.Pointer(data_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCompressedTexImage3D.xml
func (gl *GL) CompressedTexImage3D(target glbase.Enum, level int32, internalformat glbase.Enum, width, height, depth, border, imageSize int32, data interface{}) {
	data_v := reflect.ValueOf(data)
	if data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	C.gl4_2compat_glCompressedTexImage3D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLenum(internalformat), C.GLsizei(width), C.GLsizei(height), C.GLsizei(depth), C.GLint(border), C.GLsizei(imageSize), unsafe.Pointer(data_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSampleCoverage.xml
func (gl *GL) SampleCoverage(value float32, invert bool) {
	C.gl4_2compat_glSampleCoverage(gl.funcs, C.GLfloat(value), *(*C.GLboolean)(unsafe.Pointer(&invert)))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glActiveTexture.xml
func (gl *GL) ActiveTexture(texture glbase.Enum) {
	C.gl4_2compat_glActiveTexture(gl.funcs, C.GLenum(texture))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPointParameteriv.xml
func (gl *GL) PointParameteriv(pname glbase.Enum, params []int32) {
	C.gl4_2compat_glPointParameteriv(gl.funcs, C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPointParameteri.xml
func (gl *GL) PointParameteri(pname glbase.Enum, param int32) {
	C.gl4_2compat_glPointParameteri(gl.funcs, C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPointParameterfv.xml
func (gl *GL) PointParameterfv(pname glbase.Enum, params []float32) {
	C.gl4_2compat_glPointParameterfv(gl.funcs, C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPointParameterf.xml
func (gl *GL) PointParameterf(pname glbase.Enum, param float32) {
	C.gl4_2compat_glPointParameterf(gl.funcs, C.GLenum(pname), C.GLfloat(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiDrawArrays.xml
func (gl *GL) MultiDrawArrays(mode glbase.Enum, first, count []int32, drawcount int32) {
	C.gl4_2compat_glMultiDrawArrays(gl.funcs, C.GLenum(mode), (*C.GLint)(unsafe.Pointer(&first[0])), (*C.GLsizei)(unsafe.Pointer(&count[0])), C.GLsizei(drawcount))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBlendFuncSeparate.xml
func (gl *GL) BlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha glbase.Enum) {
	C.gl4_2compat_glBlendFuncSeparate(gl.funcs, C.GLenum(sfactorRGB), C.GLenum(dfactorRGB), C.GLenum(sfactorAlpha), C.GLenum(dfactorAlpha))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetBufferParameteriv.xml
func (gl *GL) GetBufferParameteriv(target, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetBufferParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUnmapBuffer.xml
func (gl *GL) UnmapBuffer(target glbase.Enum) bool {
	result := C.gl4_2compat_glUnmapBuffer(gl.funcs, C.GLenum(target))
	return *(*bool)(unsafe.Pointer(&result))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetBufferSubData.xml
func (gl *GL) GetBufferSubData(target glbase.Enum, offset, size int, data interface{}) {
	data_v := reflect.ValueOf(data)
	if data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	C.gl4_2compat_glGetBufferSubData(gl.funcs, C.GLenum(target), C.GLintptr(offset), C.GLsizeiptr(size), unsafe.Pointer(data_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBufferSubData.xml
func (gl *GL) BufferSubData(target glbase.Enum, offset, size int, data interface{}) {
	data_v := reflect.ValueOf(data)
	if data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	C.gl4_2compat_glBufferSubData(gl.funcs, C.GLenum(target), C.GLintptr(offset), C.GLsizeiptr(size), unsafe.Pointer(data_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBufferData.xml
func (gl *GL) BufferData(target glbase.Enum, size int, data interface{}, usage glbase.Enum) {
	data_v := reflect.ValueOf(data)
	if data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	C.gl4_2compat_glBufferData(gl.funcs, C.GLenum(target), C.GLsizeiptr(size), unsafe.Pointer(data_v.Index(0).Addr().Pointer()), C.GLenum(usage))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsBuffer.xml
func (gl *GL) IsBuffer(buffer glbase.Buffer) bool {
	result := C.gl4_2compat_glIsBuffer(gl.funcs, C.GLuint(buffer))
	return *(*bool)(unsafe.Pointer(&result))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGenBuffers.xml
func (gl *GL) GenBuffers(n int32, buffers []uint32) {
	C.gl4_2compat_glGenBuffers(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&buffers[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteBuffers.xml
func (gl *GL) DeleteBuffers(n int32, buffers []uint32) {
	C.gl4_2compat_glDeleteBuffers(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&buffers[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindBuffer.xml
func (gl *GL) BindBuffer(target glbase.Enum, buffer glbase.Buffer) {
	C.gl4_2compat_glBindBuffer(gl.funcs, C.GLenum(target), C.GLuint(buffer))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetQueryObjectuiv.xml
func (gl *GL) GetQueryObjectuiv(id uint32, pname glbase.Enum, params []uint32) {
	C.gl4_2compat_glGetQueryObjectuiv(gl.funcs, C.GLuint(id), C.GLenum(pname), (*C.GLuint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetQueryObjectiv.xml
func (gl *GL) GetQueryObjectiv(id uint32, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetQueryObjectiv(gl.funcs, C.GLuint(id), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetQueryiv.xml
func (gl *GL) GetQueryiv(target, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetQueryiv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEndQuery.xml
func (gl *GL) EndQuery(target glbase.Enum) {
	C.gl4_2compat_glEndQuery(gl.funcs, C.GLenum(target))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBeginQuery.xml
func (gl *GL) BeginQuery(target glbase.Enum, id uint32) {
	C.gl4_2compat_glBeginQuery(gl.funcs, C.GLenum(target), C.GLuint(id))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsQuery.xml
func (gl *GL) IsQuery(id uint32) bool {
	result := C.gl4_2compat_glIsQuery(gl.funcs, C.GLuint(id))
	return *(*bool)(unsafe.Pointer(&result))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteQueries.xml
func (gl *GL) DeleteQueries(n int32, ids []uint32) {
	C.gl4_2compat_glDeleteQueries(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&ids[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGenQueries.xml
func (gl *GL) GenQueries(n int32, ids []uint32) {
	C.gl4_2compat_glGenQueries(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&ids[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribPointer.xml
func (gl *GL) VertexAttribPointer(index glbase.Attrib, size int32, gltype glbase.Enum, normalized bool, stride int32, pointer interface{}) {
	pointer_v := reflect.ValueOf(pointer)
	if pointer_v.Kind() != reflect.Slice {
		panic("parameter pointer must be a slice")
	}
	C.gl4_2compat_glVertexAttribPointer(gl.funcs, C.GLuint(index), C.GLint(size), C.GLenum(gltype), *(*C.GLboolean)(unsafe.Pointer(&normalized)), C.GLsizei(stride), unsafe.Pointer(pointer_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glValidateProgram.xml
func (gl *GL) ValidateProgram(program glbase.Program) {
	C.gl4_2compat_glValidateProgram(gl.funcs, C.GLuint(program))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform4i.xml
func (gl *GL) Uniform4i(location glbase.Uniform, v0, v1, v2, v3 int32) {
	C.gl4_2compat_glUniform4i(gl.funcs, C.GLint(location), C.GLint(v0), C.GLint(v1), C.GLint(v2), C.GLint(v3))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform3i.xml
func (gl *GL) Uniform3i(location glbase.Uniform, v0, v1, v2 int32) {
	C.gl4_2compat_glUniform3i(gl.funcs, C.GLint(location), C.GLint(v0), C.GLint(v1), C.GLint(v2))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform2i.xml
func (gl *GL) Uniform2i(location glbase.Uniform, v0, v1 int32) {
	C.gl4_2compat_glUniform2i(gl.funcs, C.GLint(location), C.GLint(v0), C.GLint(v1))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform1i.xml
func (gl *GL) Uniform1i(location glbase.Uniform, v0 int32) {
	C.gl4_2compat_glUniform1i(gl.funcs, C.GLint(location), C.GLint(v0))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform4f.xml
func (gl *GL) Uniform4f(location glbase.Uniform, v0, v1, v2, v3 float32) {
	C.gl4_2compat_glUniform4f(gl.funcs, C.GLint(location), C.GLfloat(v0), C.GLfloat(v1), C.GLfloat(v2), C.GLfloat(v3))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform3f.xml
func (gl *GL) Uniform3f(location glbase.Uniform, v0, v1, v2 float32) {
	C.gl4_2compat_glUniform3f(gl.funcs, C.GLint(location), C.GLfloat(v0), C.GLfloat(v1), C.GLfloat(v2))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform2f.xml
func (gl *GL) Uniform2f(location glbase.Uniform, v0, v1 float32) {
	C.gl4_2compat_glUniform2f(gl.funcs, C.GLint(location), C.GLfloat(v0), C.GLfloat(v1))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform1f.xml
func (gl *GL) Uniform1f(location glbase.Uniform, v0 float32) {
	C.gl4_2compat_glUniform1f(gl.funcs, C.GLint(location), C.GLfloat(v0))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUseProgram.xml
func (gl *GL) UseProgram(program glbase.Program) {
	C.gl4_2compat_glUseProgram(gl.funcs, C.GLuint(program))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glShaderSource.xml
func (gl *GL) ShaderSource(shader glbase.Shader, source ...string) {
	count := len(source)
	length := make([]int32, count)
	glstring := make([]unsafe.Pointer, count)
	for i, src := range source {
		length[i] = int32(len(src))
		if len(src) > 0 {
			glstring[i] = *(*unsafe.Pointer)(unsafe.Pointer(&src))
		} else {
			glstring[i] = unsafe.Pointer(uintptr(0))
		}
	}
	C.gl4_2compat_glShaderSource(gl.funcs, C.GLuint(shader), C.GLsizei(count), (**C.GLchar)(unsafe.Pointer(&glstring[0])), (*C.GLint)(unsafe.Pointer(&length[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glLinkProgram.xml
func (gl *GL) LinkProgram(program glbase.Program) {
	C.gl4_2compat_glLinkProgram(gl.funcs, C.GLuint(program))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsShader.xml
func (gl *GL) IsShader(shader glbase.Shader) bool {
	result := C.gl4_2compat_glIsShader(gl.funcs, C.GLuint(shader))
	return *(*bool)(unsafe.Pointer(&result))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsProgram.xml
func (gl *GL) IsProgram(program glbase.Program) bool {
	result := C.gl4_2compat_glIsProgram(gl.funcs, C.GLuint(program))
	return *(*bool)(unsafe.Pointer(&result))
}

// GetVertexAttribiv returns in params the value of a generic vertex attribute
// parameter. The generic vertex attribute to be queried is specified by
// index, and the parameter to be queried is specified by pname.
//
// The accepted parameter names are as follows:
//
//   GL.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING
//       params returns a single value, the name of the buffer object
//       currently bound to the binding point corresponding to generic vertex
//       attribute array index. If no buffer object is bound, 0 is returned.
//       The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_ENABLED
//       params returns a single value that is non-zero (true) if the vertex
//       attribute array for index is enabled and 0 (false) if it is
//       disabled. The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_SIZE
//       params returns a single value, the size of the vertex attribute
//       array for index. The size is the number of values for each element
//       of the vertex attribute array, and it will be 1, 2, 3, or 4. The
//       initial value is 4.
//
//   GL.VERTEX_ATTRIB_ARRAY_STRIDE
//       params returns a single value, the array stride for (number of bytes
//       between successive elements in) the vertex attribute array for
//       index. A value of 0 indicates that the array elements are stored
//       sequentially in memory. The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_TYPE
//       params returns a single value, a symbolic constant indicating the
//       array type for the vertex attribute array for index. Possible values
//       are GL.BYTE, GL.UNSIGNED_BYTE, GL.SHORT, GL.UNSIGNED_SHORT, GL.INT,
//       GL.UNSIGNED_INT, GL.FLOAT, and GL.DOUBLE. The initial value is
//       GL.FLOAT.
//
//   GL.VERTEX_ATTRIB_ARRAY_NORMALIZED
//       params returns a single value that is non-zero (true) if fixed-point
//       data types for the vertex attribute array indicated by index are
//       normalized when they are converted to floating point, and 0 (false)
//       otherwise. The initial value is 0.
//
//   GL.CURRENT_VERTEX_ATTRIB
//       params returns four values that represent the current value for the
//       generic vertex attribute specified by index. Generic vertex
//       attribute 0 is unique in that it has no current state, so an error
//       will be generated if index is 0. The initial value for all other
//       generic vertex attributes is (0,0,0,1).
//
// All of the parameters except GL.CURRENT_VERTEX_ATTRIB represent
// client-side state.
//
// Error GL.INVALID_VALUE is generated if index is greater than or equal to
// GL.MAX_VERTEX_ATTRIBS. GL.INVALID_ENUM is generated if pname is not an
// accepted value.  GL.INVALID_OPERATION is generated if index is 0 and pname
// is GL.CURRENT_VERTEX_ATTRIB.
//
// GetVertexAttrib is available only if the GL version is 2.0 or greater.
//
// https://www.opengl.org/sdk/docs/man2/xhtml/glGetVertexAttribiv.xml
func (gl *GL) GetVertexAttribiv(index glbase.Attrib, pname glbase.Enum) (params int32) {
	C.gl4_2compat_glGetVertexAttribiv(gl.funcs, C.GLuint(index), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params)))
	return params
}

// GetVertexAttribfv returns in params the value of a generic vertex attribute
// parameter. The generic vertex attribute to be queried is specified by
// index, and the parameter to be queried is specified by pname.
//
// The accepted parameter names are as follows:
//
//   GL.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING
//       params returns a single value, the name of the buffer object
//       currently bound to the binding point corresponding to generic vertex
//       attribute array index. If no buffer object is bound, 0 is returned.
//       The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_ENABLED
//       params returns a single value that is non-zero (true) if the vertex
//       attribute array for index is enabled and 0 (false) if it is
//       disabled. The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_SIZE
//       params returns a single value, the size of the vertex attribute
//       array for index. The size is the number of values for each element
//       of the vertex attribute array, and it will be 1, 2, 3, or 4. The
//       initial value is 4.
//
//   GL.VERTEX_ATTRIB_ARRAY_STRIDE
//       params returns a single value, the array stride for (number of bytes
//       between successive elements in) the vertex attribute array for
//       index. A value of 0 indicates that the array elements are stored
//       sequentially in memory. The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_TYPE
//       params returns a single value, a symbolic constant indicating the
//       array type for the vertex attribute array for index. Possible values
//       are GL.BYTE, GL.UNSIGNED_BYTE, GL.SHORT, GL.UNSIGNED_SHORT, GL.INT,
//       GL.UNSIGNED_INT, GL.FLOAT, and GL.DOUBLE. The initial value is
//       GL.FLOAT.
//
//   GL.VERTEX_ATTRIB_ARRAY_NORMALIZED
//       params returns a single value that is non-zero (true) if fixed-point
//       data types for the vertex attribute array indicated by index are
//       normalized when they are converted to floating point, and 0 (false)
//       otherwise. The initial value is 0.
//
//   GL.CURRENT_VERTEX_ATTRIB
//       params returns four values that represent the current value for the
//       generic vertex attribute specified by index. Generic vertex
//       attribute 0 is unique in that it has no current state, so an error
//       will be generated if index is 0. The initial value for all other
//       generic vertex attributes is (0,0,0,1).
//
// All of the parameters except GL.CURRENT_VERTEX_ATTRIB represent
// client-side state.
//
// Error GL.INVALID_VALUE is generated if index is greater than or equal to
// GL.MAX_VERTEX_ATTRIBS. GL.INVALID_ENUM is generated if pname is not an
// accepted value.  GL.INVALID_OPERATION is generated if index is 0 and pname
// is GL.CURRENT_VERTEX_ATTRIB.
//
// GetVertexAttrib is available only if the GL version is 2.0 or greater.
//
// https://www.opengl.org/sdk/docs/man2/xhtml/glGetVertexAttribfv.xml
func (gl *GL) GetVertexAttribfv(index glbase.Attrib, pname glbase.Enum) (params float32) {
	C.gl4_2compat_glGetVertexAttribfv(gl.funcs, C.GLuint(index), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params)))
	return params
}

// GetVertexAttribdv returns in params the value of a generic vertex attribute
// parameter. The generic vertex attribute to be queried is specified by
// index, and the parameter to be queried is specified by pname.
//
// The accepted parameter names are as follows:
//
//   GL.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING
//       params returns a single value, the name of the buffer object
//       currently bound to the binding point corresponding to generic vertex
//       attribute array index. If no buffer object is bound, 0 is returned.
//       The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_ENABLED
//       params returns a single value that is non-zero (true) if the vertex
//       attribute array for index is enabled and 0 (false) if it is
//       disabled. The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_SIZE
//       params returns a single value, the size of the vertex attribute
//       array for index. The size is the number of values for each element
//       of the vertex attribute array, and it will be 1, 2, 3, or 4. The
//       initial value is 4.
//
//   GL.VERTEX_ATTRIB_ARRAY_STRIDE
//       params returns a single value, the array stride for (number of bytes
//       between successive elements in) the vertex attribute array for
//       index. A value of 0 indicates that the array elements are stored
//       sequentially in memory. The initial value is 0.
//
//   GL.VERTEX_ATTRIB_ARRAY_TYPE
//       params returns a single value, a symbolic constant indicating the
//       array type for the vertex attribute array for index. Possible values
//       are GL.BYTE, GL.UNSIGNED_BYTE, GL.SHORT, GL.UNSIGNED_SHORT, GL.INT,
//       GL.UNSIGNED_INT, GL.FLOAT, and GL.DOUBLE. The initial value is
//       GL.FLOAT.
//
//   GL.VERTEX_ATTRIB_ARRAY_NORMALIZED
//       params returns a single value that is non-zero (true) if fixed-point
//       data types for the vertex attribute array indicated by index are
//       normalized when they are converted to floating point, and 0 (false)
//       otherwise. The initial value is 0.
//
//   GL.CURRENT_VERTEX_ATTRIB
//       params returns four values that represent the current value for the
//       generic vertex attribute specified by index. Generic vertex
//       attribute 0 is unique in that it has no current state, so an error
//       will be generated if index is 0. The initial value for all other
//       generic vertex attributes is (0,0,0,1).
//
// All of the parameters except GL.CURRENT_VERTEX_ATTRIB represent
// client-side state.
//
// Error GL.INVALID_VALUE is generated if index is greater than or equal to
// GL.MAX_VERTEX_ATTRIBS. GL.INVALID_ENUM is generated if pname is not an
// accepted value.  GL.INVALID_OPERATION is generated if index is 0 and pname
// is GL.CURRENT_VERTEX_ATTRIB.
//
// GetVertexAttrib is available only if the GL version is 2.0 or greater.
//
// https://www.opengl.org/sdk/docs/man2/xhtml/glGetVertexAttribdv.xml
func (gl *GL) GetVertexAttribdv(index glbase.Attrib, pname glbase.Enum) (params float64) {
	C.gl4_2compat_glGetVertexAttribdv(gl.funcs, C.GLuint(index), C.GLenum(pname), (*C.GLdouble)(unsafe.Pointer(&params)))
	return params
}

// GetUniformiv returns in params the value of the specified uniform
// variable. The type of the uniform variable specified by location
// determines the number of values returned. If the uniform variable is
// defined in the shader as a boolean, int, or float, a single value will be
// returned. If it is defined as a vec2, ivec2, or bvec2, two values will be
// returned. If it is defined as a vec3, ivec3, or bvec3, three values will
// be returned, and so on. To query values stored in uniform variables
// declared as arrays, call glGetUniformiv for each element of the array. To
// query values stored in uniform variables declared as structures, call
// glGetUniformiv for each field in the structure. The values for uniform
// variables declared as a matrix will be returned in column major order.
//
// The locations assigned to uniform variables are not known until the
// program object is linked. After linking has occurred, the command
// GetUniformLocation can be used to obtain the location of a uniform
// variable. This location value can then be passed to glGetUniformiv in order
// to query the current value of the uniform variable. After a program object
// has been linked successfully, the index values for uniform variables
// remain fixed until the next link command occurs. The uniform variable
// values can only be queried after a link if the link was successful.
//
// Error GL.INVALID_VALUE is generated if program is not a value generated by
// OpenGL. GL.INVALID_OPERATION is generated if program is not a program
// object. GL.INVALID_OPERATION is generated if program has not been
// successfully linked. GL.INVALID_OPERATION is generated if location does
// not correspond to a valid uniform variable location for the specified
// program object. GL.INVALID_OPERATION is generated if glGetUniformiv is
// executed between the execution of Begin and the corresponding execution of
// End.
//
// glGetUniformiv is available only if the GL version is 2.0 or greater.
//
// See also GetActiveUniform, GetUniformLocation, GetProgram, CreateProgram,
// LinkProgram.
//
// https://www.opengl.org/sdk/docs/man2/xhtml/glGetUniformiv.xml
func (gl *GL) GetUniformiv(program glbase.Program, location glbase.Uniform, params []int32) {
	var params_c [4]int32
	C.gl4_2compat_glGetUniformiv(gl.funcs, C.GLuint(program), C.GLint(location), (*C.GLint)(unsafe.Pointer(&params_c[0])))
	copy(params, params_c[:])
}

// GetUniformfv returns in params the value of the specified uniform
// variable. The type of the uniform variable specified by location
// determines the number of values returned. If the uniform variable is
// defined in the shader as a boolean, int, or float, a single value will be
// returned. If it is defined as a vec2, ivec2, or bvec2, two values will be
// returned. If it is defined as a vec3, ivec3, or bvec3, three values will
// be returned, and so on. To query values stored in uniform variables
// declared as arrays, call glGetUniformfv for each element of the array. To
// query values stored in uniform variables declared as structures, call
// glGetUniformfv for each field in the structure. The values for uniform
// variables declared as a matrix will be returned in column major order.
//
// The locations assigned to uniform variables are not known until the
// program object is linked. After linking has occurred, the command
// GetUniformLocation can be used to obtain the location of a uniform
// variable. This location value can then be passed to glGetUniformfv in order
// to query the current value of the uniform variable. After a program object
// has been linked successfully, the index values for uniform variables
// remain fixed until the next link command occurs. The uniform variable
// values can only be queried after a link if the link was successful.
//
// Error GL.INVALID_VALUE is generated if program is not a value generated by
// OpenGL. GL.INVALID_OPERATION is generated if program is not a program
// object. GL.INVALID_OPERATION is generated if program has not been
// successfully linked. GL.INVALID_OPERATION is generated if location does
// not correspond to a valid uniform variable location for the specified
// program object. GL.INVALID_OPERATION is generated if glGetUniformfv is
// executed between the execution of Begin and the corresponding execution of
// End.
//
// glGetUniformfv is available only if the GL version is 2.0 or greater.
//
// See also GetActiveUniform, GetUniformLocation, GetProgram, CreateProgram,
// LinkProgram.
//
// https://www.opengl.org/sdk/docs/man2/xhtml/glGetUniformfv.xml
func (gl *GL) GetUniformfv(program glbase.Program, location glbase.Uniform, params []float32) {
	var params_c [4]float32
	C.gl4_2compat_glGetUniformfv(gl.funcs, C.GLuint(program), C.GLint(location), (*C.GLfloat)(unsafe.Pointer(&params_c[0])))
	copy(params, params_c[:])
}

// GetUniformLocation returns an integer that represents the location of a
// specific uniform variable within a program object. name must be an active
// uniform variable name in program that is not a structure, an array of
// structures, or a subcomponent of a vector or a matrix. This function
// returns -1 if name does not correspond to an active uniform variable in
// program or if name starts with the reserved prefix "gl_".
//
// Uniform variables that are structures or arrays of structures may be
// queried by calling GetUniformLocation for each field within the
// structure. The array element operator "[]" and the structure field
// operator "." may be used in name in order to select elements within an
// array or fields within a structure. The result of using these operators is
// not allowed to be another structure, an array of structures, or a
// subcomponent of a vector or a matrix. Except if the last part of name
// indicates a uniform variable array, the location of the first element of
// an array can be retrieved by using the name of the array, or by using the
// name appended by "[0]".
//
// The actual locations assigned to uniform variables are not known until the
// program object is linked successfully. After linking has occurred, the
// command GetUniformLocation can be used to obtain the location of a
// uniform variable. This location value can then be passed to glUniform to
// set the value of the uniform variable or to GetUniform in order to query
// the current value of the uniform variable. After a program object has been
// linked successfully, the index values for uniform variables remain fixed
// until the next link command occurs. Uniform variable locations and values
// can only be queried after a link if the link was successful.
//
// Error GL.INVALID_VALUE is generated if program is not a value generated by
// OpenGL. GL.INVALID_OPERATION is generated if program is not a program object.
// GL.INVALID_OPERATION is generated if program has not been successfully
// linked. GL.INVALID_OPERATION is generated if GetUniformLocation is executed
// between the execution of glBegin and the corresponding execution of glEnd.
//
// GetUniformLocation is available only if the GL version is 2.0 or greater.
//
// See also GetActiveUniform, GetProgram, GetUniform, LinkProgram.
//
// https://www.opengl.org/sdk/docs/man2/xhtml/glGetUniformLocation.xml
func (gl *GL) GetUniformLocation(program glbase.Program, name string) glbase.Uniform {
	name_cstr := C.CString(name)
	result := C.gl4_2compat_glGetUniformLocation(gl.funcs, C.GLuint(program), (*C.GLchar)(name_cstr))
	C.free(unsafe.Pointer(name_cstr))
	return glbase.Uniform(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetShaderSource.xml
func (gl *GL) GetShaderSource(shader glbase.Shader, bufSize int32, length []int32, source []byte) {
	C.gl4_2compat_glGetShaderSource(gl.funcs, C.GLuint(shader), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLchar)(unsafe.Pointer(&source[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetShaderInfoLog.xml
func (gl *GL) GetShaderInfoLog(shader glbase.Shader, bufSize int32, length []int32, infoLog []byte) {
	C.gl4_2compat_glGetShaderInfoLog(gl.funcs, C.GLuint(shader), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLchar)(unsafe.Pointer(&infoLog[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetShaderiv.xml
func (gl *GL) GetShaderiv(shader glbase.Shader, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetShaderiv(gl.funcs, C.GLuint(shader), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetProgramInfoLog.xml
func (gl *GL) GetProgramInfoLog(program glbase.Program, bufSize int32, length []int32, infoLog []byte) {
	C.gl4_2compat_glGetProgramInfoLog(gl.funcs, C.GLuint(program), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLchar)(unsafe.Pointer(&infoLog[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetProgramiv.xml
func (gl *GL) GetProgramiv(program glbase.Program, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetProgramiv(gl.funcs, C.GLuint(program), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// GetAttribLocation queries the previously linked program object specified
// by program for the attribute variable specified by name and returns the
// index of the generic vertex attribute that is bound to that attribute
// variable. If name is a matrix attribute variable, the index of the first
// column of the matrix is returned. If the named attribute variable is not
// an active attribute in the specified program object or if name starts with
// the reserved prefix "gl_", a value of -1 is returned.
//
// The association between an attribute variable name and a generic attribute
// index can be specified at any time by calling BindAttribLocation.
// Attribute bindings do not go into effect until LinkProgram is called.
// After a program object has been linked successfully, the index values for
// attribute variables remain fixed until the next link command occurs. The
// attribute values can only be queried after a link if the link was
// successful. GetAttribLocation returns the binding that actually went
// into effect the last time glLinkProgram was called for the specified
// program object. Attribute bindings that have been specified since the last
// link operation are not returned by GetAttribLocation.
//
// Error GL_INVALID_OPERATION is generated if program is not a value
// generated by OpenGL. GL_INVALID_OPERATION is generated if program is not
// a program object. GL_INVALID_OPERATION is generated if program has not
// been successfully linked.  GL_INVALID_OPERATION is generated if
// GetAttribLocation is executed between the execution of glBegin and the
// corresponding execution of glEnd.
//
// GetAttribLocation is available only if the GL version is 2.0 or greater.
//
// See also GetActiveAttrib, BindAttribLocation, LinkProgram, VertexAttrib,
// VertexAttribPointer.
//
// https://www.opengl.org/sdk/docs/man2/xhtml/glGetAttribLocation.xml
func (gl *GL) GetAttribLocation(program glbase.Program, name string) glbase.Attrib {
	name_cstr := C.CString(name)
	result := C.gl4_2compat_glGetAttribLocation(gl.funcs, C.GLuint(program), (*C.GLchar)(name_cstr))
	C.free(unsafe.Pointer(name_cstr))
	return glbase.Attrib(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetAttachedShaders.xml
func (gl *GL) GetAttachedShaders(program glbase.Program, maxCount int32, count []int32, obj []uint32) {
	C.gl4_2compat_glGetAttachedShaders(gl.funcs, C.GLuint(program), C.GLsizei(maxCount), (*C.GLsizei)(unsafe.Pointer(&count[0])), (*C.GLuint)(unsafe.Pointer(&obj[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetActiveUniform.xml
func (gl *GL) GetActiveUniform(program glbase.Program, index uint32, bufSize int32, length, size []int32, gltype []glbase.Enum, name []byte) {
	C.gl4_2compat_glGetActiveUniform(gl.funcs, C.GLuint(program), C.GLuint(index), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLint)(unsafe.Pointer(&size[0])), (*C.GLenum)(unsafe.Pointer(&gltype[0])), (*C.GLchar)(unsafe.Pointer(&name[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetActiveAttrib.xml
func (gl *GL) GetActiveAttrib(program glbase.Program, index glbase.Attrib, bufSize int32, length, size []int32, gltype []glbase.Enum, name []byte) {
	C.gl4_2compat_glGetActiveAttrib(gl.funcs, C.GLuint(program), C.GLuint(index), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLint)(unsafe.Pointer(&size[0])), (*C.GLenum)(unsafe.Pointer(&gltype[0])), (*C.GLchar)(unsafe.Pointer(&name[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEnableVertexAttribArray.xml
func (gl *GL) EnableVertexAttribArray(index glbase.Attrib) {
	C.gl4_2compat_glEnableVertexAttribArray(gl.funcs, C.GLuint(index))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDisableVertexAttribArray.xml
func (gl *GL) DisableVertexAttribArray(index glbase.Attrib) {
	C.gl4_2compat_glDisableVertexAttribArray(gl.funcs, C.GLuint(index))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDetachShader.xml
func (gl *GL) DetachShader(program glbase.Program, shader glbase.Shader) {
	C.gl4_2compat_glDetachShader(gl.funcs, C.GLuint(program), C.GLuint(shader))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteShader.xml
func (gl *GL) DeleteShader(shader glbase.Shader) {
	C.gl4_2compat_glDeleteShader(gl.funcs, C.GLuint(shader))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteProgram.xml
func (gl *GL) DeleteProgram(program glbase.Program) {
	C.gl4_2compat_glDeleteProgram(gl.funcs, C.GLuint(program))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCreateShader.xml
func (gl *GL) CreateShader(gltype glbase.Enum) glbase.Shader {
	result := C.gl4_2compat_glCreateShader(gl.funcs, C.GLenum(gltype))
	return glbase.Shader(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCreateProgram.xml
func (gl *GL) CreateProgram() glbase.Program {
	result := C.gl4_2compat_glCreateProgram(gl.funcs)
	return glbase.Program(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCompileShader.xml
func (gl *GL) CompileShader(shader glbase.Shader) {
	C.gl4_2compat_glCompileShader(gl.funcs, C.GLuint(shader))
}

// BindAttribLocation associates a user-defined attribute variable in the program
// object specified by program with a generic vertex attribute index. The name
// parameter specifies the name of the vertex shader attribute variable to
// which index is to be bound. When program is made part of the current state,
// values provided via the generic vertex attribute index will modify the
// value of the user-defined attribute variable specified by name.
//
// If name refers to a matrix attribute variable, index refers to the first
// column of the matrix. Other matrix columns are then automatically bound to
// locations index+1 for a matrix of type mat2; index+1 and index+2 for a
// matrix of type mat3; and index+1, index+2, and index+3 for a matrix of
// type mat4.
//
// This command makes it possible for vertex shaders to use descriptive names
// for attribute variables rather than generic variables that are numbered
// from 0 to GL.MAX_VERTEX_ATTRIBS-1. The values sent to each generic
// attribute index are part of current state, just like standard vertex
// attributes such as color, normal, and vertex position. If a different
// program object is made current by calling UseProgram, the generic vertex
// attributes are tracked in such a way that the same values will be observed
// by attributes in the new program object that are also bound to index.
//
// Attribute variable name-to-generic attribute index bindings for a program
// object can be explicitly assigned at any time by calling
// BindAttribLocation. Attribute bindings do not go into effect until
// LinkProgram is called. After a program object has been linked
// successfully, the index values for generic attributes remain fixed (and
// their values can be queried) until the next link command occurs.
//
// Applications are not allowed to bind any of the standard OpenGL vertex
// attributes using this command, as they are bound automatically when
// needed. Any attribute binding that occurs after the program object has
// been linked will not take effect until the next time the program object is
// linked.
//
// If name was bound previously, that information is lost. Thus you cannot
// bind one user-defined attribute variable to multiple indices, but you can
// bind multiple user-defined attribute variables to the same index.
//
// Applications are allowed to bind more than one user-defined attribute
// variable to the same generic vertex attribute index. This is called
// aliasing, and it is allowed only if just one of the aliased attributes is
// active in the executable program, or if no path through the shader
// consumes more than one attribute of a set of attributes aliased to the
// same location. The compiler and linker are allowed to assume that no
// aliasing is done and are free to employ optimizations that work only in
// the absence of aliasing. OpenGL implementations are not required to do
// error checking to detect aliasing. Because there is no way to bind
// standard attributes, it is not possible to alias generic attributes with
// conventional ones (except for generic attribute 0).
//
// BindAttribLocation can be called before any vertex shader objects are
// bound to the specified program object. It is also permissible to bind a
// generic attribute index to an attribute variable name that is never used
// in a vertex shader.
//
// Active attributes that are not explicitly bound will be bound by the
// linker when LinkProgram is called. The locations assigned can be queried
// by calling GetAttribLocation.
//
// Error GL.INVALID_VALUE is generated if index is greater than or equal to
// GL.MAX_VERTEX_ATTRIBS.
// GL.INVALID_OPERATION is generated if name starts with the reserved prefix "gl_".
// GL.INVALID_VALUE is generated if program is not a value generated by OpenGL.
// GL.INVALID_OPERATION is generated if program is not a program object.
// GL.INVALID_OPERATION is generated if BindAttribLocation is executed
// between the execution of Begin and the corresponding execution of End.
//
// BindAttribLocation is available only if the GL version is 2.0 or greater.
//
// See also GetActiveAttrib, GetAttribLocation, EnableVertexAttribArray,
// DisableVertexAttribArray, VertexAttrib, VertexAttribPointer.
//
// https://www.opengl.org/sdk/docs/man2/xhtml/glBindAttribLocation.xml
func (gl *GL) BindAttribLocation(program glbase.Program, index glbase.Attrib, name string) {
	name_cstr := C.CString(name)
	C.gl4_2compat_glBindAttribLocation(gl.funcs, C.GLuint(program), C.GLuint(index), (*C.GLchar)(name_cstr))
	C.free(unsafe.Pointer(name_cstr))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glAttachShader.xml
func (gl *GL) AttachShader(program glbase.Program, shader glbase.Shader) {
	C.gl4_2compat_glAttachShader(gl.funcs, C.GLuint(program), C.GLuint(shader))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glStencilMaskSeparate.xml
func (gl *GL) StencilMaskSeparate(face glbase.Enum, mask uint32) {
	C.gl4_2compat_glStencilMaskSeparate(gl.funcs, C.GLenum(face), C.GLuint(mask))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glStencilFuncSeparate.xml
func (gl *GL) StencilFuncSeparate(face, glfunc glbase.Enum, ref int32, mask uint32) {
	C.gl4_2compat_glStencilFuncSeparate(gl.funcs, C.GLenum(face), C.GLenum(glfunc), C.GLint(ref), C.GLuint(mask))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glStencilOpSeparate.xml
func (gl *GL) StencilOpSeparate(face, sfail, dpfail, dppass glbase.Enum) {
	C.gl4_2compat_glStencilOpSeparate(gl.funcs, C.GLenum(face), C.GLenum(sfail), C.GLenum(dpfail), C.GLenum(dppass))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawBuffers.xml
func (gl *GL) DrawBuffers(n int32, bufs []glbase.Enum) {
	C.gl4_2compat_glDrawBuffers(gl.funcs, C.GLsizei(n), (*C.GLenum)(unsafe.Pointer(&bufs[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBlendEquationSeparate.xml
func (gl *GL) BlendEquationSeparate(modeRGB, modeAlpha glbase.Enum) {
	C.gl4_2compat_glBlendEquationSeparate(gl.funcs, C.GLenum(modeRGB), C.GLenum(modeAlpha))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsVertexArray.xml
func (gl *GL) IsVertexArray(array uint32) bool {
	result := C.gl4_2compat_glIsVertexArray(gl.funcs, C.GLuint(array))
	return *(*bool)(unsafe.Pointer(&result))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGenVertexArrays.xml
func (gl *GL) GenVertexArrays(n int32, arrays []uint32) {
	C.gl4_2compat_glGenVertexArrays(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&arrays[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteVertexArrays.xml
func (gl *GL) DeleteVertexArrays(n int32, arrays []uint32) {
	C.gl4_2compat_glDeleteVertexArrays(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&arrays[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindVertexArray.xml
func (gl *GL) BindVertexArray(array uint32) {
	C.gl4_2compat_glBindVertexArray(gl.funcs, C.GLuint(array))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFlushMappedBufferRange.xml
func (gl *GL) FlushMappedBufferRange(target glbase.Enum, offset, length int) {
	C.gl4_2compat_glFlushMappedBufferRange(gl.funcs, C.GLenum(target), C.GLintptr(offset), C.GLsizeiptr(length))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFramebufferTextureLayer.xml
func (gl *GL) FramebufferTextureLayer(target, attachment glbase.Enum, texture glbase.Texture, level, layer int32) {
	C.gl4_2compat_glFramebufferTextureLayer(gl.funcs, C.GLenum(target), C.GLenum(attachment), C.GLuint(texture), C.GLint(level), C.GLint(layer))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRenderbufferStorageMultisample.xml
func (gl *GL) RenderbufferStorageMultisample(target glbase.Enum, samples int32, internalformat glbase.Enum, width, height int32) {
	C.gl4_2compat_glRenderbufferStorageMultisample(gl.funcs, C.GLenum(target), C.GLsizei(samples), C.GLenum(internalformat), C.GLsizei(width), C.GLsizei(height))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBlitFramebuffer.xml
func (gl *GL) BlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1 int32, mask glbase.Bitfield, filter glbase.Enum) {
	C.gl4_2compat_glBlitFramebuffer(gl.funcs, C.GLint(srcX0), C.GLint(srcY0), C.GLint(srcX1), C.GLint(srcY1), C.GLint(dstX0), C.GLint(dstY0), C.GLint(dstX1), C.GLint(dstY1), C.GLbitfield(mask), C.GLenum(filter))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGenerateMipmap.xml
func (gl *GL) GenerateMipmap(target glbase.Enum) {
	C.gl4_2compat_glGenerateMipmap(gl.funcs, C.GLenum(target))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetFramebufferAttachmentParameteriv.xml
func (gl *GL) GetFramebufferAttachmentParameteriv(target, attachment, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetFramebufferAttachmentParameteriv(gl.funcs, C.GLenum(target), C.GLenum(attachment), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFramebufferRenderbuffer.xml
func (gl *GL) FramebufferRenderbuffer(target, attachment, renderbuffertarget glbase.Enum, renderbuffer uint32) {
	C.gl4_2compat_glFramebufferRenderbuffer(gl.funcs, C.GLenum(target), C.GLenum(attachment), C.GLenum(renderbuffertarget), C.GLuint(renderbuffer))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFramebufferTexture3D.xml
func (gl *GL) FramebufferTexture3D(target, attachment, textarget glbase.Enum, texture glbase.Texture, level, zoffset int32) {
	C.gl4_2compat_glFramebufferTexture3D(gl.funcs, C.GLenum(target), C.GLenum(attachment), C.GLenum(textarget), C.GLuint(texture), C.GLint(level), C.GLint(zoffset))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFramebufferTexture2D.xml
func (gl *GL) FramebufferTexture2D(target, attachment, textarget glbase.Enum, texture glbase.Texture, level int32) {
	C.gl4_2compat_glFramebufferTexture2D(gl.funcs, C.GLenum(target), C.GLenum(attachment), C.GLenum(textarget), C.GLuint(texture), C.GLint(level))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFramebufferTexture1D.xml
func (gl *GL) FramebufferTexture1D(target, attachment, textarget glbase.Enum, texture glbase.Texture, level int32) {
	C.gl4_2compat_glFramebufferTexture1D(gl.funcs, C.GLenum(target), C.GLenum(attachment), C.GLenum(textarget), C.GLuint(texture), C.GLint(level))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCheckFramebufferStatus.xml
func (gl *GL) CheckFramebufferStatus(target glbase.Enum) glbase.Enum {
	result := C.gl4_2compat_glCheckFramebufferStatus(gl.funcs, C.GLenum(target))
	return glbase.Enum(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGenFramebuffers.xml
func (gl *GL) GenFramebuffers(n int32, framebuffers []uint32) {
	C.gl4_2compat_glGenFramebuffers(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&framebuffers[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteFramebuffers.xml
func (gl *GL) DeleteFramebuffers(n int32, framebuffers []uint32) {
	C.gl4_2compat_glDeleteFramebuffers(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&framebuffers[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindFramebuffer.xml
func (gl *GL) BindFramebuffer(target glbase.Enum, framebuffer uint32) {
	C.gl4_2compat_glBindFramebuffer(gl.funcs, C.GLenum(target), C.GLuint(framebuffer))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsFramebuffer.xml
func (gl *GL) IsFramebuffer(framebuffer uint32) bool {
	result := C.gl4_2compat_glIsFramebuffer(gl.funcs, C.GLuint(framebuffer))
	return *(*bool)(unsafe.Pointer(&result))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetRenderbufferParameteriv.xml
func (gl *GL) GetRenderbufferParameteriv(target, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetRenderbufferParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRenderbufferStorage.xml
func (gl *GL) RenderbufferStorage(target, internalformat glbase.Enum, width, height int32) {
	C.gl4_2compat_glRenderbufferStorage(gl.funcs, C.GLenum(target), C.GLenum(internalformat), C.GLsizei(width), C.GLsizei(height))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGenRenderbuffers.xml
func (gl *GL) GenRenderbuffers(n int32, renderbuffers []uint32) {
	C.gl4_2compat_glGenRenderbuffers(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&renderbuffers[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteRenderbuffers.xml
func (gl *GL) DeleteRenderbuffers(n int32, renderbuffers []uint32) {
	C.gl4_2compat_glDeleteRenderbuffers(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&renderbuffers[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindRenderbuffer.xml
func (gl *GL) BindRenderbuffer(target glbase.Enum, renderbuffer uint32) {
	C.gl4_2compat_glBindRenderbuffer(gl.funcs, C.GLenum(target), C.GLuint(renderbuffer))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsRenderbuffer.xml
func (gl *GL) IsRenderbuffer(renderbuffer uint32) bool {
	result := C.gl4_2compat_glIsRenderbuffer(gl.funcs, C.GLuint(renderbuffer))
	return *(*bool)(unsafe.Pointer(&result))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClearBufferfi.xml
func (gl *GL) ClearBufferfi(buffer glbase.Enum, drawbuffer int32, depth float32, stencil int32) {
	C.gl4_2compat_glClearBufferfi(gl.funcs, C.GLenum(buffer), C.GLint(drawbuffer), C.GLfloat(depth), C.GLint(stencil))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClearBufferfv.xml
func (gl *GL) ClearBufferfv(buffer glbase.Enum, drawbuffer int32, value []float32) {
	C.gl4_2compat_glClearBufferfv(gl.funcs, C.GLenum(buffer), C.GLint(drawbuffer), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClearBufferuiv.xml
func (gl *GL) ClearBufferuiv(buffer glbase.Enum, drawbuffer int32, value []uint32) {
	C.gl4_2compat_glClearBufferuiv(gl.funcs, C.GLenum(buffer), C.GLint(drawbuffer), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClearBufferiv.xml
func (gl *GL) ClearBufferiv(buffer glbase.Enum, drawbuffer int32, value []int32) {
	C.gl4_2compat_glClearBufferiv(gl.funcs, C.GLenum(buffer), C.GLint(drawbuffer), (*C.GLint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetTexParameterIuiv.xml
func (gl *GL) GetTexParameterIuiv(target, pname glbase.Enum, params []uint32) {
	C.gl4_2compat_glGetTexParameterIuiv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLuint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetTexParameterIiv.xml
func (gl *GL) GetTexParameterIiv(target, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetTexParameterIiv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexParameterIuiv.xml
func (gl *GL) TexParameterIuiv(target, pname glbase.Enum, params []uint32) {
	C.gl4_2compat_glTexParameterIuiv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLuint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexParameterIiv.xml
func (gl *GL) TexParameterIiv(target, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glTexParameterIiv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform4ui.xml
func (gl *GL) Uniform4ui(location glbase.Uniform, v0, v1, v2, v3 uint32) {
	C.gl4_2compat_glUniform4ui(gl.funcs, C.GLint(location), C.GLuint(v0), C.GLuint(v1), C.GLuint(v2), C.GLuint(v3))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform3ui.xml
func (gl *GL) Uniform3ui(location glbase.Uniform, v0, v1, v2 uint32) {
	C.gl4_2compat_glUniform3ui(gl.funcs, C.GLint(location), C.GLuint(v0), C.GLuint(v1), C.GLuint(v2))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform2ui.xml
func (gl *GL) Uniform2ui(location glbase.Uniform, v0, v1 uint32) {
	C.gl4_2compat_glUniform2ui(gl.funcs, C.GLint(location), C.GLuint(v0), C.GLuint(v1))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform1ui.xml
func (gl *GL) Uniform1ui(location glbase.Uniform, v0 uint32) {
	C.gl4_2compat_glUniform1ui(gl.funcs, C.GLint(location), C.GLuint(v0))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetFragDataLocation.xml
func (gl *GL) GetFragDataLocation(program glbase.Program, name []byte) int32 {
	result := C.gl4_2compat_glGetFragDataLocation(gl.funcs, C.GLuint(program), (*C.GLchar)(unsafe.Pointer(&name[0])))
	return int32(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindFragDataLocation.xml
func (gl *GL) BindFragDataLocation(program glbase.Program, color uint32, name []byte) {
	C.gl4_2compat_glBindFragDataLocation(gl.funcs, C.GLuint(program), C.GLuint(color), (*C.GLchar)(unsafe.Pointer(&name[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetUniformuiv.xml
func (gl *GL) GetUniformuiv(program glbase.Program, location glbase.Uniform, params []uint32) {
	C.gl4_2compat_glGetUniformuiv(gl.funcs, C.GLuint(program), C.GLint(location), (*C.GLuint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetVertexAttribIuiv.xml
func (gl *GL) GetVertexAttribIuiv(index glbase.Attrib, pname glbase.Enum, params []uint32) {
	C.gl4_2compat_glGetVertexAttribIuiv(gl.funcs, C.GLuint(index), C.GLenum(pname), (*C.GLuint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetVertexAttribIiv.xml
func (gl *GL) GetVertexAttribIiv(index glbase.Attrib, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetVertexAttribIiv(gl.funcs, C.GLuint(index), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribIPointer.xml
func (gl *GL) VertexAttribIPointer(index glbase.Attrib, size int32, gltype glbase.Enum, stride int32, pointer interface{}) {
	pointer_v := reflect.ValueOf(pointer)
	if pointer_v.Kind() != reflect.Slice {
		panic("parameter pointer must be a slice")
	}
	C.gl4_2compat_glVertexAttribIPointer(gl.funcs, C.GLuint(index), C.GLint(size), C.GLenum(gltype), C.GLsizei(stride), unsafe.Pointer(pointer_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEndConditionalRender.xml
func (gl *GL) EndConditionalRender() {
	C.gl4_2compat_glEndConditionalRender(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBeginConditionalRender.xml
func (gl *GL) BeginConditionalRender(id uint32, mode glbase.Enum) {
	C.gl4_2compat_glBeginConditionalRender(gl.funcs, C.GLuint(id), C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClampColor.xml
func (gl *GL) ClampColor(target, clamp glbase.Enum) {
	C.gl4_2compat_glClampColor(gl.funcs, C.GLenum(target), C.GLenum(clamp))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetTransformFeedbackVarying.xml
func (gl *GL) GetTransformFeedbackVarying(program glbase.Program, index uint32, bufSize int32, length, size []int32, gltype []glbase.Enum, name []byte) {
	C.gl4_2compat_glGetTransformFeedbackVarying(gl.funcs, C.GLuint(program), C.GLuint(index), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLsizei)(unsafe.Pointer(&size[0])), (*C.GLenum)(unsafe.Pointer(&gltype[0])), (*C.GLchar)(unsafe.Pointer(&name[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindBufferBase.xml
func (gl *GL) BindBufferBase(target glbase.Enum, index uint32, buffer glbase.Buffer) {
	C.gl4_2compat_glBindBufferBase(gl.funcs, C.GLenum(target), C.GLuint(index), C.GLuint(buffer))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindBufferRange.xml
func (gl *GL) BindBufferRange(target glbase.Enum, index uint32, buffer glbase.Buffer, offset, size int) {
	C.gl4_2compat_glBindBufferRange(gl.funcs, C.GLenum(target), C.GLuint(index), C.GLuint(buffer), C.GLintptr(offset), C.GLsizeiptr(size))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEndTransformFeedback.xml
func (gl *GL) EndTransformFeedback() {
	C.gl4_2compat_glEndTransformFeedback(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBeginTransformFeedback.xml
func (gl *GL) BeginTransformFeedback(primitiveMode glbase.Enum) {
	C.gl4_2compat_glBeginTransformFeedback(gl.funcs, C.GLenum(primitiveMode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsEnabledi.xml
func (gl *GL) IsEnabledi(target glbase.Enum, index uint32) bool {
	result := C.gl4_2compat_glIsEnabledi(gl.funcs, C.GLenum(target), C.GLuint(index))
	return *(*bool)(unsafe.Pointer(&result))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDisablei.xml
func (gl *GL) Disablei(target glbase.Enum, index uint32) {
	C.gl4_2compat_glDisablei(gl.funcs, C.GLenum(target), C.GLuint(index))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEnablei.xml
func (gl *GL) Enablei(target glbase.Enum, index uint32) {
	C.gl4_2compat_glEnablei(gl.funcs, C.GLenum(target), C.GLuint(index))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetIntegeri_v.xml
func (gl *GL) GetIntegeri_v(target glbase.Enum, index uint32, data []int32) {
	C.gl4_2compat_glGetIntegeri_v(gl.funcs, C.GLenum(target), C.GLuint(index), (*C.GLint)(unsafe.Pointer(&data[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetBooleani_v.xml
func (gl *GL) GetBooleani_v(target glbase.Enum, index uint32, data []bool) {
	C.gl4_2compat_glGetBooleani_v(gl.funcs, C.GLenum(target), C.GLuint(index), (*C.GLboolean)(unsafe.Pointer(&data[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColorMaski.xml
func (gl *GL) ColorMaski(index uint32, r, g, b, a bool) {
	C.gl4_2compat_glColorMaski(gl.funcs, C.GLuint(index), *(*C.GLboolean)(unsafe.Pointer(&r)), *(*C.GLboolean)(unsafe.Pointer(&g)), *(*C.GLboolean)(unsafe.Pointer(&b)), *(*C.GLboolean)(unsafe.Pointer(&a)))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCopyBufferSubData.xml
func (gl *GL) CopyBufferSubData(readTarget, writeTarget glbase.Enum, readOffset, writeOffset, size int) {
	C.gl4_2compat_glCopyBufferSubData(gl.funcs, C.GLenum(readTarget), C.GLenum(writeTarget), C.GLintptr(readOffset), C.GLintptr(writeOffset), C.GLsizeiptr(size))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniformBlockBinding.xml
func (gl *GL) UniformBlockBinding(program glbase.Program, uniformBlockIndex, uniformBlockBinding uint32) {
	C.gl4_2compat_glUniformBlockBinding(gl.funcs, C.GLuint(program), C.GLuint(uniformBlockIndex), C.GLuint(uniformBlockBinding))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetActiveUniformBlockName.xml
func (gl *GL) GetActiveUniformBlockName(program glbase.Program, uniformBlockIndex uint32, bufSize int32, length []int32, uniformBlockName []byte) {
	C.gl4_2compat_glGetActiveUniformBlockName(gl.funcs, C.GLuint(program), C.GLuint(uniformBlockIndex), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLchar)(unsafe.Pointer(&uniformBlockName[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetActiveUniformBlockiv.xml
func (gl *GL) GetActiveUniformBlockiv(program glbase.Program, uniformBlockIndex uint32, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetActiveUniformBlockiv(gl.funcs, C.GLuint(program), C.GLuint(uniformBlockIndex), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetUniformBlockIndex.xml
func (gl *GL) GetUniformBlockIndex(program glbase.Program, uniformBlockName []byte) uint32 {
	result := C.gl4_2compat_glGetUniformBlockIndex(gl.funcs, C.GLuint(program), (*C.GLchar)(unsafe.Pointer(&uniformBlockName[0])))
	return uint32(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetActiveUniformName.xml
func (gl *GL) GetActiveUniformName(program glbase.Program, uniformIndex uint32, bufSize int32, length []int32, uniformName []byte) {
	C.gl4_2compat_glGetActiveUniformName(gl.funcs, C.GLuint(program), C.GLuint(uniformIndex), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLchar)(unsafe.Pointer(&uniformName[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetActiveUniformsiv.xml
func (gl *GL) GetActiveUniformsiv(program glbase.Program, uniformCount int32, uniformIndices []uint32, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetActiveUniformsiv(gl.funcs, C.GLuint(program), C.GLsizei(uniformCount), (*C.GLuint)(unsafe.Pointer(&uniformIndices[0])), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPrimitiveRestartIndex.xml
func (gl *GL) PrimitiveRestartIndex(index uint32) {
	C.gl4_2compat_glPrimitiveRestartIndex(gl.funcs, C.GLuint(index))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexBuffer.xml
func (gl *GL) TexBuffer(target, internalformat glbase.Enum, buffer glbase.Buffer) {
	C.gl4_2compat_glTexBuffer(gl.funcs, C.GLenum(target), C.GLenum(internalformat), C.GLuint(buffer))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawElementsInstanced.xml
func (gl *GL) DrawElementsInstanced(mode glbase.Enum, count int32, gltype glbase.Enum, indices interface{}, instancecount int32) {
	indices_v := reflect.ValueOf(indices)
	if indices_v.Kind() != reflect.Slice {
		panic("parameter indices must be a slice")
	}
	C.gl4_2compat_glDrawElementsInstanced(gl.funcs, C.GLenum(mode), C.GLsizei(count), C.GLenum(gltype), unsafe.Pointer(indices_v.Index(0).Addr().Pointer()), C.GLsizei(instancecount))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawArraysInstanced.xml
func (gl *GL) DrawArraysInstanced(mode glbase.Enum, first, count, instancecount int32) {
	C.gl4_2compat_glDrawArraysInstanced(gl.funcs, C.GLenum(mode), C.GLint(first), C.GLsizei(count), C.GLsizei(instancecount))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSampleMaski.xml
func (gl *GL) SampleMaski(index uint32, mask glbase.Bitfield) {
	C.gl4_2compat_glSampleMaski(gl.funcs, C.GLuint(index), C.GLbitfield(mask))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetMultisamplefv.xml
func (gl *GL) GetMultisamplefv(pname glbase.Enum, index uint32, val []float32) {
	C.gl4_2compat_glGetMultisamplefv(gl.funcs, C.GLenum(pname), C.GLuint(index), (*C.GLfloat)(unsafe.Pointer(&val[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexImage3DMultisample.xml
func (gl *GL) TexImage3DMultisample(target glbase.Enum, samples, internalformat, width, height, depth int32, fixedsamplelocations bool) {
	C.gl4_2compat_glTexImage3DMultisample(gl.funcs, C.GLenum(target), C.GLsizei(samples), C.GLint(internalformat), C.GLsizei(width), C.GLsizei(height), C.GLsizei(depth), *(*C.GLboolean)(unsafe.Pointer(&fixedsamplelocations)))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexImage2DMultisample.xml
func (gl *GL) TexImage2DMultisample(target glbase.Enum, samples, internalformat, width, height int32, fixedsamplelocations bool) {
	C.gl4_2compat_glTexImage2DMultisample(gl.funcs, C.GLenum(target), C.GLsizei(samples), C.GLint(internalformat), C.GLsizei(width), C.GLsizei(height), *(*C.GLboolean)(unsafe.Pointer(&fixedsamplelocations)))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetSynciv.xml
func (gl *GL) GetSynciv(sync glbase.Sync, pname glbase.Enum, bufSize int32, length, values []int32) {
	C.gl4_2compat_glGetSynciv(gl.funcs, C.GLsync(sync), C.GLenum(pname), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLint)(unsafe.Pointer(&values[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetInteger64v.xml
func (gl *GL) GetInteger64v(pname glbase.Enum, params []int64) {
	C.gl4_2compat_glGetInteger64v(gl.funcs, C.GLenum(pname), (*C.GLint64)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glWaitSync.xml
func (gl *GL) WaitSync(sync glbase.Sync, flags glbase.Bitfield, timeout uint64) {
	C.gl4_2compat_glWaitSync(gl.funcs, C.GLsync(sync), C.GLbitfield(flags), C.GLuint64(timeout))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClientWaitSync.xml
func (gl *GL) ClientWaitSync(sync glbase.Sync, flags glbase.Bitfield, timeout uint64) glbase.Enum {
	result := C.gl4_2compat_glClientWaitSync(gl.funcs, C.GLsync(sync), C.GLbitfield(flags), C.GLuint64(timeout))
	return glbase.Enum(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteSync.xml
func (gl *GL) DeleteSync(sync glbase.Sync) {
	C.gl4_2compat_glDeleteSync(gl.funcs, C.GLsync(sync))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsSync.xml
func (gl *GL) IsSync(sync glbase.Sync) bool {
	result := C.gl4_2compat_glIsSync(gl.funcs, C.GLsync(sync))
	return *(*bool)(unsafe.Pointer(&result))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFenceSync.xml
func (gl *GL) FenceSync(condition glbase.Enum, flags glbase.Bitfield) glbase.Sync {
	result := C.gl4_2compat_glFenceSync(gl.funcs, C.GLenum(condition), C.GLbitfield(flags))
	return glbase.Sync(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProvokingVertex.xml
func (gl *GL) ProvokingVertex(mode glbase.Enum) {
	C.gl4_2compat_glProvokingVertex(gl.funcs, C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawElementsInstancedBaseVertex.xml
func (gl *GL) DrawElementsInstancedBaseVertex(mode glbase.Enum, count int32, gltype glbase.Enum, indices interface{}, instancecount, basevertex int32) {
	indices_v := reflect.ValueOf(indices)
	if indices_v.Kind() != reflect.Slice {
		panic("parameter indices must be a slice")
	}
	C.gl4_2compat_glDrawElementsInstancedBaseVertex(gl.funcs, C.GLenum(mode), C.GLsizei(count), C.GLenum(gltype), unsafe.Pointer(indices_v.Index(0).Addr().Pointer()), C.GLsizei(instancecount), C.GLint(basevertex))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawRangeElementsBaseVertex.xml
func (gl *GL) DrawRangeElementsBaseVertex(mode glbase.Enum, start, end uint32, count int32, gltype glbase.Enum, indices interface{}, basevertex int32) {
	indices_v := reflect.ValueOf(indices)
	if indices_v.Kind() != reflect.Slice {
		panic("parameter indices must be a slice")
	}
	C.gl4_2compat_glDrawRangeElementsBaseVertex(gl.funcs, C.GLenum(mode), C.GLuint(start), C.GLuint(end), C.GLsizei(count), C.GLenum(gltype), unsafe.Pointer(indices_v.Index(0).Addr().Pointer()), C.GLint(basevertex))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawElementsBaseVertex.xml
func (gl *GL) DrawElementsBaseVertex(mode glbase.Enum, count int32, gltype glbase.Enum, indices interface{}, basevertex int32) {
	indices_v := reflect.ValueOf(indices)
	if indices_v.Kind() != reflect.Slice {
		panic("parameter indices must be a slice")
	}
	C.gl4_2compat_glDrawElementsBaseVertex(gl.funcs, C.GLenum(mode), C.GLsizei(count), C.GLenum(gltype), unsafe.Pointer(indices_v.Index(0).Addr().Pointer()), C.GLint(basevertex))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFramebufferTexture.xml
func (gl *GL) FramebufferTexture(target, attachment glbase.Enum, texture glbase.Texture, level int32) {
	C.gl4_2compat_glFramebufferTexture(gl.funcs, C.GLenum(target), C.GLenum(attachment), C.GLuint(texture), C.GLint(level))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetBufferParameteri64v.xml
func (gl *GL) GetBufferParameteri64v(target, pname glbase.Enum, params []int64) {
	C.gl4_2compat_glGetBufferParameteri64v(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint64)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetInteger64i_v.xml
func (gl *GL) GetInteger64i_v(target glbase.Enum, index uint32, data []int64) {
	C.gl4_2compat_glGetInteger64i_v(gl.funcs, C.GLenum(target), C.GLuint(index), (*C.GLint64)(unsafe.Pointer(&data[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribP4uiv.xml
func (gl *GL) VertexAttribP4uiv(index glbase.Attrib, gltype glbase.Enum, normalized bool, value []uint32) {
	C.gl4_2compat_glVertexAttribP4uiv(gl.funcs, C.GLuint(index), C.GLenum(gltype), *(*C.GLboolean)(unsafe.Pointer(&normalized)), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribP4ui.xml
func (gl *GL) VertexAttribP4ui(index glbase.Attrib, gltype glbase.Enum, normalized bool, value uint32) {
	C.gl4_2compat_glVertexAttribP4ui(gl.funcs, C.GLuint(index), C.GLenum(gltype), *(*C.GLboolean)(unsafe.Pointer(&normalized)), C.GLuint(value))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribP3uiv.xml
func (gl *GL) VertexAttribP3uiv(index glbase.Attrib, gltype glbase.Enum, normalized bool, value []uint32) {
	C.gl4_2compat_glVertexAttribP3uiv(gl.funcs, C.GLuint(index), C.GLenum(gltype), *(*C.GLboolean)(unsafe.Pointer(&normalized)), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribP3ui.xml
func (gl *GL) VertexAttribP3ui(index glbase.Attrib, gltype glbase.Enum, normalized bool, value uint32) {
	C.gl4_2compat_glVertexAttribP3ui(gl.funcs, C.GLuint(index), C.GLenum(gltype), *(*C.GLboolean)(unsafe.Pointer(&normalized)), C.GLuint(value))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribP2uiv.xml
func (gl *GL) VertexAttribP2uiv(index glbase.Attrib, gltype glbase.Enum, normalized bool, value []uint32) {
	C.gl4_2compat_glVertexAttribP2uiv(gl.funcs, C.GLuint(index), C.GLenum(gltype), *(*C.GLboolean)(unsafe.Pointer(&normalized)), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribP2ui.xml
func (gl *GL) VertexAttribP2ui(index glbase.Attrib, gltype glbase.Enum, normalized bool, value uint32) {
	C.gl4_2compat_glVertexAttribP2ui(gl.funcs, C.GLuint(index), C.GLenum(gltype), *(*C.GLboolean)(unsafe.Pointer(&normalized)), C.GLuint(value))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribP1uiv.xml
func (gl *GL) VertexAttribP1uiv(index glbase.Attrib, gltype glbase.Enum, normalized bool, value []uint32) {
	C.gl4_2compat_glVertexAttribP1uiv(gl.funcs, C.GLuint(index), C.GLenum(gltype), *(*C.GLboolean)(unsafe.Pointer(&normalized)), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribP1ui.xml
func (gl *GL) VertexAttribP1ui(index glbase.Attrib, gltype glbase.Enum, normalized bool, value uint32) {
	C.gl4_2compat_glVertexAttribP1ui(gl.funcs, C.GLuint(index), C.GLenum(gltype), *(*C.GLboolean)(unsafe.Pointer(&normalized)), C.GLuint(value))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSecondaryColorP3uiv.xml
func (gl *GL) SecondaryColorP3uiv(gltype glbase.Enum, color []uint32) {
	C.gl4_2compat_glSecondaryColorP3uiv(gl.funcs, C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&color[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSecondaryColorP3ui.xml
func (gl *GL) SecondaryColorP3ui(gltype glbase.Enum, color uint32) {
	C.gl4_2compat_glSecondaryColorP3ui(gl.funcs, C.GLenum(gltype), C.GLuint(color))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColorP4uiv.xml
func (gl *GL) ColorP4uiv(gltype glbase.Enum, color []uint32) {
	C.gl4_2compat_glColorP4uiv(gl.funcs, C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&color[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColorP4ui.xml
func (gl *GL) ColorP4ui(gltype glbase.Enum, color uint32) {
	C.gl4_2compat_glColorP4ui(gl.funcs, C.GLenum(gltype), C.GLuint(color))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColorP3uiv.xml
func (gl *GL) ColorP3uiv(gltype glbase.Enum, color []uint32) {
	C.gl4_2compat_glColorP3uiv(gl.funcs, C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&color[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColorP3ui.xml
func (gl *GL) ColorP3ui(gltype glbase.Enum, color uint32) {
	C.gl4_2compat_glColorP3ui(gl.funcs, C.GLenum(gltype), C.GLuint(color))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glNormalP3uiv.xml
func (gl *GL) NormalP3uiv(gltype glbase.Enum, coords []uint32) {
	C.gl4_2compat_glNormalP3uiv(gl.funcs, C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&coords[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glNormalP3ui.xml
func (gl *GL) NormalP3ui(gltype glbase.Enum, coords uint32) {
	C.gl4_2compat_glNormalP3ui(gl.funcs, C.GLenum(gltype), C.GLuint(coords))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoordP4uiv.xml
func (gl *GL) MultiTexCoordP4uiv(texture, gltype glbase.Enum, coords []uint32) {
	C.gl4_2compat_glMultiTexCoordP4uiv(gl.funcs, C.GLenum(texture), C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&coords[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoordP4ui.xml
func (gl *GL) MultiTexCoordP4ui(texture, gltype glbase.Enum, coords uint32) {
	C.gl4_2compat_glMultiTexCoordP4ui(gl.funcs, C.GLenum(texture), C.GLenum(gltype), C.GLuint(coords))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoordP3uiv.xml
func (gl *GL) MultiTexCoordP3uiv(texture, gltype glbase.Enum, coords []uint32) {
	C.gl4_2compat_glMultiTexCoordP3uiv(gl.funcs, C.GLenum(texture), C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&coords[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoordP3ui.xml
func (gl *GL) MultiTexCoordP3ui(texture, gltype glbase.Enum, coords uint32) {
	C.gl4_2compat_glMultiTexCoordP3ui(gl.funcs, C.GLenum(texture), C.GLenum(gltype), C.GLuint(coords))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoordP2uiv.xml
func (gl *GL) MultiTexCoordP2uiv(texture, gltype glbase.Enum, coords []uint32) {
	C.gl4_2compat_glMultiTexCoordP2uiv(gl.funcs, C.GLenum(texture), C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&coords[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoordP2ui.xml
func (gl *GL) MultiTexCoordP2ui(texture, gltype glbase.Enum, coords uint32) {
	C.gl4_2compat_glMultiTexCoordP2ui(gl.funcs, C.GLenum(texture), C.GLenum(gltype), C.GLuint(coords))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoordP1uiv.xml
func (gl *GL) MultiTexCoordP1uiv(texture, gltype glbase.Enum, coords []uint32) {
	C.gl4_2compat_glMultiTexCoordP1uiv(gl.funcs, C.GLenum(texture), C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&coords[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoordP1ui.xml
func (gl *GL) MultiTexCoordP1ui(texture, gltype glbase.Enum, coords uint32) {
	C.gl4_2compat_glMultiTexCoordP1ui(gl.funcs, C.GLenum(texture), C.GLenum(gltype), C.GLuint(coords))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoordP4uiv.xml
func (gl *GL) TexCoordP4uiv(gltype glbase.Enum, coords []uint32) {
	C.gl4_2compat_glTexCoordP4uiv(gl.funcs, C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&coords[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoordP4ui.xml
func (gl *GL) TexCoordP4ui(gltype glbase.Enum, coords uint32) {
	C.gl4_2compat_glTexCoordP4ui(gl.funcs, C.GLenum(gltype), C.GLuint(coords))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoordP3uiv.xml
func (gl *GL) TexCoordP3uiv(gltype glbase.Enum, coords []uint32) {
	C.gl4_2compat_glTexCoordP3uiv(gl.funcs, C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&coords[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoordP3ui.xml
func (gl *GL) TexCoordP3ui(gltype glbase.Enum, coords uint32) {
	C.gl4_2compat_glTexCoordP3ui(gl.funcs, C.GLenum(gltype), C.GLuint(coords))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoordP2uiv.xml
func (gl *GL) TexCoordP2uiv(gltype glbase.Enum, coords []uint32) {
	C.gl4_2compat_glTexCoordP2uiv(gl.funcs, C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&coords[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoordP2ui.xml
func (gl *GL) TexCoordP2ui(gltype glbase.Enum, coords uint32) {
	C.gl4_2compat_glTexCoordP2ui(gl.funcs, C.GLenum(gltype), C.GLuint(coords))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoordP1uiv.xml
func (gl *GL) TexCoordP1uiv(gltype glbase.Enum, coords []uint32) {
	C.gl4_2compat_glTexCoordP1uiv(gl.funcs, C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&coords[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoordP1ui.xml
func (gl *GL) TexCoordP1ui(gltype glbase.Enum, coords uint32) {
	C.gl4_2compat_glTexCoordP1ui(gl.funcs, C.GLenum(gltype), C.GLuint(coords))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexP4uiv.xml
func (gl *GL) VertexP4uiv(gltype glbase.Enum, value []uint32) {
	C.gl4_2compat_glVertexP4uiv(gl.funcs, C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexP4ui.xml
func (gl *GL) VertexP4ui(gltype glbase.Enum, value uint32) {
	C.gl4_2compat_glVertexP4ui(gl.funcs, C.GLenum(gltype), C.GLuint(value))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexP3uiv.xml
func (gl *GL) VertexP3uiv(gltype glbase.Enum, value []uint32) {
	C.gl4_2compat_glVertexP3uiv(gl.funcs, C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexP3ui.xml
func (gl *GL) VertexP3ui(gltype glbase.Enum, value uint32) {
	C.gl4_2compat_glVertexP3ui(gl.funcs, C.GLenum(gltype), C.GLuint(value))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexP2uiv.xml
func (gl *GL) VertexP2uiv(gltype glbase.Enum, value []uint32) {
	C.gl4_2compat_glVertexP2uiv(gl.funcs, C.GLenum(gltype), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexP2ui.xml
func (gl *GL) VertexP2ui(gltype glbase.Enum, value uint32) {
	C.gl4_2compat_glVertexP2ui(gl.funcs, C.GLenum(gltype), C.GLuint(value))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetQueryObjectui64v.xml
func (gl *GL) GetQueryObjectui64v(id uint32, pname glbase.Enum, params []uint64) {
	C.gl4_2compat_glGetQueryObjectui64v(gl.funcs, C.GLuint(id), C.GLenum(pname), (*C.GLuint64)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetQueryObjecti64v.xml
func (gl *GL) GetQueryObjecti64v(id uint32, pname glbase.Enum, params []int64) {
	C.gl4_2compat_glGetQueryObjecti64v(gl.funcs, C.GLuint(id), C.GLenum(pname), (*C.GLint64)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glQueryCounter.xml
func (gl *GL) QueryCounter(id uint32, target glbase.Enum) {
	C.gl4_2compat_glQueryCounter(gl.funcs, C.GLuint(id), C.GLenum(target))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetSamplerParameterIuiv.xml
func (gl *GL) GetSamplerParameterIuiv(sampler uint32, pname glbase.Enum, params []uint32) {
	C.gl4_2compat_glGetSamplerParameterIuiv(gl.funcs, C.GLuint(sampler), C.GLenum(pname), (*C.GLuint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetSamplerParameterfv.xml
func (gl *GL) GetSamplerParameterfv(sampler uint32, pname glbase.Enum, params []float32) {
	C.gl4_2compat_glGetSamplerParameterfv(gl.funcs, C.GLuint(sampler), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetSamplerParameterIiv.xml
func (gl *GL) GetSamplerParameterIiv(sampler uint32, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetSamplerParameterIiv(gl.funcs, C.GLuint(sampler), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetSamplerParameteriv.xml
func (gl *GL) GetSamplerParameteriv(sampler uint32, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetSamplerParameteriv(gl.funcs, C.GLuint(sampler), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSamplerParameterIuiv.xml
func (gl *GL) SamplerParameterIuiv(sampler uint32, pname glbase.Enum, param []uint32) {
	C.gl4_2compat_glSamplerParameterIuiv(gl.funcs, C.GLuint(sampler), C.GLenum(pname), (*C.GLuint)(unsafe.Pointer(&param[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSamplerParameterIiv.xml
func (gl *GL) SamplerParameterIiv(sampler uint32, pname glbase.Enum, param []int32) {
	C.gl4_2compat_glSamplerParameterIiv(gl.funcs, C.GLuint(sampler), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&param[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSamplerParameterfv.xml
func (gl *GL) SamplerParameterfv(sampler uint32, pname glbase.Enum, param []float32) {
	C.gl4_2compat_glSamplerParameterfv(gl.funcs, C.GLuint(sampler), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&param[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSamplerParameterf.xml
func (gl *GL) SamplerParameterf(sampler uint32, pname glbase.Enum, param float32) {
	C.gl4_2compat_glSamplerParameterf(gl.funcs, C.GLuint(sampler), C.GLenum(pname), C.GLfloat(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSamplerParameteriv.xml
func (gl *GL) SamplerParameteriv(sampler uint32, pname glbase.Enum, param []int32) {
	C.gl4_2compat_glSamplerParameteriv(gl.funcs, C.GLuint(sampler), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&param[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSamplerParameteri.xml
func (gl *GL) SamplerParameteri(sampler uint32, pname glbase.Enum, param int32) {
	C.gl4_2compat_glSamplerParameteri(gl.funcs, C.GLuint(sampler), C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindSampler.xml
func (gl *GL) BindSampler(unit, sampler uint32) {
	C.gl4_2compat_glBindSampler(gl.funcs, C.GLuint(unit), C.GLuint(sampler))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsSampler.xml
func (gl *GL) IsSampler(sampler uint32) bool {
	result := C.gl4_2compat_glIsSampler(gl.funcs, C.GLuint(sampler))
	return *(*bool)(unsafe.Pointer(&result))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteSamplers.xml
func (gl *GL) DeleteSamplers(count int32, samplers []uint32) {
	C.gl4_2compat_glDeleteSamplers(gl.funcs, C.GLsizei(count), (*C.GLuint)(unsafe.Pointer(&samplers[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGenSamplers.xml
func (gl *GL) GenSamplers(count int32, samplers []uint32) {
	C.gl4_2compat_glGenSamplers(gl.funcs, C.GLsizei(count), (*C.GLuint)(unsafe.Pointer(&samplers[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetFragDataIndex.xml
func (gl *GL) GetFragDataIndex(program glbase.Program, name []byte) int32 {
	result := C.gl4_2compat_glGetFragDataIndex(gl.funcs, C.GLuint(program), (*C.GLchar)(unsafe.Pointer(&name[0])))
	return int32(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindFragDataLocationIndexed.xml
func (gl *GL) BindFragDataLocationIndexed(program glbase.Program, colorNumber, index uint32, name []byte) {
	C.gl4_2compat_glBindFragDataLocationIndexed(gl.funcs, C.GLuint(program), C.GLuint(colorNumber), C.GLuint(index), (*C.GLchar)(unsafe.Pointer(&name[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribDivisor.xml
func (gl *GL) VertexAttribDivisor(index glbase.Attrib, divisor uint32) {
	C.gl4_2compat_glVertexAttribDivisor(gl.funcs, C.GLuint(index), C.GLuint(divisor))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetQueryIndexediv.xml
func (gl *GL) GetQueryIndexediv(target glbase.Enum, index uint32, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetQueryIndexediv(gl.funcs, C.GLenum(target), C.GLuint(index), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEndQueryIndexed.xml
func (gl *GL) EndQueryIndexed(target glbase.Enum, index uint32) {
	C.gl4_2compat_glEndQueryIndexed(gl.funcs, C.GLenum(target), C.GLuint(index))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBeginQueryIndexed.xml
func (gl *GL) BeginQueryIndexed(target glbase.Enum, index, id uint32) {
	C.gl4_2compat_glBeginQueryIndexed(gl.funcs, C.GLenum(target), C.GLuint(index), C.GLuint(id))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawTransformFeedbackStream.xml
func (gl *GL) DrawTransformFeedbackStream(mode glbase.Enum, id, stream uint32) {
	C.gl4_2compat_glDrawTransformFeedbackStream(gl.funcs, C.GLenum(mode), C.GLuint(id), C.GLuint(stream))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawTransformFeedback.xml
func (gl *GL) DrawTransformFeedback(mode glbase.Enum, id uint32) {
	C.gl4_2compat_glDrawTransformFeedback(gl.funcs, C.GLenum(mode), C.GLuint(id))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glResumeTransformFeedback.xml
func (gl *GL) ResumeTransformFeedback() {
	C.gl4_2compat_glResumeTransformFeedback(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPauseTransformFeedback.xml
func (gl *GL) PauseTransformFeedback() {
	C.gl4_2compat_glPauseTransformFeedback(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsTransformFeedback.xml
func (gl *GL) IsTransformFeedback(id uint32) bool {
	result := C.gl4_2compat_glIsTransformFeedback(gl.funcs, C.GLuint(id))
	return *(*bool)(unsafe.Pointer(&result))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGenTransformFeedbacks.xml
func (gl *GL) GenTransformFeedbacks(n int32, ids []uint32) {
	C.gl4_2compat_glGenTransformFeedbacks(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&ids[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteTransformFeedbacks.xml
func (gl *GL) DeleteTransformFeedbacks(n int32, ids []uint32) {
	C.gl4_2compat_glDeleteTransformFeedbacks(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&ids[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindTransformFeedback.xml
func (gl *GL) BindTransformFeedback(target glbase.Enum, id uint32) {
	C.gl4_2compat_glBindTransformFeedback(gl.funcs, C.GLenum(target), C.GLuint(id))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPatchParameterfv.xml
func (gl *GL) PatchParameterfv(pname glbase.Enum, values []float32) {
	C.gl4_2compat_glPatchParameterfv(gl.funcs, C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&values[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPatchParameteri.xml
func (gl *GL) PatchParameteri(pname glbase.Enum, value int32) {
	C.gl4_2compat_glPatchParameteri(gl.funcs, C.GLenum(pname), C.GLint(value))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetProgramStageiv.xml
func (gl *GL) GetProgramStageiv(program glbase.Program, shadertype, pname glbase.Enum, values []int32) {
	C.gl4_2compat_glGetProgramStageiv(gl.funcs, C.GLuint(program), C.GLenum(shadertype), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&values[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetUniformSubroutineuiv.xml
func (gl *GL) GetUniformSubroutineuiv(shadertype glbase.Enum, location glbase.Uniform, params []uint32) {
	C.gl4_2compat_glGetUniformSubroutineuiv(gl.funcs, C.GLenum(shadertype), C.GLint(location), (*C.GLuint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetActiveSubroutineName.xml
func (gl *GL) GetActiveSubroutineName(program glbase.Program, shadertype glbase.Enum, index uint32, bufsize int32, length []int32, name []byte) {
	C.gl4_2compat_glGetActiveSubroutineName(gl.funcs, C.GLuint(program), C.GLenum(shadertype), C.GLuint(index), C.GLsizei(bufsize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLchar)(unsafe.Pointer(&name[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetActiveSubroutineUniformName.xml
func (gl *GL) GetActiveSubroutineUniformName(program glbase.Program, shadertype glbase.Enum, index uint32, bufsize int32, length []int32, name []byte) {
	C.gl4_2compat_glGetActiveSubroutineUniformName(gl.funcs, C.GLuint(program), C.GLenum(shadertype), C.GLuint(index), C.GLsizei(bufsize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLchar)(unsafe.Pointer(&name[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetActiveSubroutineUniformiv.xml
func (gl *GL) GetActiveSubroutineUniformiv(program glbase.Program, shadertype glbase.Enum, index uint32, pname glbase.Enum, values []int32) {
	C.gl4_2compat_glGetActiveSubroutineUniformiv(gl.funcs, C.GLuint(program), C.GLenum(shadertype), C.GLuint(index), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&values[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetSubroutineIndex.xml
func (gl *GL) GetSubroutineIndex(program glbase.Program, shadertype glbase.Enum, name []byte) uint32 {
	result := C.gl4_2compat_glGetSubroutineIndex(gl.funcs, C.GLuint(program), C.GLenum(shadertype), (*C.GLchar)(unsafe.Pointer(&name[0])))
	return uint32(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetSubroutineUniformLocation.xml
func (gl *GL) GetSubroutineUniformLocation(program glbase.Program, shadertype glbase.Enum, name []byte) int32 {
	result := C.gl4_2compat_glGetSubroutineUniformLocation(gl.funcs, C.GLuint(program), C.GLenum(shadertype), (*C.GLchar)(unsafe.Pointer(&name[0])))
	return int32(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetUniformdv.xml
func (gl *GL) GetUniformdv(program glbase.Program, location glbase.Uniform, params []float64) {
	C.gl4_2compat_glGetUniformdv(gl.funcs, C.GLuint(program), C.GLint(location), (*C.GLdouble)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform4d.xml
func (gl *GL) Uniform4d(location glbase.Uniform, x, y, z, w float64) {
	C.gl4_2compat_glUniform4d(gl.funcs, C.GLint(location), C.GLdouble(x), C.GLdouble(y), C.GLdouble(z), C.GLdouble(w))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform3d.xml
func (gl *GL) Uniform3d(location glbase.Uniform, x, y, z float64) {
	C.gl4_2compat_glUniform3d(gl.funcs, C.GLint(location), C.GLdouble(x), C.GLdouble(y), C.GLdouble(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform2d.xml
func (gl *GL) Uniform2d(location glbase.Uniform, x, y float64) {
	C.gl4_2compat_glUniform2d(gl.funcs, C.GLint(location), C.GLdouble(x), C.GLdouble(y))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform1d.xml
func (gl *GL) Uniform1d(location glbase.Uniform, x float64) {
	C.gl4_2compat_glUniform1d(gl.funcs, C.GLint(location), C.GLdouble(x))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawElementsIndirect.xml
func (gl *GL) DrawElementsIndirect(mode, gltype glbase.Enum, indirect interface{}) {
	indirect_v := reflect.ValueOf(indirect)
	if indirect_v.Kind() != reflect.Slice {
		panic("parameter indirect must be a slice")
	}
	C.gl4_2compat_glDrawElementsIndirect(gl.funcs, C.GLenum(mode), C.GLenum(gltype), unsafe.Pointer(indirect_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawArraysIndirect.xml
func (gl *GL) DrawArraysIndirect(mode glbase.Enum, indirect interface{}) {
	indirect_v := reflect.ValueOf(indirect)
	if indirect_v.Kind() != reflect.Slice {
		panic("parameter indirect must be a slice")
	}
	C.gl4_2compat_glDrawArraysIndirect(gl.funcs, C.GLenum(mode), unsafe.Pointer(indirect_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBlendFuncSeparatei.xml
func (gl *GL) BlendFuncSeparatei(buf uint32, srcRGB, dstRGB, srcAlpha, dstAlpha glbase.Enum) {
	C.gl4_2compat_glBlendFuncSeparatei(gl.funcs, C.GLuint(buf), C.GLenum(srcRGB), C.GLenum(dstRGB), C.GLenum(srcAlpha), C.GLenum(dstAlpha))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBlendFunci.xml
func (gl *GL) BlendFunci(buf uint32, src, dst glbase.Enum) {
	C.gl4_2compat_glBlendFunci(gl.funcs, C.GLuint(buf), C.GLenum(src), C.GLenum(dst))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBlendEquationSeparatei.xml
func (gl *GL) BlendEquationSeparatei(buf uint32, modeRGB, modeAlpha glbase.Enum) {
	C.gl4_2compat_glBlendEquationSeparatei(gl.funcs, C.GLuint(buf), C.GLenum(modeRGB), C.GLenum(modeAlpha))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBlendEquationi.xml
func (gl *GL) BlendEquationi(buf uint32, mode glbase.Enum) {
	C.gl4_2compat_glBlendEquationi(gl.funcs, C.GLuint(buf), C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMinSampleShading.xml
func (gl *GL) MinSampleShading(value float32) {
	C.gl4_2compat_glMinSampleShading(gl.funcs, C.GLfloat(value))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetDoublei_v.xml
func (gl *GL) GetDoublei_v(target glbase.Enum, index uint32, data []float64) {
	C.gl4_2compat_glGetDoublei_v(gl.funcs, C.GLenum(target), C.GLuint(index), (*C.GLdouble)(unsafe.Pointer(&data[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetFloati_v.xml
func (gl *GL) GetFloati_v(target glbase.Enum, index uint32, data []float32) {
	C.gl4_2compat_glGetFloati_v(gl.funcs, C.GLenum(target), C.GLuint(index), (*C.GLfloat)(unsafe.Pointer(&data[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDepthRangeIndexed.xml
func (gl *GL) DepthRangeIndexed(index uint32, n, f float64) {
	C.gl4_2compat_glDepthRangeIndexed(gl.funcs, C.GLuint(index), C.GLdouble(n), C.GLdouble(f))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDepthRangeArrayv.xml
func (gl *GL) DepthRangeArrayv(first uint32, count int32, v []float64) {
	C.gl4_2compat_glDepthRangeArrayv(gl.funcs, C.GLuint(first), C.GLsizei(count), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glScissorIndexedv.xml
func (gl *GL) ScissorIndexedv(index uint32, v []int32) {
	C.gl4_2compat_glScissorIndexedv(gl.funcs, C.GLuint(index), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glScissorIndexed.xml
func (gl *GL) ScissorIndexed(index uint32, left, bottom, width, height int32) {
	C.gl4_2compat_glScissorIndexed(gl.funcs, C.GLuint(index), C.GLint(left), C.GLint(bottom), C.GLsizei(width), C.GLsizei(height))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glScissorArrayv.xml
func (gl *GL) ScissorArrayv(first uint32, count int32, v []int32) {
	C.gl4_2compat_glScissorArrayv(gl.funcs, C.GLuint(first), C.GLsizei(count), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glViewportIndexedfv.xml
func (gl *GL) ViewportIndexedfv(index uint32, v []float32) {
	C.gl4_2compat_glViewportIndexedfv(gl.funcs, C.GLuint(index), (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glViewportIndexedf.xml
func (gl *GL) ViewportIndexedf(index uint32, x, y, w, h float32) {
	C.gl4_2compat_glViewportIndexedf(gl.funcs, C.GLuint(index), C.GLfloat(x), C.GLfloat(y), C.GLfloat(w), C.GLfloat(h))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glViewportArrayv.xml
func (gl *GL) ViewportArrayv(first uint32, count int32, v []float32) {
	C.gl4_2compat_glViewportArrayv(gl.funcs, C.GLuint(first), C.GLsizei(count), (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetVertexAttribLdv.xml
func (gl *GL) GetVertexAttribLdv(index glbase.Attrib, pname glbase.Enum, params []float64) {
	C.gl4_2compat_glGetVertexAttribLdv(gl.funcs, C.GLuint(index), C.GLenum(pname), (*C.GLdouble)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribLPointer.xml
func (gl *GL) VertexAttribLPointer(index glbase.Attrib, size int32, gltype glbase.Enum, stride int32, pointer interface{}) {
	pointer_v := reflect.ValueOf(pointer)
	if pointer_v.Kind() != reflect.Slice {
		panic("parameter pointer must be a slice")
	}
	C.gl4_2compat_glVertexAttribLPointer(gl.funcs, C.GLuint(index), C.GLint(size), C.GLenum(gltype), C.GLsizei(stride), unsafe.Pointer(pointer_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribL4dv.xml
func (gl *GL) VertexAttribL4dv(index glbase.Attrib, v []float64) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertexAttribL4dv(gl.funcs, C.GLuint(index), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribL3dv.xml
func (gl *GL) VertexAttribL3dv(index glbase.Attrib, v []float64) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertexAttribL3dv(gl.funcs, C.GLuint(index), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribL2dv.xml
func (gl *GL) VertexAttribL2dv(index glbase.Attrib, v []float64) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertexAttribL2dv(gl.funcs, C.GLuint(index), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribL1dv.xml
func (gl *GL) VertexAttribL1dv(index glbase.Attrib, v []float64) {
	C.gl4_2compat_glVertexAttribL1dv(gl.funcs, C.GLuint(index), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribL4d.xml
func (gl *GL) VertexAttribL4d(index glbase.Attrib, x, y, z, w float64) {
	C.gl4_2compat_glVertexAttribL4d(gl.funcs, C.GLuint(index), C.GLdouble(x), C.GLdouble(y), C.GLdouble(z), C.GLdouble(w))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribL3d.xml
func (gl *GL) VertexAttribL3d(index glbase.Attrib, x, y, z float64) {
	C.gl4_2compat_glVertexAttribL3d(gl.funcs, C.GLuint(index), C.GLdouble(x), C.GLdouble(y), C.GLdouble(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribL2d.xml
func (gl *GL) VertexAttribL2d(index glbase.Attrib, x, y float64) {
	C.gl4_2compat_glVertexAttribL2d(gl.funcs, C.GLuint(index), C.GLdouble(x), C.GLdouble(y))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribL1d.xml
func (gl *GL) VertexAttribL1d(index glbase.Attrib, x float64) {
	C.gl4_2compat_glVertexAttribL1d(gl.funcs, C.GLuint(index), C.GLdouble(x))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetProgramPipelineInfoLog.xml
func (gl *GL) GetProgramPipelineInfoLog(pipeline uint32, bufSize int32, length []int32, infoLog []byte) {
	C.gl4_2compat_glGetProgramPipelineInfoLog(gl.funcs, C.GLuint(pipeline), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLchar)(unsafe.Pointer(&infoLog[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glValidateProgramPipeline.xml
func (gl *GL) ValidateProgramPipeline(pipeline uint32) {
	C.gl4_2compat_glValidateProgramPipeline(gl.funcs, C.GLuint(pipeline))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix4x3dv.xml
func (gl *GL) ProgramUniformMatrix4x3dv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float64) {
	if len(value) != 3 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniformMatrix4x3dv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLdouble)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix3x4dv.xml
func (gl *GL) ProgramUniformMatrix3x4dv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float64) {
	if len(value) != 4 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniformMatrix3x4dv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLdouble)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix4x2dv.xml
func (gl *GL) ProgramUniformMatrix4x2dv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float64) {
	if len(value) != 2 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniformMatrix4x2dv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLdouble)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix2x4dv.xml
func (gl *GL) ProgramUniformMatrix2x4dv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float64) {
	if len(value) != 4 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniformMatrix2x4dv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLdouble)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix3x2dv.xml
func (gl *GL) ProgramUniformMatrix3x2dv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float64) {
	if len(value) != 2 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniformMatrix3x2dv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLdouble)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix2x3dv.xml
func (gl *GL) ProgramUniformMatrix2x3dv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float64) {
	if len(value) != 3 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniformMatrix2x3dv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLdouble)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix4x3fv.xml
func (gl *GL) ProgramUniformMatrix4x3fv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float32) {
	if len(value) != 3 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniformMatrix4x3fv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix3x4fv.xml
func (gl *GL) ProgramUniformMatrix3x4fv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float32) {
	if len(value) != 4 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniformMatrix3x4fv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix4x2fv.xml
func (gl *GL) ProgramUniformMatrix4x2fv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float32) {
	if len(value) != 2 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniformMatrix4x2fv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix2x4fv.xml
func (gl *GL) ProgramUniformMatrix2x4fv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float32) {
	if len(value) != 4 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniformMatrix2x4fv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix3x2fv.xml
func (gl *GL) ProgramUniformMatrix3x2fv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float32) {
	if len(value) != 2 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniformMatrix3x2fv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix2x3fv.xml
func (gl *GL) ProgramUniformMatrix2x3fv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float32) {
	if len(value) != 3 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniformMatrix2x3fv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix4dv.xml
func (gl *GL) ProgramUniformMatrix4dv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float64) {
	if len(value) != 4 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniformMatrix4dv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLdouble)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix3dv.xml
func (gl *GL) ProgramUniformMatrix3dv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float64) {
	if len(value) != 3 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniformMatrix3dv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLdouble)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix2dv.xml
func (gl *GL) ProgramUniformMatrix2dv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float64) {
	if len(value) != 2 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniformMatrix2dv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLdouble)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix4fv.xml
func (gl *GL) ProgramUniformMatrix4fv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float32) {
	if len(value) != 4 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniformMatrix4fv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix3fv.xml
func (gl *GL) ProgramUniformMatrix3fv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float32) {
	if len(value) != 3 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniformMatrix3fv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniformMatrix2fv.xml
func (gl *GL) ProgramUniformMatrix2fv(program glbase.Program, location glbase.Uniform, count int32, transpose bool, value []float32) {
	if len(value) != 2 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniformMatrix2fv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), *(*C.GLboolean)(unsafe.Pointer(&transpose)), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform4uiv.xml
func (gl *GL) ProgramUniform4uiv(program glbase.Program, location glbase.Uniform, count int32, value []uint32) {
	C.gl4_2compat_glProgramUniform4uiv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform4ui.xml
func (gl *GL) ProgramUniform4ui(program glbase.Program, location glbase.Uniform, v0, v1, v2, v3 uint32) {
	C.gl4_2compat_glProgramUniform4ui(gl.funcs, C.GLuint(program), C.GLint(location), C.GLuint(v0), C.GLuint(v1), C.GLuint(v2), C.GLuint(v3))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform4dv.xml
func (gl *GL) ProgramUniform4dv(program glbase.Program, location glbase.Uniform, count int32, value []float64) {
	if len(value) != 4 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniform4dv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLdouble)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform4d.xml
func (gl *GL) ProgramUniform4d(program glbase.Program, location glbase.Uniform, v0, v1, v2, v3 float64) {
	C.gl4_2compat_glProgramUniform4d(gl.funcs, C.GLuint(program), C.GLint(location), C.GLdouble(v0), C.GLdouble(v1), C.GLdouble(v2), C.GLdouble(v3))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform4fv.xml
func (gl *GL) ProgramUniform4fv(program glbase.Program, location glbase.Uniform, count int32, value []float32) {
	if len(value) != 4 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniform4fv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform4f.xml
func (gl *GL) ProgramUniform4f(program glbase.Program, location glbase.Uniform, v0, v1, v2, v3 float32) {
	C.gl4_2compat_glProgramUniform4f(gl.funcs, C.GLuint(program), C.GLint(location), C.GLfloat(v0), C.GLfloat(v1), C.GLfloat(v2), C.GLfloat(v3))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform4iv.xml
func (gl *GL) ProgramUniform4iv(program glbase.Program, location glbase.Uniform, count int32, value []int32) {
	if len(value) != 4 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniform4iv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform4i.xml
func (gl *GL) ProgramUniform4i(program glbase.Program, location glbase.Uniform, v0, v1, v2, v3 int32) {
	C.gl4_2compat_glProgramUniform4i(gl.funcs, C.GLuint(program), C.GLint(location), C.GLint(v0), C.GLint(v1), C.GLint(v2), C.GLint(v3))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform3uiv.xml
func (gl *GL) ProgramUniform3uiv(program glbase.Program, location glbase.Uniform, count int32, value []uint32) {
	C.gl4_2compat_glProgramUniform3uiv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform3ui.xml
func (gl *GL) ProgramUniform3ui(program glbase.Program, location glbase.Uniform, v0, v1, v2 uint32) {
	C.gl4_2compat_glProgramUniform3ui(gl.funcs, C.GLuint(program), C.GLint(location), C.GLuint(v0), C.GLuint(v1), C.GLuint(v2))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform3dv.xml
func (gl *GL) ProgramUniform3dv(program glbase.Program, location glbase.Uniform, count int32, value []float64) {
	if len(value) != 3 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniform3dv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLdouble)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform3d.xml
func (gl *GL) ProgramUniform3d(program glbase.Program, location glbase.Uniform, v0, v1, v2 float64) {
	C.gl4_2compat_glProgramUniform3d(gl.funcs, C.GLuint(program), C.GLint(location), C.GLdouble(v0), C.GLdouble(v1), C.GLdouble(v2))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform3fv.xml
func (gl *GL) ProgramUniform3fv(program glbase.Program, location glbase.Uniform, count int32, value []float32) {
	if len(value) != 3 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniform3fv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform3f.xml
func (gl *GL) ProgramUniform3f(program glbase.Program, location glbase.Uniform, v0, v1, v2 float32) {
	C.gl4_2compat_glProgramUniform3f(gl.funcs, C.GLuint(program), C.GLint(location), C.GLfloat(v0), C.GLfloat(v1), C.GLfloat(v2))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform3iv.xml
func (gl *GL) ProgramUniform3iv(program glbase.Program, location glbase.Uniform, count int32, value []int32) {
	if len(value) != 3 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniform3iv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform3i.xml
func (gl *GL) ProgramUniform3i(program glbase.Program, location glbase.Uniform, v0, v1, v2 int32) {
	C.gl4_2compat_glProgramUniform3i(gl.funcs, C.GLuint(program), C.GLint(location), C.GLint(v0), C.GLint(v1), C.GLint(v2))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform2uiv.xml
func (gl *GL) ProgramUniform2uiv(program glbase.Program, location glbase.Uniform, count int32, value []uint32) {
	C.gl4_2compat_glProgramUniform2uiv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform2ui.xml
func (gl *GL) ProgramUniform2ui(program glbase.Program, location glbase.Uniform, v0, v1 uint32) {
	C.gl4_2compat_glProgramUniform2ui(gl.funcs, C.GLuint(program), C.GLint(location), C.GLuint(v0), C.GLuint(v1))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform2dv.xml
func (gl *GL) ProgramUniform2dv(program glbase.Program, location glbase.Uniform, count int32, value []float64) {
	if len(value) != 2 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniform2dv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLdouble)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform2d.xml
func (gl *GL) ProgramUniform2d(program glbase.Program, location glbase.Uniform, v0, v1 float64) {
	C.gl4_2compat_glProgramUniform2d(gl.funcs, C.GLuint(program), C.GLint(location), C.GLdouble(v0), C.GLdouble(v1))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform2fv.xml
func (gl *GL) ProgramUniform2fv(program glbase.Program, location glbase.Uniform, count int32, value []float32) {
	if len(value) != 2 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniform2fv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform2f.xml
func (gl *GL) ProgramUniform2f(program glbase.Program, location glbase.Uniform, v0, v1 float32) {
	C.gl4_2compat_glProgramUniform2f(gl.funcs, C.GLuint(program), C.GLint(location), C.GLfloat(v0), C.GLfloat(v1))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform2iv.xml
func (gl *GL) ProgramUniform2iv(program glbase.Program, location glbase.Uniform, count int32, value []int32) {
	if len(value) != 2 {
		panic("parameter value has incorrect length")
	}
	C.gl4_2compat_glProgramUniform2iv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform2i.xml
func (gl *GL) ProgramUniform2i(program glbase.Program, location glbase.Uniform, v0, v1 int32) {
	C.gl4_2compat_glProgramUniform2i(gl.funcs, C.GLuint(program), C.GLint(location), C.GLint(v0), C.GLint(v1))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform1uiv.xml
func (gl *GL) ProgramUniform1uiv(program glbase.Program, location glbase.Uniform, count int32, value []uint32) {
	C.gl4_2compat_glProgramUniform1uiv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLuint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform1ui.xml
func (gl *GL) ProgramUniform1ui(program glbase.Program, location glbase.Uniform, v0 uint32) {
	C.gl4_2compat_glProgramUniform1ui(gl.funcs, C.GLuint(program), C.GLint(location), C.GLuint(v0))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform1dv.xml
func (gl *GL) ProgramUniform1dv(program glbase.Program, location glbase.Uniform, count int32, value []float64) {
	C.gl4_2compat_glProgramUniform1dv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLdouble)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform1d.xml
func (gl *GL) ProgramUniform1d(program glbase.Program, location glbase.Uniform, v0 float64) {
	C.gl4_2compat_glProgramUniform1d(gl.funcs, C.GLuint(program), C.GLint(location), C.GLdouble(v0))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform1fv.xml
func (gl *GL) ProgramUniform1fv(program glbase.Program, location glbase.Uniform, count int32, value []float32) {
	C.gl4_2compat_glProgramUniform1fv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform1f.xml
func (gl *GL) ProgramUniform1f(program glbase.Program, location glbase.Uniform, v0 float32) {
	C.gl4_2compat_glProgramUniform1f(gl.funcs, C.GLuint(program), C.GLint(location), C.GLfloat(v0))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform1iv.xml
func (gl *GL) ProgramUniform1iv(program glbase.Program, location glbase.Uniform, count int32, value []int32) {
	C.gl4_2compat_glProgramUniform1iv(gl.funcs, C.GLuint(program), C.GLint(location), C.GLsizei(count), (*C.GLint)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramUniform1i.xml
func (gl *GL) ProgramUniform1i(program glbase.Program, location glbase.Uniform, v0 int32) {
	C.gl4_2compat_glProgramUniform1i(gl.funcs, C.GLuint(program), C.GLint(location), C.GLint(v0))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetProgramPipelineiv.xml
func (gl *GL) GetProgramPipelineiv(pipeline uint32, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetProgramPipelineiv(gl.funcs, C.GLuint(pipeline), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsProgramPipeline.xml
func (gl *GL) IsProgramPipeline(pipeline uint32) bool {
	result := C.gl4_2compat_glIsProgramPipeline(gl.funcs, C.GLuint(pipeline))
	return *(*bool)(unsafe.Pointer(&result))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGenProgramPipelines.xml
func (gl *GL) GenProgramPipelines(n int32, pipelines []uint32) {
	C.gl4_2compat_glGenProgramPipelines(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&pipelines[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteProgramPipelines.xml
func (gl *GL) DeleteProgramPipelines(n int32, pipelines []uint32) {
	C.gl4_2compat_glDeleteProgramPipelines(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&pipelines[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindProgramPipeline.xml
func (gl *GL) BindProgramPipeline(pipeline uint32) {
	C.gl4_2compat_glBindProgramPipeline(gl.funcs, C.GLuint(pipeline))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glActiveShaderProgram.xml
func (gl *GL) ActiveShaderProgram(pipeline uint32, program glbase.Program) {
	C.gl4_2compat_glActiveShaderProgram(gl.funcs, C.GLuint(pipeline), C.GLuint(program))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUseProgramStages.xml
func (gl *GL) UseProgramStages(pipeline uint32, stages glbase.Bitfield, program glbase.Program) {
	C.gl4_2compat_glUseProgramStages(gl.funcs, C.GLuint(pipeline), C.GLbitfield(stages), C.GLuint(program))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramParameteri.xml
func (gl *GL) ProgramParameteri(program glbase.Program, pname glbase.Enum, value int32) {
	C.gl4_2compat_glProgramParameteri(gl.funcs, C.GLuint(program), C.GLenum(pname), C.GLint(value))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glProgramBinary.xml
func (gl *GL) ProgramBinary(program glbase.Program, binaryFormat glbase.Enum, binary interface{}, length int32) {
	binary_v := reflect.ValueOf(binary)
	if binary_v.Kind() != reflect.Slice {
		panic("parameter binary must be a slice")
	}
	C.gl4_2compat_glProgramBinary(gl.funcs, C.GLuint(program), C.GLenum(binaryFormat), unsafe.Pointer(binary_v.Index(0).Addr().Pointer()), C.GLsizei(length))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetProgramBinary.xml
func (gl *GL) GetProgramBinary(program glbase.Program, bufSize int32, length []int32, binaryFormat []glbase.Enum, binary interface{}) {
	binary_v := reflect.ValueOf(binary)
	if binary_v.Kind() != reflect.Slice {
		panic("parameter binary must be a slice")
	}
	C.gl4_2compat_glGetProgramBinary(gl.funcs, C.GLuint(program), C.GLsizei(bufSize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLenum)(unsafe.Pointer(&binaryFormat[0])), unsafe.Pointer(binary_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClearDepthf.xml
func (gl *GL) ClearDepthf(dd float32) {
	C.gl4_2compat_glClearDepthf(gl.funcs, C.GLfloat(dd))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDepthRangef.xml
func (gl *GL) DepthRangef(n, f float32) {
	C.gl4_2compat_glDepthRangef(gl.funcs, C.GLfloat(n), C.GLfloat(f))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetShaderPrecisionFormat.xml
func (gl *GL) GetShaderPrecisionFormat(shadertype, precisiontype glbase.Enum, range_, precision []int32) {
	C.gl4_2compat_glGetShaderPrecisionFormat(gl.funcs, C.GLenum(shadertype), C.GLenum(precisiontype), (*C.GLint)(unsafe.Pointer(&range_[0])), (*C.GLint)(unsafe.Pointer(&precision[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glShaderBinary.xml
func (gl *GL) ShaderBinary(count int32, shaders []uint32, binaryformat glbase.Enum, binary interface{}, length int32) {
	binary_v := reflect.ValueOf(binary)
	if binary_v.Kind() != reflect.Slice {
		panic("parameter binary must be a slice")
	}
	C.gl4_2compat_glShaderBinary(gl.funcs, C.GLsizei(count), (*C.GLuint)(unsafe.Pointer(&shaders[0])), C.GLenum(binaryformat), unsafe.Pointer(binary_v.Index(0).Addr().Pointer()), C.GLsizei(length))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glReleaseShaderCompiler.xml
func (gl *GL) ReleaseShaderCompiler() {
	C.gl4_2compat_glReleaseShaderCompiler(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexStorage3D.xml
func (gl *GL) TexStorage3D(target glbase.Enum, levels int32, internalformat glbase.Enum, width, height, depth int32) {
	C.gl4_2compat_glTexStorage3D(gl.funcs, C.GLenum(target), C.GLsizei(levels), C.GLenum(internalformat), C.GLsizei(width), C.GLsizei(height), C.GLsizei(depth))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexStorage2D.xml
func (gl *GL) TexStorage2D(target glbase.Enum, levels int32, internalformat glbase.Enum, width, height int32) {
	C.gl4_2compat_glTexStorage2D(gl.funcs, C.GLenum(target), C.GLsizei(levels), C.GLenum(internalformat), C.GLsizei(width), C.GLsizei(height))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexStorage1D.xml
func (gl *GL) TexStorage1D(target glbase.Enum, levels int32, internalformat glbase.Enum, width int32) {
	C.gl4_2compat_glTexStorage1D(gl.funcs, C.GLenum(target), C.GLsizei(levels), C.GLenum(internalformat), C.GLsizei(width))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMemoryBarrier.xml
func (gl *GL) MemoryBarrier(barriers glbase.Bitfield) {
	C.gl4_2compat_glMemoryBarrier(gl.funcs, C.GLbitfield(barriers))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindImageTexture.xml
func (gl *GL) BindImageTexture(unit uint32, texture glbase.Texture, level int32, layered bool, layer int32, access, format glbase.Enum) {
	C.gl4_2compat_glBindImageTexture(gl.funcs, C.GLuint(unit), C.GLuint(texture), C.GLint(level), *(*C.GLboolean)(unsafe.Pointer(&layered)), C.GLint(layer), C.GLenum(access), C.GLenum(format))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetActiveAtomicCounterBufferiv.xml
func (gl *GL) GetActiveAtomicCounterBufferiv(program glbase.Program, bufferIndex uint32, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetActiveAtomicCounterBufferiv(gl.funcs, C.GLuint(program), C.GLuint(bufferIndex), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetInternalformativ.xml
func (gl *GL) GetInternalformativ(target, internalformat, pname glbase.Enum, bufSize int32, params []int32) {
	C.gl4_2compat_glGetInternalformativ(gl.funcs, C.GLenum(target), C.GLenum(internalformat), C.GLenum(pname), C.GLsizei(bufSize), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawTransformFeedbackStreamInstanced.xml
func (gl *GL) DrawTransformFeedbackStreamInstanced(mode glbase.Enum, id, stream uint32, instancecount int32) {
	C.gl4_2compat_glDrawTransformFeedbackStreamInstanced(gl.funcs, C.GLenum(mode), C.GLuint(id), C.GLuint(stream), C.GLsizei(instancecount))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawTransformFeedbackInstanced.xml
func (gl *GL) DrawTransformFeedbackInstanced(mode glbase.Enum, id uint32, instancecount int32) {
	C.gl4_2compat_glDrawTransformFeedbackInstanced(gl.funcs, C.GLenum(mode), C.GLuint(id), C.GLsizei(instancecount))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawElementsInstancedBaseVertexBaseInstance.xml
func (gl *GL) DrawElementsInstancedBaseVertexBaseInstance(mode glbase.Enum, count int32, gltype glbase.Enum, indices interface{}, instancecount, basevertex int32, baseinstance uint32) {
	indices_v := reflect.ValueOf(indices)
	if indices_v.Kind() != reflect.Slice {
		panic("parameter indices must be a slice")
	}
	C.gl4_2compat_glDrawElementsInstancedBaseVertexBaseInstance(gl.funcs, C.GLenum(mode), C.GLsizei(count), C.GLenum(gltype), unsafe.Pointer(indices_v.Index(0).Addr().Pointer()), C.GLsizei(instancecount), C.GLint(basevertex), C.GLuint(baseinstance))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawElementsInstancedBaseInstance.xml
func (gl *GL) DrawElementsInstancedBaseInstance(mode glbase.Enum, count int32, gltype glbase.Enum, indices interface{}, instancecount int32, baseinstance uint32) {
	indices_v := reflect.ValueOf(indices)
	if indices_v.Kind() != reflect.Slice {
		panic("parameter indices must be a slice")
	}
	C.gl4_2compat_glDrawElementsInstancedBaseInstance(gl.funcs, C.GLenum(mode), C.GLsizei(count), C.GLenum(gltype), unsafe.Pointer(indices_v.Index(0).Addr().Pointer()), C.GLsizei(instancecount), C.GLuint(baseinstance))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawArraysInstancedBaseInstance.xml
func (gl *GL) DrawArraysInstancedBaseInstance(mode glbase.Enum, first, count, instancecount int32, baseinstance uint32) {
	C.gl4_2compat_glDrawArraysInstancedBaseInstance(gl.funcs, C.GLenum(mode), C.GLint(first), C.GLsizei(count), C.GLsizei(instancecount), C.GLuint(baseinstance))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTranslatef.xml
func (gl *GL) Translatef(x, y, z float32) {
	C.gl4_2compat_glTranslatef(gl.funcs, C.GLfloat(x), C.GLfloat(y), C.GLfloat(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTranslated.xml
func (gl *GL) Translated(x, y, z float64) {
	C.gl4_2compat_glTranslated(gl.funcs, C.GLdouble(x), C.GLdouble(y), C.GLdouble(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glScalef.xml
func (gl *GL) Scalef(x, y, z float32) {
	C.gl4_2compat_glScalef(gl.funcs, C.GLfloat(x), C.GLfloat(y), C.GLfloat(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glScaled.xml
func (gl *GL) Scaled(x, y, z float64) {
	C.gl4_2compat_glScaled(gl.funcs, C.GLdouble(x), C.GLdouble(y), C.GLdouble(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRotatef.xml
func (gl *GL) Rotatef(angle, x, y, z float32) {
	C.gl4_2compat_glRotatef(gl.funcs, C.GLfloat(angle), C.GLfloat(x), C.GLfloat(y), C.GLfloat(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRotated.xml
func (gl *GL) Rotated(angle, x, y, z float64) {
	C.gl4_2compat_glRotated(gl.funcs, C.GLdouble(angle), C.GLdouble(x), C.GLdouble(y), C.GLdouble(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPushMatrix.xml
func (gl *GL) PushMatrix() {
	C.gl4_2compat_glPushMatrix(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPopMatrix.xml
func (gl *GL) PopMatrix() {
	C.gl4_2compat_glPopMatrix(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glOrtho.xml
func (gl *GL) Ortho(left, right, bottom, top, zNear, zFar float64) {
	C.gl4_2compat_glOrtho(gl.funcs, C.GLdouble(left), C.GLdouble(right), C.GLdouble(bottom), C.GLdouble(top), C.GLdouble(zNear), C.GLdouble(zFar))
}

// MultMatrixd multiplies the current matrix with the provided matrix.
//
// The m parameter must hold 16 consecutive elements of a 4x4 column-major matrix.
//
// The current matrix is determined by the current matrix mode (see
// MatrixMode). It is either the projection matrix, modelview matrix, or the
// texture matrix.
//
// For example, if the current matrix is C and the coordinates to be transformed
// are v = (v[0], v[1], v[2], v[3]), then the current transformation is C × v, or
//
//     c[0]  c[4]  c[8]  c[12]     v[0]
//     c[1]  c[5]  c[9]  c[13]     v[1]
//     c[2]  c[6]  c[10] c[14]  X  v[2]
//     c[3]  c[7]  c[11] c[15]     v[3]
//
// Calling glMultMatrix with an argument of m = m[0], m[1], ..., m[15]
// replaces the current transformation with (C X M) x v, or
//
//     c[0]  c[4]  c[8]  c[12]   m[0]  m[4]  m[8]  m[12]   v[0]
//     c[1]  c[5]  c[9]  c[13]   m[1]  m[5]  m[9]  m[13]   v[1]
//     c[2]  c[6]  c[10] c[14] X m[2]  m[6]  m[10] m[14] X v[2]
//     c[3]  c[7]  c[11] c[15]   m[3]  m[7]  m[11] m[15]   v[3]
//
// Where 'X' denotes matrix multiplication, and v is represented as a 4x1 matrix.
//
// While the elements of the matrix may be specified with single or double
// precision, the GL may store or operate on these values in less-than-single
// precision.
//
// In many computer languages, 4×4 arrays are represented in row-major
// order. The transformations just described represent these matrices in
// column-major order. The order of the multiplication is important. For
// example, if the current transformation is a rotation, and MultMatrix is
// called with a translation matrix, the translation is done directly on the
// coordinates to be transformed, while the rotation is done on the results
// of that translation.
//
// GL.INVALID_OPERATION is generated if MultMatrix is executed between the
// execution of Begin and the corresponding execution of End.
//
// See also LoadIdentity, LoadMatrix, LoadTransposeMatrix, MatrixMode,
// MultTransposeMatrix, PushMatrix.
//
// https://www.opengl.org/sdk/docs/man2/xhtml/glMultMatrixd.xml
func (gl *GL) MultMatrixd(m []float64) {
	if len(m) != 16 {
		panic("parameter m must have length 16 for the 4x4 matrix")
	}
	C.gl4_2compat_glMultMatrixd(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&m[0])))
}

// MultMatrixf multiplies the current matrix with the provided matrix.
//
// The m parameter must hold 16 consecutive elements of a 4x4 column-major matrix.
//
// The current matrix is determined by the current matrix mode (see
// MatrixMode). It is either the projection matrix, modelview matrix, or the
// texture matrix.
//
// For example, if the current matrix is C and the coordinates to be transformed
// are v = (v[0], v[1], v[2], v[3]), then the current transformation is C × v, or
//
//     c[0]  c[4]  c[8]  c[12]     v[0]
//     c[1]  c[5]  c[9]  c[13]     v[1]
//     c[2]  c[6]  c[10] c[14]  X  v[2]
//     c[3]  c[7]  c[11] c[15]     v[3]
//
// Calling glMultMatrix with an argument of m = m[0], m[1], ..., m[15]
// replaces the current transformation with (C X M) x v, or
//
//     c[0]  c[4]  c[8]  c[12]   m[0]  m[4]  m[8]  m[12]   v[0]
//     c[1]  c[5]  c[9]  c[13]   m[1]  m[5]  m[9]  m[13]   v[1]
//     c[2]  c[6]  c[10] c[14] X m[2]  m[6]  m[10] m[14] X v[2]
//     c[3]  c[7]  c[11] c[15]   m[3]  m[7]  m[11] m[15]   v[3]
//
// Where 'X' denotes matrix multiplication, and v is represented as a 4x1 matrix.
//
// While the elements of the matrix may be specified with single or double
// precision, the GL may store or operate on these values in less-than-single
// precision.
//
// In many computer languages, 4×4 arrays are represented in row-major
// order. The transformations just described represent these matrices in
// column-major order. The order of the multiplication is important. For
// example, if the current transformation is a rotation, and MultMatrix is
// called with a translation matrix, the translation is done directly on the
// coordinates to be transformed, while the rotation is done on the results
// of that translation.
//
// GL.INVALID_OPERATION is generated if MultMatrix is executed between the
// execution of Begin and the corresponding execution of End.
//
// See also LoadIdentity, LoadMatrix, LoadTransposeMatrix, MatrixMode,
// MultTransposeMatrix, PushMatrix.
//
// https://www.opengl.org/sdk/docs/man2/xhtml/glMultMatrixf.xml
func (gl *GL) MultMatrixf(m []float32) {
	if len(m) != 16 {
		panic("parameter m must have length 16 for the 4x4 matrix")
	}
	C.gl4_2compat_glMultMatrixf(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&m[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMatrixMode.xml
func (gl *GL) MatrixMode(mode glbase.Enum) {
	C.gl4_2compat_glMatrixMode(gl.funcs, C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glLoadMatrixd.xml
func (gl *GL) LoadMatrixd(m []float64) {
	C.gl4_2compat_glLoadMatrixd(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&m[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glLoadMatrixf.xml
func (gl *GL) LoadMatrixf(m []float32) {
	C.gl4_2compat_glLoadMatrixf(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&m[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glLoadIdentity.xml
func (gl *GL) LoadIdentity() {
	C.gl4_2compat_glLoadIdentity(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFrustum.xml
func (gl *GL) Frustum(left, right, bottom, top, zNear, zFar float64) {
	C.gl4_2compat_glFrustum(gl.funcs, C.GLdouble(left), C.GLdouble(right), C.GLdouble(bottom), C.GLdouble(top), C.GLdouble(zNear), C.GLdouble(zFar))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsList.xml
func (gl *GL) IsList(list uint32) bool {
	result := C.gl4_2compat_glIsList(gl.funcs, C.GLuint(list))
	return *(*bool)(unsafe.Pointer(&result))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetTexGeniv.xml
func (gl *GL) GetTexGeniv(coord, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetTexGeniv(gl.funcs, C.GLenum(coord), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetTexGenfv.xml
func (gl *GL) GetTexGenfv(coord, pname glbase.Enum, params []float32) {
	C.gl4_2compat_glGetTexGenfv(gl.funcs, C.GLenum(coord), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetTexGendv.xml
func (gl *GL) GetTexGendv(coord, pname glbase.Enum, params []float64) {
	C.gl4_2compat_glGetTexGendv(gl.funcs, C.GLenum(coord), C.GLenum(pname), (*C.GLdouble)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetTexEnviv.xml
func (gl *GL) GetTexEnviv(target, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetTexEnviv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetTexEnvfv.xml
func (gl *GL) GetTexEnvfv(target, pname glbase.Enum, params []float32) {
	C.gl4_2compat_glGetTexEnvfv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetPolygonStipple.xml
func (gl *GL) GetPolygonStipple(mask []uint8) {
	C.gl4_2compat_glGetPolygonStipple(gl.funcs, (*C.GLubyte)(unsafe.Pointer(&mask[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetPixelMapusv.xml
func (gl *GL) GetPixelMapusv(glmap glbase.Enum, values []uint16) {
	C.gl4_2compat_glGetPixelMapusv(gl.funcs, C.GLenum(glmap), (*C.GLushort)(unsafe.Pointer(&values[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetPixelMapuiv.xml
func (gl *GL) GetPixelMapuiv(glmap glbase.Enum, values []uint32) {
	C.gl4_2compat_glGetPixelMapuiv(gl.funcs, C.GLenum(glmap), (*C.GLuint)(unsafe.Pointer(&values[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetPixelMapfv.xml
func (gl *GL) GetPixelMapfv(glmap glbase.Enum, values []float32) {
	C.gl4_2compat_glGetPixelMapfv(gl.funcs, C.GLenum(glmap), (*C.GLfloat)(unsafe.Pointer(&values[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetMaterialiv.xml
func (gl *GL) GetMaterialiv(face, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetMaterialiv(gl.funcs, C.GLenum(face), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetMaterialfv.xml
func (gl *GL) GetMaterialfv(face, pname glbase.Enum, params []float32) {
	C.gl4_2compat_glGetMaterialfv(gl.funcs, C.GLenum(face), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetMapiv.xml
func (gl *GL) GetMapiv(target, query glbase.Enum, v []int32) {
	C.gl4_2compat_glGetMapiv(gl.funcs, C.GLenum(target), C.GLenum(query), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetMapfv.xml
func (gl *GL) GetMapfv(target, query glbase.Enum, v []float32) {
	C.gl4_2compat_glGetMapfv(gl.funcs, C.GLenum(target), C.GLenum(query), (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetMapdv.xml
func (gl *GL) GetMapdv(target, query glbase.Enum, v []float64) {
	C.gl4_2compat_glGetMapdv(gl.funcs, C.GLenum(target), C.GLenum(query), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetLightiv.xml
func (gl *GL) GetLightiv(light, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetLightiv(gl.funcs, C.GLenum(light), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetLightfv.xml
func (gl *GL) GetLightfv(light, pname glbase.Enum, params []float32) {
	C.gl4_2compat_glGetLightfv(gl.funcs, C.GLenum(light), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetClipPlane.xml
func (gl *GL) GetClipPlane(plane glbase.Enum, equation []float64) {
	C.gl4_2compat_glGetClipPlane(gl.funcs, C.GLenum(plane), (*C.GLdouble)(unsafe.Pointer(&equation[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawPixels.xml
func (gl *GL) DrawPixels(width, height int32, format, gltype glbase.Enum, pixels interface{}) {
	pixels_v := reflect.ValueOf(pixels)
	if pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	C.gl4_2compat_glDrawPixels(gl.funcs, C.GLsizei(width), C.GLsizei(height), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(pixels_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCopyPixels.xml
func (gl *GL) CopyPixels(x, y, width, height int32, gltype glbase.Enum) {
	C.gl4_2compat_glCopyPixels(gl.funcs, C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height), C.GLenum(gltype))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPixelMapusv.xml
func (gl *GL) PixelMapusv(glmap glbase.Enum, mapsize int32, values []uint16) {
	C.gl4_2compat_glPixelMapusv(gl.funcs, C.GLenum(glmap), C.GLint(mapsize), (*C.GLushort)(unsafe.Pointer(&values[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPixelMapuiv.xml
func (gl *GL) PixelMapuiv(glmap glbase.Enum, mapsize int32, values []uint32) {
	C.gl4_2compat_glPixelMapuiv(gl.funcs, C.GLenum(glmap), C.GLint(mapsize), (*C.GLuint)(unsafe.Pointer(&values[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPixelMapfv.xml
func (gl *GL) PixelMapfv(glmap glbase.Enum, mapsize int32, values []float32) {
	C.gl4_2compat_glPixelMapfv(gl.funcs, C.GLenum(glmap), C.GLint(mapsize), (*C.GLfloat)(unsafe.Pointer(&values[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPixelTransferi.xml
func (gl *GL) PixelTransferi(pname glbase.Enum, param int32) {
	C.gl4_2compat_glPixelTransferi(gl.funcs, C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPixelTransferf.xml
func (gl *GL) PixelTransferf(pname glbase.Enum, param float32) {
	C.gl4_2compat_glPixelTransferf(gl.funcs, C.GLenum(pname), C.GLfloat(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPixelZoom.xml
func (gl *GL) PixelZoom(xfactor, yfactor float32) {
	C.gl4_2compat_glPixelZoom(gl.funcs, C.GLfloat(xfactor), C.GLfloat(yfactor))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glAlphaFunc.xml
func (gl *GL) AlphaFunc(glfunc glbase.Enum, ref float32) {
	C.gl4_2compat_glAlphaFunc(gl.funcs, C.GLenum(glfunc), C.GLfloat(ref))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEvalPoint2.xml
func (gl *GL) EvalPoint2(i, j int32) {
	C.gl4_2compat_glEvalPoint2(gl.funcs, C.GLint(i), C.GLint(j))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEvalMesh2.xml
func (gl *GL) EvalMesh2(mode glbase.Enum, i1, i2, j1, j2 int32) {
	C.gl4_2compat_glEvalMesh2(gl.funcs, C.GLenum(mode), C.GLint(i1), C.GLint(i2), C.GLint(j1), C.GLint(j2))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEvalPoint1.xml
func (gl *GL) EvalPoint1(i int32) {
	C.gl4_2compat_glEvalPoint1(gl.funcs, C.GLint(i))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEvalMesh1.xml
func (gl *GL) EvalMesh1(mode glbase.Enum, i1, i2 int32) {
	C.gl4_2compat_glEvalMesh1(gl.funcs, C.GLenum(mode), C.GLint(i1), C.GLint(i2))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEvalCoord2fv.xml
func (gl *GL) EvalCoord2fv(u []float32) {
	if len(u) != 2 {
		panic("parameter u has incorrect length")
	}
	C.gl4_2compat_glEvalCoord2fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&u[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEvalCoord2f.xml
func (gl *GL) EvalCoord2f(u, v float32) {
	C.gl4_2compat_glEvalCoord2f(gl.funcs, C.GLfloat(u), C.GLfloat(v))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEvalCoord2dv.xml
func (gl *GL) EvalCoord2dv(u []float64) {
	if len(u) != 2 {
		panic("parameter u has incorrect length")
	}
	C.gl4_2compat_glEvalCoord2dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&u[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEvalCoord2d.xml
func (gl *GL) EvalCoord2d(u, v float64) {
	C.gl4_2compat_glEvalCoord2d(gl.funcs, C.GLdouble(u), C.GLdouble(v))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEvalCoord1fv.xml
func (gl *GL) EvalCoord1fv(u []float32) {
	C.gl4_2compat_glEvalCoord1fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&u[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEvalCoord1f.xml
func (gl *GL) EvalCoord1f(u float32) {
	C.gl4_2compat_glEvalCoord1f(gl.funcs, C.GLfloat(u))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEvalCoord1dv.xml
func (gl *GL) EvalCoord1dv(u []float64) {
	C.gl4_2compat_glEvalCoord1dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&u[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEvalCoord1d.xml
func (gl *GL) EvalCoord1d(u float64) {
	C.gl4_2compat_glEvalCoord1d(gl.funcs, C.GLdouble(u))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMapGrid2f.xml
func (gl *GL) MapGrid2f(un int32, u1, u2 float32, vn int32, v1, v2 float32) {
	C.gl4_2compat_glMapGrid2f(gl.funcs, C.GLint(un), C.GLfloat(u1), C.GLfloat(u2), C.GLint(vn), C.GLfloat(v1), C.GLfloat(v2))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMapGrid2d.xml
func (gl *GL) MapGrid2d(un int32, u1, u2 float64, vn int32, v1, v2 float64) {
	C.gl4_2compat_glMapGrid2d(gl.funcs, C.GLint(un), C.GLdouble(u1), C.GLdouble(u2), C.GLint(vn), C.GLdouble(v1), C.GLdouble(v2))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMapGrid1f.xml
func (gl *GL) MapGrid1f(un int32, u1, u2 float32) {
	C.gl4_2compat_glMapGrid1f(gl.funcs, C.GLint(un), C.GLfloat(u1), C.GLfloat(u2))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMapGrid1d.xml
func (gl *GL) MapGrid1d(un int32, u1, u2 float64) {
	C.gl4_2compat_glMapGrid1d(gl.funcs, C.GLint(un), C.GLdouble(u1), C.GLdouble(u2))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMap2f.xml
func (gl *GL) Map2f(target glbase.Enum, u1, u2 float32, ustride, uorder int32, v1, v2 float32, vstride, vorder int32, points []float32) {
	C.gl4_2compat_glMap2f(gl.funcs, C.GLenum(target), C.GLfloat(u1), C.GLfloat(u2), C.GLint(ustride), C.GLint(uorder), C.GLfloat(v1), C.GLfloat(v2), C.GLint(vstride), C.GLint(vorder), (*C.GLfloat)(unsafe.Pointer(&points[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMap2d.xml
func (gl *GL) Map2d(target glbase.Enum, u1, u2 float64, ustride, uorder int32, v1, v2 float64, vstride, vorder int32, points []float64) {
	C.gl4_2compat_glMap2d(gl.funcs, C.GLenum(target), C.GLdouble(u1), C.GLdouble(u2), C.GLint(ustride), C.GLint(uorder), C.GLdouble(v1), C.GLdouble(v2), C.GLint(vstride), C.GLint(vorder), (*C.GLdouble)(unsafe.Pointer(&points[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMap1f.xml
func (gl *GL) Map1f(target glbase.Enum, u1, u2 float32, stride, order int32, points []float32) {
	C.gl4_2compat_glMap1f(gl.funcs, C.GLenum(target), C.GLfloat(u1), C.GLfloat(u2), C.GLint(stride), C.GLint(order), (*C.GLfloat)(unsafe.Pointer(&points[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMap1d.xml
func (gl *GL) Map1d(target glbase.Enum, u1, u2 float64, stride, order int32, points []float64) {
	C.gl4_2compat_glMap1d(gl.funcs, C.GLenum(target), C.GLdouble(u1), C.GLdouble(u2), C.GLint(stride), C.GLint(order), (*C.GLdouble)(unsafe.Pointer(&points[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPushAttrib.xml
func (gl *GL) PushAttrib(mask glbase.Bitfield) {
	C.gl4_2compat_glPushAttrib(gl.funcs, C.GLbitfield(mask))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPopAttrib.xml
func (gl *GL) PopAttrib() {
	C.gl4_2compat_glPopAttrib(gl.funcs)
}

// Accum executes an operation on the accumulation buffer.
//
// Parameter op defines the accumulation buffer operation (GL.ACCUM, GL.LOAD,
// GL.ADD, GL.MULT, or GL.RETURN) and specifies how the value parameter is
// used.
//
// The accumulation buffer is an extended-range color buffer. Images are not
// rendered into it. Rather, images rendered into one of the color buffers
// are added to the contents of the accumulation buffer after rendering.
// Effects such as antialiasing (of points, lines, and polygons), motion
// blur, and depth of field can be created by accumulating images generated
// with different transformation matrices.
//
// Each pixel in the accumulation buffer consists of red, green, blue, and
// alpha values. The number of bits per component in the accumulation buffer
// depends on the implementation. You can examine this number by calling
// GetIntegerv four times, with arguments GL.ACCUM_RED_BITS,
// GL.ACCUM_GREEN_BITS, GL.ACCUM_BLUE_BITS, and GL.ACCUM_ALPHA_BITS.
// Regardless of the number of bits per component, the range of values stored
// by each component is (-1, 1). The accumulation buffer pixels are mapped
// one-to-one with frame buffer pixels.
//
// All accumulation buffer operations are limited to the area of the current
// scissor box and applied identically to the red, green, blue, and alpha
// components of each pixel. If a Accum operation results in a value outside
// the range (-1, 1), the contents of an accumulation buffer pixel component
// are undefined.
//
// The operations are as follows:
//
//   GL.ACCUM
//       Obtains R, G, B, and A values from the buffer currently selected for
//       reading (see glReadBuffer). Each component value is divided by 2 n -
//       1 , where n is the number of bits allocated to each color component
//       in the currently selected buffer. The result is a floating-point
//       value in the range 0 1 , which is multiplied by value and added to
//       the corresponding pixel component in the accumulation buffer,
//       thereby updating the accumulation buffer.
//
//   GL.LOAD
//       Similar to GL.ACCUM, except that the current value in the
//       accumulation buffer is not used in the calculation of the new value.
//       That is, the R, G, B, and A values from the currently selected
//       buffer are divided by 2 n - 1 , multiplied by value, and then stored
//       in the corresponding accumulation buffer cell, overwriting the
//       current value.
//
//   GL.ADD
//       Adds value to each R, G, B, and A in the accumulation buffer.
//
//   GL.MULT
//       Multiplies each R, G, B, and A in the accumulation buffer by value
//       and returns the scaled component to its corresponding accumulation
//       buffer location.
//
//   GL.RETURN
//       Transfers accumulation buffer values to the color buffer or buffers
//       currently selected for writing. Each R, G, B, and A component is
//       multiplied by value, then multiplied by 2 n - 1 , clamped to the
//       range 0 2 n - 1 , and stored in the corresponding display buffer
//       cell. The only fragment operations that are applied to this transfer
//       are pixel ownership, scissor, dithering, and color writemasks.
//
// To clear the accumulation buffer, call ClearAccum with R, G, B, and A
// values to set it to, then call Clear with the accumulation buffer
// enabled.
//
// Error GL.INVALID_ENUM is generated if op is not an accepted value.
// GL.INVALID_OPERATION is generated if there is no accumulation buffer.
// GL.INVALID_OPERATION is generated if Accum is executed between the
// execution of Begin and the corresponding execution of End.
//
// See also Clear, ClearAccum, CopyPixels, DrawBuffer, Get, ReadBuffer,
// ReadPixels, Scissor, StencilOp
//
// https://www.opengl.org/sdk/docs/man2/xhtml/glAccum.xml
func (gl *GL) Accum(op glbase.Enum, value float32) {
	C.gl4_2compat_glAccum(gl.funcs, C.GLenum(op), C.GLfloat(value))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIndexMask.xml
func (gl *GL) IndexMask(mask uint32) {
	C.gl4_2compat_glIndexMask(gl.funcs, C.GLuint(mask))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClearIndex.xml
func (gl *GL) ClearIndex(c float32) {
	C.gl4_2compat_glClearIndex(gl.funcs, C.GLfloat(c))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClearAccum.xml
func (gl *GL) ClearAccum(red, green, blue, alpha float32) {
	C.gl4_2compat_glClearAccum(gl.funcs, C.GLfloat(red), C.GLfloat(green), C.GLfloat(blue), C.GLfloat(alpha))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPushName.xml
func (gl *GL) PushName(name uint32) {
	C.gl4_2compat_glPushName(gl.funcs, C.GLuint(name))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPopName.xml
func (gl *GL) PopName() {
	C.gl4_2compat_glPopName(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPassThrough.xml
func (gl *GL) PassThrough(token float32) {
	C.gl4_2compat_glPassThrough(gl.funcs, C.GLfloat(token))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glLoadName.xml
func (gl *GL) LoadName(name uint32) {
	C.gl4_2compat_glLoadName(gl.funcs, C.GLuint(name))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glInitNames.xml
func (gl *GL) InitNames() {
	C.gl4_2compat_glInitNames(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRenderMode.xml
func (gl *GL) RenderMode(mode glbase.Enum) int32 {
	result := C.gl4_2compat_glRenderMode(gl.funcs, C.GLenum(mode))
	return int32(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSelectBuffer.xml
func (gl *GL) SelectBuffer(size int32, buffer []glbase.Buffer) {
	C.gl4_2compat_glSelectBuffer(gl.funcs, C.GLsizei(size), (*C.GLuint)(unsafe.Pointer(&buffer[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFeedbackBuffer.xml
func (gl *GL) FeedbackBuffer(size int32, gltype glbase.Enum, buffer []float32) {
	C.gl4_2compat_glFeedbackBuffer(gl.funcs, C.GLsizei(size), C.GLenum(gltype), (*C.GLfloat)(unsafe.Pointer(&buffer[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexGeniv.xml
func (gl *GL) TexGeniv(coord, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glTexGeniv(gl.funcs, C.GLenum(coord), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexGeni.xml
func (gl *GL) TexGeni(coord, pname glbase.Enum, param int32) {
	C.gl4_2compat_glTexGeni(gl.funcs, C.GLenum(coord), C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexGenfv.xml
func (gl *GL) TexGenfv(coord, pname glbase.Enum, params []float32) {
	C.gl4_2compat_glTexGenfv(gl.funcs, C.GLenum(coord), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexGenf.xml
func (gl *GL) TexGenf(coord, pname glbase.Enum, param float32) {
	C.gl4_2compat_glTexGenf(gl.funcs, C.GLenum(coord), C.GLenum(pname), C.GLfloat(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexGendv.xml
func (gl *GL) TexGendv(coord, pname glbase.Enum, params []float64) {
	C.gl4_2compat_glTexGendv(gl.funcs, C.GLenum(coord), C.GLenum(pname), (*C.GLdouble)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexGend.xml
func (gl *GL) TexGend(coord, pname glbase.Enum, param float64) {
	C.gl4_2compat_glTexGend(gl.funcs, C.GLenum(coord), C.GLenum(pname), C.GLdouble(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexEnviv.xml
func (gl *GL) TexEnviv(target, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glTexEnviv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexEnvi.xml
func (gl *GL) TexEnvi(target, pname glbase.Enum, param int32) {
	C.gl4_2compat_glTexEnvi(gl.funcs, C.GLenum(target), C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexEnvfv.xml
func (gl *GL) TexEnvfv(target, pname glbase.Enum, params []float32) {
	C.gl4_2compat_glTexEnvfv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexEnvf.xml
func (gl *GL) TexEnvf(target, pname glbase.Enum, param float32) {
	C.gl4_2compat_glTexEnvf(gl.funcs, C.GLenum(target), C.GLenum(pname), C.GLfloat(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glShadeModel.xml
func (gl *GL) ShadeModel(mode glbase.Enum) {
	C.gl4_2compat_glShadeModel(gl.funcs, C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPolygonStipple.xml
func (gl *GL) PolygonStipple(mask []uint8) {
	C.gl4_2compat_glPolygonStipple(gl.funcs, (*C.GLubyte)(unsafe.Pointer(&mask[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMaterialiv.xml
func (gl *GL) Materialiv(face, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glMaterialiv(gl.funcs, C.GLenum(face), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMateriali.xml
func (gl *GL) Materiali(face, pname glbase.Enum, param int32) {
	C.gl4_2compat_glMateriali(gl.funcs, C.GLenum(face), C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMaterialfv.xml
func (gl *GL) Materialfv(face, pname glbase.Enum, params []float32) {
	C.gl4_2compat_glMaterialfv(gl.funcs, C.GLenum(face), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMaterialf.xml
func (gl *GL) Materialf(face, pname glbase.Enum, param float32) {
	C.gl4_2compat_glMaterialf(gl.funcs, C.GLenum(face), C.GLenum(pname), C.GLfloat(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glLineStipple.xml
func (gl *GL) LineStipple(factor int32, pattern uint16) {
	C.gl4_2compat_glLineStipple(gl.funcs, C.GLint(factor), C.GLushort(pattern))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glLightModeliv.xml
func (gl *GL) LightModeliv(pname glbase.Enum, params []int32) {
	C.gl4_2compat_glLightModeliv(gl.funcs, C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glLightModeli.xml
func (gl *GL) LightModeli(pname glbase.Enum, param int32) {
	C.gl4_2compat_glLightModeli(gl.funcs, C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glLightModelfv.xml
func (gl *GL) LightModelfv(pname glbase.Enum, params []float32) {
	C.gl4_2compat_glLightModelfv(gl.funcs, C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glLightModelf.xml
func (gl *GL) LightModelf(pname glbase.Enum, param float32) {
	C.gl4_2compat_glLightModelf(gl.funcs, C.GLenum(pname), C.GLfloat(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glLightiv.xml
func (gl *GL) Lightiv(light, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glLightiv(gl.funcs, C.GLenum(light), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glLighti.xml
func (gl *GL) Lighti(light, pname glbase.Enum, param int32) {
	C.gl4_2compat_glLighti(gl.funcs, C.GLenum(light), C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glLightfv.xml
func (gl *GL) Lightfv(light, pname glbase.Enum, params []float32) {
	C.gl4_2compat_glLightfv(gl.funcs, C.GLenum(light), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glLightf.xml
func (gl *GL) Lightf(light, pname glbase.Enum, param float32) {
	C.gl4_2compat_glLightf(gl.funcs, C.GLenum(light), C.GLenum(pname), C.GLfloat(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFogiv.xml
func (gl *GL) Fogiv(pname glbase.Enum, params []int32) {
	C.gl4_2compat_glFogiv(gl.funcs, C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFogi.xml
func (gl *GL) Fogi(pname glbase.Enum, param int32) {
	C.gl4_2compat_glFogi(gl.funcs, C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFogfv.xml
func (gl *GL) Fogfv(pname glbase.Enum, params []float32) {
	C.gl4_2compat_glFogfv(gl.funcs, C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFogf.xml
func (gl *GL) Fogf(pname glbase.Enum, param float32) {
	C.gl4_2compat_glFogf(gl.funcs, C.GLenum(pname), C.GLfloat(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColorMaterial.xml
func (gl *GL) ColorMaterial(face, mode glbase.Enum) {
	C.gl4_2compat_glColorMaterial(gl.funcs, C.GLenum(face), C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClipPlane.xml
func (gl *GL) ClipPlane(plane glbase.Enum, equation []float64) {
	C.gl4_2compat_glClipPlane(gl.funcs, C.GLenum(plane), (*C.GLdouble)(unsafe.Pointer(&equation[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertex4sv.xml
func (gl *GL) Vertex4sv(v []int16) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertex4sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertex4s.xml
func (gl *GL) Vertex4s(x, y, z, w int16) {
	C.gl4_2compat_glVertex4s(gl.funcs, C.GLshort(x), C.GLshort(y), C.GLshort(z), C.GLshort(w))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertex4iv.xml
func (gl *GL) Vertex4iv(v []int32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertex4iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertex4i.xml
func (gl *GL) Vertex4i(x, y, z, w int32) {
	C.gl4_2compat_glVertex4i(gl.funcs, C.GLint(x), C.GLint(y), C.GLint(z), C.GLint(w))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertex4fv.xml
func (gl *GL) Vertex4fv(v []float32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertex4fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertex4f.xml
func (gl *GL) Vertex4f(x, y, z, w float32) {
	C.gl4_2compat_glVertex4f(gl.funcs, C.GLfloat(x), C.GLfloat(y), C.GLfloat(z), C.GLfloat(w))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertex4dv.xml
func (gl *GL) Vertex4dv(v []float64) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertex4dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertex4d.xml
func (gl *GL) Vertex4d(x, y, z, w float64) {
	C.gl4_2compat_glVertex4d(gl.funcs, C.GLdouble(x), C.GLdouble(y), C.GLdouble(z), C.GLdouble(w))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertex3sv.xml
func (gl *GL) Vertex3sv(v []int16) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertex3sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertex3s.xml
func (gl *GL) Vertex3s(x, y, z int16) {
	C.gl4_2compat_glVertex3s(gl.funcs, C.GLshort(x), C.GLshort(y), C.GLshort(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertex3iv.xml
func (gl *GL) Vertex3iv(v []int32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertex3iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertex3i.xml
func (gl *GL) Vertex3i(x, y, z int32) {
	C.gl4_2compat_glVertex3i(gl.funcs, C.GLint(x), C.GLint(y), C.GLint(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertex3fv.xml
func (gl *GL) Vertex3fv(v []float32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertex3fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertex3f.xml
func (gl *GL) Vertex3f(x, y, z float32) {
	C.gl4_2compat_glVertex3f(gl.funcs, C.GLfloat(x), C.GLfloat(y), C.GLfloat(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertex3dv.xml
func (gl *GL) Vertex3dv(v []float64) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertex3dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertex3d.xml
func (gl *GL) Vertex3d(x, y, z float64) {
	C.gl4_2compat_glVertex3d(gl.funcs, C.GLdouble(x), C.GLdouble(y), C.GLdouble(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertex2sv.xml
func (gl *GL) Vertex2sv(v []int16) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertex2sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertex2s.xml
func (gl *GL) Vertex2s(x, y int16) {
	C.gl4_2compat_glVertex2s(gl.funcs, C.GLshort(x), C.GLshort(y))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertex2iv.xml
func (gl *GL) Vertex2iv(v []int32) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertex2iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertex2i.xml
func (gl *GL) Vertex2i(x, y int32) {
	C.gl4_2compat_glVertex2i(gl.funcs, C.GLint(x), C.GLint(y))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertex2fv.xml
func (gl *GL) Vertex2fv(v []float32) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertex2fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertex2f.xml
func (gl *GL) Vertex2f(x, y float32) {
	C.gl4_2compat_glVertex2f(gl.funcs, C.GLfloat(x), C.GLfloat(y))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertex2dv.xml
func (gl *GL) Vertex2dv(v []float64) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertex2dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertex2d.xml
func (gl *GL) Vertex2d(x, y float64) {
	C.gl4_2compat_glVertex2d(gl.funcs, C.GLdouble(x), C.GLdouble(y))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord4sv.xml
func (gl *GL) TexCoord4sv(v []int16) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glTexCoord4sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord4s.xml
func (gl *GL) TexCoord4s(s, t, r, q int16) {
	C.gl4_2compat_glTexCoord4s(gl.funcs, C.GLshort(s), C.GLshort(t), C.GLshort(r), C.GLshort(q))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord4iv.xml
func (gl *GL) TexCoord4iv(v []int32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glTexCoord4iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord4i.xml
func (gl *GL) TexCoord4i(s, t, r, q int32) {
	C.gl4_2compat_glTexCoord4i(gl.funcs, C.GLint(s), C.GLint(t), C.GLint(r), C.GLint(q))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord4fv.xml
func (gl *GL) TexCoord4fv(v []float32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glTexCoord4fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord4f.xml
func (gl *GL) TexCoord4f(s, t, r, q float32) {
	C.gl4_2compat_glTexCoord4f(gl.funcs, C.GLfloat(s), C.GLfloat(t), C.GLfloat(r), C.GLfloat(q))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord4dv.xml
func (gl *GL) TexCoord4dv(v []float64) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glTexCoord4dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord4d.xml
func (gl *GL) TexCoord4d(s, t, r, q float64) {
	C.gl4_2compat_glTexCoord4d(gl.funcs, C.GLdouble(s), C.GLdouble(t), C.GLdouble(r), C.GLdouble(q))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord3sv.xml
func (gl *GL) TexCoord3sv(v []int16) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glTexCoord3sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord3s.xml
func (gl *GL) TexCoord3s(s, t, r int16) {
	C.gl4_2compat_glTexCoord3s(gl.funcs, C.GLshort(s), C.GLshort(t), C.GLshort(r))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord3iv.xml
func (gl *GL) TexCoord3iv(v []int32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glTexCoord3iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord3i.xml
func (gl *GL) TexCoord3i(s, t, r int32) {
	C.gl4_2compat_glTexCoord3i(gl.funcs, C.GLint(s), C.GLint(t), C.GLint(r))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord3fv.xml
func (gl *GL) TexCoord3fv(v []float32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glTexCoord3fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord3f.xml
func (gl *GL) TexCoord3f(s, t, r float32) {
	C.gl4_2compat_glTexCoord3f(gl.funcs, C.GLfloat(s), C.GLfloat(t), C.GLfloat(r))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord3dv.xml
func (gl *GL) TexCoord3dv(v []float64) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glTexCoord3dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord3d.xml
func (gl *GL) TexCoord3d(s, t, r float64) {
	C.gl4_2compat_glTexCoord3d(gl.funcs, C.GLdouble(s), C.GLdouble(t), C.GLdouble(r))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord2sv.xml
func (gl *GL) TexCoord2sv(v []int16) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glTexCoord2sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord2s.xml
func (gl *GL) TexCoord2s(s, t int16) {
	C.gl4_2compat_glTexCoord2s(gl.funcs, C.GLshort(s), C.GLshort(t))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord2iv.xml
func (gl *GL) TexCoord2iv(v []int32) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glTexCoord2iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord2i.xml
func (gl *GL) TexCoord2i(s, t int32) {
	C.gl4_2compat_glTexCoord2i(gl.funcs, C.GLint(s), C.GLint(t))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord2fv.xml
func (gl *GL) TexCoord2fv(v []float32) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glTexCoord2fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord2f.xml
func (gl *GL) TexCoord2f(s, t float32) {
	C.gl4_2compat_glTexCoord2f(gl.funcs, C.GLfloat(s), C.GLfloat(t))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord2dv.xml
func (gl *GL) TexCoord2dv(v []float64) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glTexCoord2dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord2d.xml
func (gl *GL) TexCoord2d(s, t float64) {
	C.gl4_2compat_glTexCoord2d(gl.funcs, C.GLdouble(s), C.GLdouble(t))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord1sv.xml
func (gl *GL) TexCoord1sv(v []int16) {
	C.gl4_2compat_glTexCoord1sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord1s.xml
func (gl *GL) TexCoord1s(s int16) {
	C.gl4_2compat_glTexCoord1s(gl.funcs, C.GLshort(s))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord1iv.xml
func (gl *GL) TexCoord1iv(v []int32) {
	C.gl4_2compat_glTexCoord1iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord1i.xml
func (gl *GL) TexCoord1i(s int32) {
	C.gl4_2compat_glTexCoord1i(gl.funcs, C.GLint(s))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord1fv.xml
func (gl *GL) TexCoord1fv(v []float32) {
	C.gl4_2compat_glTexCoord1fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord1f.xml
func (gl *GL) TexCoord1f(s float32) {
	C.gl4_2compat_glTexCoord1f(gl.funcs, C.GLfloat(s))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord1dv.xml
func (gl *GL) TexCoord1dv(v []float64) {
	C.gl4_2compat_glTexCoord1dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoord1d.xml
func (gl *GL) TexCoord1d(s float64) {
	C.gl4_2compat_glTexCoord1d(gl.funcs, C.GLdouble(s))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRectsv.xml
func (gl *GL) Rectsv(v1, v2 []int16) {
	C.gl4_2compat_glRectsv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v1[0])), (*C.GLshort)(unsafe.Pointer(&v2[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRects.xml
func (gl *GL) Rects(x1, y1, x2, y2 int16) {
	C.gl4_2compat_glRects(gl.funcs, C.GLshort(x1), C.GLshort(y1), C.GLshort(x2), C.GLshort(y2))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRectiv.xml
func (gl *GL) Rectiv(v1, v2 []int32) {
	C.gl4_2compat_glRectiv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v1[0])), (*C.GLint)(unsafe.Pointer(&v2[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRecti.xml
func (gl *GL) Recti(x1, y1, x2, y2 int32) {
	C.gl4_2compat_glRecti(gl.funcs, C.GLint(x1), C.GLint(y1), C.GLint(x2), C.GLint(y2))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRectfv.xml
func (gl *GL) Rectfv(v1, v2 []float32) {
	C.gl4_2compat_glRectfv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v1[0])), (*C.GLfloat)(unsafe.Pointer(&v2[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRectf.xml
func (gl *GL) Rectf(x1, y1, x2, y2 float32) {
	C.gl4_2compat_glRectf(gl.funcs, C.GLfloat(x1), C.GLfloat(y1), C.GLfloat(x2), C.GLfloat(y2))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRectdv.xml
func (gl *GL) Rectdv(v1, v2 []float64) {
	C.gl4_2compat_glRectdv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v1[0])), (*C.GLdouble)(unsafe.Pointer(&v2[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRectd.xml
func (gl *GL) Rectd(x1, y1, x2, y2 float64) {
	C.gl4_2compat_glRectd(gl.funcs, C.GLdouble(x1), C.GLdouble(y1), C.GLdouble(x2), C.GLdouble(y2))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRasterPos4sv.xml
func (gl *GL) RasterPos4sv(v []int16) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glRasterPos4sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRasterPos4s.xml
func (gl *GL) RasterPos4s(x, y, z, w int16) {
	C.gl4_2compat_glRasterPos4s(gl.funcs, C.GLshort(x), C.GLshort(y), C.GLshort(z), C.GLshort(w))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRasterPos4iv.xml
func (gl *GL) RasterPos4iv(v []int32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glRasterPos4iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRasterPos4i.xml
func (gl *GL) RasterPos4i(x, y, z, w int32) {
	C.gl4_2compat_glRasterPos4i(gl.funcs, C.GLint(x), C.GLint(y), C.GLint(z), C.GLint(w))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRasterPos4fv.xml
func (gl *GL) RasterPos4fv(v []float32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glRasterPos4fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRasterPos4f.xml
func (gl *GL) RasterPos4f(x, y, z, w float32) {
	C.gl4_2compat_glRasterPos4f(gl.funcs, C.GLfloat(x), C.GLfloat(y), C.GLfloat(z), C.GLfloat(w))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRasterPos4dv.xml
func (gl *GL) RasterPos4dv(v []float64) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glRasterPos4dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRasterPos4d.xml
func (gl *GL) RasterPos4d(x, y, z, w float64) {
	C.gl4_2compat_glRasterPos4d(gl.funcs, C.GLdouble(x), C.GLdouble(y), C.GLdouble(z), C.GLdouble(w))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRasterPos3sv.xml
func (gl *GL) RasterPos3sv(v []int16) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glRasterPos3sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRasterPos3s.xml
func (gl *GL) RasterPos3s(x, y, z int16) {
	C.gl4_2compat_glRasterPos3s(gl.funcs, C.GLshort(x), C.GLshort(y), C.GLshort(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRasterPos3iv.xml
func (gl *GL) RasterPos3iv(v []int32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glRasterPos3iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRasterPos3i.xml
func (gl *GL) RasterPos3i(x, y, z int32) {
	C.gl4_2compat_glRasterPos3i(gl.funcs, C.GLint(x), C.GLint(y), C.GLint(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRasterPos3fv.xml
func (gl *GL) RasterPos3fv(v []float32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glRasterPos3fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRasterPos3f.xml
func (gl *GL) RasterPos3f(x, y, z float32) {
	C.gl4_2compat_glRasterPos3f(gl.funcs, C.GLfloat(x), C.GLfloat(y), C.GLfloat(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRasterPos3dv.xml
func (gl *GL) RasterPos3dv(v []float64) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glRasterPos3dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRasterPos3d.xml
func (gl *GL) RasterPos3d(x, y, z float64) {
	C.gl4_2compat_glRasterPos3d(gl.funcs, C.GLdouble(x), C.GLdouble(y), C.GLdouble(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRasterPos2sv.xml
func (gl *GL) RasterPos2sv(v []int16) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glRasterPos2sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRasterPos2s.xml
func (gl *GL) RasterPos2s(x, y int16) {
	C.gl4_2compat_glRasterPos2s(gl.funcs, C.GLshort(x), C.GLshort(y))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRasterPos2iv.xml
func (gl *GL) RasterPos2iv(v []int32) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glRasterPos2iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRasterPos2i.xml
func (gl *GL) RasterPos2i(x, y int32) {
	C.gl4_2compat_glRasterPos2i(gl.funcs, C.GLint(x), C.GLint(y))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRasterPos2fv.xml
func (gl *GL) RasterPos2fv(v []float32) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glRasterPos2fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRasterPos2f.xml
func (gl *GL) RasterPos2f(x, y float32) {
	C.gl4_2compat_glRasterPos2f(gl.funcs, C.GLfloat(x), C.GLfloat(y))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRasterPos2dv.xml
func (gl *GL) RasterPos2dv(v []float64) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glRasterPos2dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRasterPos2d.xml
func (gl *GL) RasterPos2d(x, y float64) {
	C.gl4_2compat_glRasterPos2d(gl.funcs, C.GLdouble(x), C.GLdouble(y))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glNormal3sv.xml
func (gl *GL) Normal3sv(v []int16) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glNormal3sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glNormal3s.xml
func (gl *GL) Normal3s(nx, ny, nz int16) {
	C.gl4_2compat_glNormal3s(gl.funcs, C.GLshort(nx), C.GLshort(ny), C.GLshort(nz))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glNormal3iv.xml
func (gl *GL) Normal3iv(v []int32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glNormal3iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glNormal3i.xml
func (gl *GL) Normal3i(nx, ny, nz int32) {
	C.gl4_2compat_glNormal3i(gl.funcs, C.GLint(nx), C.GLint(ny), C.GLint(nz))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glNormal3fv.xml
func (gl *GL) Normal3fv(v []float32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glNormal3fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glNormal3f.xml
func (gl *GL) Normal3f(nx, ny, nz float32) {
	C.gl4_2compat_glNormal3f(gl.funcs, C.GLfloat(nx), C.GLfloat(ny), C.GLfloat(nz))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glNormal3dv.xml
func (gl *GL) Normal3dv(v []float64) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glNormal3dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glNormal3d.xml
func (gl *GL) Normal3d(nx, ny, nz float64) {
	C.gl4_2compat_glNormal3d(gl.funcs, C.GLdouble(nx), C.GLdouble(ny), C.GLdouble(nz))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glNormal3bv.xml
func (gl *GL) Normal3bv(v []byte) {
	C.gl4_2compat_glNormal3bv(gl.funcs, (*C.GLbyte)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glNormal3b.xml
func (gl *GL) Normal3b(nx, ny, nz byte) {
	C.gl4_2compat_glNormal3b(gl.funcs, C.GLbyte(nx), C.GLbyte(ny), C.GLbyte(nz))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIndexsv.xml
func (gl *GL) Indexsv(c []int16) {
	C.gl4_2compat_glIndexsv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&c[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIndexs.xml
func (gl *GL) Indexs(c int16) {
	C.gl4_2compat_glIndexs(gl.funcs, C.GLshort(c))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIndexiv.xml
func (gl *GL) Indexiv(c []int32) {
	C.gl4_2compat_glIndexiv(gl.funcs, (*C.GLint)(unsafe.Pointer(&c[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIndexi.xml
func (gl *GL) Indexi(c int32) {
	C.gl4_2compat_glIndexi(gl.funcs, C.GLint(c))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIndexfv.xml
func (gl *GL) Indexfv(c []float32) {
	C.gl4_2compat_glIndexfv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&c[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIndexf.xml
func (gl *GL) Indexf(c float32) {
	C.gl4_2compat_glIndexf(gl.funcs, C.GLfloat(c))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIndexdv.xml
func (gl *GL) Indexdv(c []float64) {
	C.gl4_2compat_glIndexdv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&c[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIndexd.xml
func (gl *GL) Indexd(c float64) {
	C.gl4_2compat_glIndexd(gl.funcs, C.GLdouble(c))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEnd.xml
func (gl *GL) End() {
	C.gl4_2compat_glEnd(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEdgeFlagv.xml
func (gl *GL) EdgeFlagv(flag []bool) {
	C.gl4_2compat_glEdgeFlagv(gl.funcs, (*C.GLboolean)(unsafe.Pointer(&flag[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEdgeFlag.xml
func (gl *GL) EdgeFlag(flag bool) {
	C.gl4_2compat_glEdgeFlag(gl.funcs, *(*C.GLboolean)(unsafe.Pointer(&flag)))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor4usv.xml
func (gl *GL) Color4usv(v []uint16) {
	C.gl4_2compat_glColor4usv(gl.funcs, (*C.GLushort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor4us.xml
func (gl *GL) Color4us(red, green, blue, alpha uint16) {
	C.gl4_2compat_glColor4us(gl.funcs, C.GLushort(red), C.GLushort(green), C.GLushort(blue), C.GLushort(alpha))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor4uiv.xml
func (gl *GL) Color4uiv(v []uint32) {
	C.gl4_2compat_glColor4uiv(gl.funcs, (*C.GLuint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor4ui.xml
func (gl *GL) Color4ui(red, green, blue, alpha uint32) {
	C.gl4_2compat_glColor4ui(gl.funcs, C.GLuint(red), C.GLuint(green), C.GLuint(blue), C.GLuint(alpha))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor4ubv.xml
func (gl *GL) Color4ubv(v []uint8) {
	C.gl4_2compat_glColor4ubv(gl.funcs, (*C.GLubyte)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor4ub.xml
func (gl *GL) Color4ub(red, green, blue, alpha uint8) {
	C.gl4_2compat_glColor4ub(gl.funcs, C.GLubyte(red), C.GLubyte(green), C.GLubyte(blue), C.GLubyte(alpha))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor4sv.xml
func (gl *GL) Color4sv(v []int16) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glColor4sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor4s.xml
func (gl *GL) Color4s(red, green, blue, alpha int16) {
	C.gl4_2compat_glColor4s(gl.funcs, C.GLshort(red), C.GLshort(green), C.GLshort(blue), C.GLshort(alpha))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor4iv.xml
func (gl *GL) Color4iv(v []int32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glColor4iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor4i.xml
func (gl *GL) Color4i(red, green, blue, alpha int32) {
	C.gl4_2compat_glColor4i(gl.funcs, C.GLint(red), C.GLint(green), C.GLint(blue), C.GLint(alpha))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor4fv.xml
func (gl *GL) Color4fv(v []float32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glColor4fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor4f.xml
func (gl *GL) Color4f(red, green, blue, alpha float32) {
	C.gl4_2compat_glColor4f(gl.funcs, C.GLfloat(red), C.GLfloat(green), C.GLfloat(blue), C.GLfloat(alpha))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor4dv.xml
func (gl *GL) Color4dv(v []float64) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glColor4dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor4d.xml
func (gl *GL) Color4d(red, green, blue, alpha float64) {
	C.gl4_2compat_glColor4d(gl.funcs, C.GLdouble(red), C.GLdouble(green), C.GLdouble(blue), C.GLdouble(alpha))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor4bv.xml
func (gl *GL) Color4bv(v []byte) {
	C.gl4_2compat_glColor4bv(gl.funcs, (*C.GLbyte)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor4b.xml
func (gl *GL) Color4b(red, green, blue, alpha byte) {
	C.gl4_2compat_glColor4b(gl.funcs, C.GLbyte(red), C.GLbyte(green), C.GLbyte(blue), C.GLbyte(alpha))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor3usv.xml
func (gl *GL) Color3usv(v []uint16) {
	C.gl4_2compat_glColor3usv(gl.funcs, (*C.GLushort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor3us.xml
func (gl *GL) Color3us(red, green, blue uint16) {
	C.gl4_2compat_glColor3us(gl.funcs, C.GLushort(red), C.GLushort(green), C.GLushort(blue))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor3uiv.xml
func (gl *GL) Color3uiv(v []uint32) {
	C.gl4_2compat_glColor3uiv(gl.funcs, (*C.GLuint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor3ui.xml
func (gl *GL) Color3ui(red, green, blue uint32) {
	C.gl4_2compat_glColor3ui(gl.funcs, C.GLuint(red), C.GLuint(green), C.GLuint(blue))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor3ubv.xml
func (gl *GL) Color3ubv(v []uint8) {
	C.gl4_2compat_glColor3ubv(gl.funcs, (*C.GLubyte)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor3ub.xml
func (gl *GL) Color3ub(red, green, blue uint8) {
	C.gl4_2compat_glColor3ub(gl.funcs, C.GLubyte(red), C.GLubyte(green), C.GLubyte(blue))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor3sv.xml
func (gl *GL) Color3sv(v []int16) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glColor3sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor3s.xml
func (gl *GL) Color3s(red, green, blue int16) {
	C.gl4_2compat_glColor3s(gl.funcs, C.GLshort(red), C.GLshort(green), C.GLshort(blue))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor3iv.xml
func (gl *GL) Color3iv(v []int32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glColor3iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor3i.xml
func (gl *GL) Color3i(red, green, blue int32) {
	C.gl4_2compat_glColor3i(gl.funcs, C.GLint(red), C.GLint(green), C.GLint(blue))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor3fv.xml
func (gl *GL) Color3fv(v []float32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glColor3fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor3f.xml
func (gl *GL) Color3f(red, green, blue float32) {
	C.gl4_2compat_glColor3f(gl.funcs, C.GLfloat(red), C.GLfloat(green), C.GLfloat(blue))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor3dv.xml
func (gl *GL) Color3dv(v []float64) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glColor3dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor3d.xml
func (gl *GL) Color3d(red, green, blue float64) {
	C.gl4_2compat_glColor3d(gl.funcs, C.GLdouble(red), C.GLdouble(green), C.GLdouble(blue))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor3bv.xml
func (gl *GL) Color3bv(v []byte) {
	C.gl4_2compat_glColor3bv(gl.funcs, (*C.GLbyte)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColor3b.xml
func (gl *GL) Color3b(red, green, blue byte) {
	C.gl4_2compat_glColor3b(gl.funcs, C.GLbyte(red), C.GLbyte(green), C.GLbyte(blue))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBitmap.xml
func (gl *GL) Bitmap(width, height int32, xorig, yorig, xmove, ymove float32, bitmap []uint8) {
	C.gl4_2compat_glBitmap(gl.funcs, C.GLsizei(width), C.GLsizei(height), C.GLfloat(xorig), C.GLfloat(yorig), C.GLfloat(xmove), C.GLfloat(ymove), (*C.GLubyte)(unsafe.Pointer(&bitmap[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBegin.xml
func (gl *GL) Begin(mode glbase.Enum) {
	C.gl4_2compat_glBegin(gl.funcs, C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glListBase.xml
func (gl *GL) ListBase(base uint32) {
	C.gl4_2compat_glListBase(gl.funcs, C.GLuint(base))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGenLists.xml
func (gl *GL) GenLists(range_ int32) uint32 {
	result := C.gl4_2compat_glGenLists(gl.funcs, C.GLsizei(range_))
	return uint32(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteLists.xml
func (gl *GL) DeleteLists(list uint32, range_ int32) {
	C.gl4_2compat_glDeleteLists(gl.funcs, C.GLuint(list), C.GLsizei(range_))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCallLists.xml
func (gl *GL) CallLists(n int32, gltype glbase.Enum, lists interface{}) {
	lists_v := reflect.ValueOf(lists)
	if lists_v.Kind() != reflect.Slice {
		panic("parameter lists must be a slice")
	}
	C.gl4_2compat_glCallLists(gl.funcs, C.GLsizei(n), C.GLenum(gltype), unsafe.Pointer(lists_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCallList.xml
func (gl *GL) CallList(list uint32) {
	C.gl4_2compat_glCallList(gl.funcs, C.GLuint(list))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEndList.xml
func (gl *GL) EndList() {
	C.gl4_2compat_glEndList(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glNewList.xml
func (gl *GL) NewList(list uint32, mode glbase.Enum) {
	C.gl4_2compat_glNewList(gl.funcs, C.GLuint(list), C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPushClientAttrib.xml
func (gl *GL) PushClientAttrib(mask glbase.Bitfield) {
	C.gl4_2compat_glPushClientAttrib(gl.funcs, C.GLbitfield(mask))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPopClientAttrib.xml
func (gl *GL) PopClientAttrib() {
	C.gl4_2compat_glPopClientAttrib(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPrioritizeTextures.xml
func (gl *GL) PrioritizeTextures(n int32, textures []uint32, priorities []float32) {
	C.gl4_2compat_glPrioritizeTextures(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&textures[0])), (*C.GLfloat)(unsafe.Pointer(&priorities[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glAreTexturesResident.xml
func (gl *GL) AreTexturesResident(n int32, textures []uint32, residences []bool) bool {
	result := C.gl4_2compat_glAreTexturesResident(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&textures[0])), (*C.GLboolean)(unsafe.Pointer(&residences[0])))
	return *(*bool)(unsafe.Pointer(&result))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexPointer.xml
func (gl *GL) VertexPointer(size int32, gltype glbase.Enum, stride int32, pointer interface{}) {
	pointer_v := reflect.ValueOf(pointer)
	if pointer_v.Kind() != reflect.Slice {
		panic("parameter pointer must be a slice")
	}
	C.gl4_2compat_glVertexPointer(gl.funcs, C.GLint(size), C.GLenum(gltype), C.GLsizei(stride), unsafe.Pointer(pointer_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexCoordPointer.xml
func (gl *GL) TexCoordPointer(size int32, gltype glbase.Enum, stride int32, pointer interface{}) {
	pointer_v := reflect.ValueOf(pointer)
	if pointer_v.Kind() != reflect.Slice {
		panic("parameter pointer must be a slice")
	}
	C.gl4_2compat_glTexCoordPointer(gl.funcs, C.GLint(size), C.GLenum(gltype), C.GLsizei(stride), unsafe.Pointer(pointer_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glNormalPointer.xml
func (gl *GL) NormalPointer(gltype glbase.Enum, stride int32, pointer interface{}) {
	pointer_v := reflect.ValueOf(pointer)
	if pointer_v.Kind() != reflect.Slice {
		panic("parameter pointer must be a slice")
	}
	C.gl4_2compat_glNormalPointer(gl.funcs, C.GLenum(gltype), C.GLsizei(stride), unsafe.Pointer(pointer_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glInterleavedArrays.xml
func (gl *GL) InterleavedArrays(format glbase.Enum, stride int32, pointer interface{}) {
	pointer_v := reflect.ValueOf(pointer)
	if pointer_v.Kind() != reflect.Slice {
		panic("parameter pointer must be a slice")
	}
	C.gl4_2compat_glInterleavedArrays(gl.funcs, C.GLenum(format), C.GLsizei(stride), unsafe.Pointer(pointer_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIndexPointer.xml
func (gl *GL) IndexPointer(gltype glbase.Enum, stride int32, pointer interface{}) {
	pointer_v := reflect.ValueOf(pointer)
	if pointer_v.Kind() != reflect.Slice {
		panic("parameter pointer must be a slice")
	}
	C.gl4_2compat_glIndexPointer(gl.funcs, C.GLenum(gltype), C.GLsizei(stride), unsafe.Pointer(pointer_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEnableClientState.xml
func (gl *GL) EnableClientState(array glbase.Enum) {
	C.gl4_2compat_glEnableClientState(gl.funcs, C.GLenum(array))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEdgeFlagPointer.xml
func (gl *GL) EdgeFlagPointer(stride int32, pointer interface{}) {
	pointer_v := reflect.ValueOf(pointer)
	if pointer_v.Kind() != reflect.Slice {
		panic("parameter pointer must be a slice")
	}
	C.gl4_2compat_glEdgeFlagPointer(gl.funcs, C.GLsizei(stride), unsafe.Pointer(pointer_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDisableClientState.xml
func (gl *GL) DisableClientState(array glbase.Enum) {
	C.gl4_2compat_glDisableClientState(gl.funcs, C.GLenum(array))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColorPointer.xml
func (gl *GL) ColorPointer(size int32, gltype glbase.Enum, stride int32, pointer interface{}) {
	pointer_v := reflect.ValueOf(pointer)
	if pointer_v.Kind() != reflect.Slice {
		panic("parameter pointer must be a slice")
	}
	C.gl4_2compat_glColorPointer(gl.funcs, C.GLint(size), C.GLenum(gltype), C.GLsizei(stride), unsafe.Pointer(pointer_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glArrayElement.xml
func (gl *GL) ArrayElement(i int32) {
	C.gl4_2compat_glArrayElement(gl.funcs, C.GLint(i))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glResetMinmax.xml
func (gl *GL) ResetMinmax(target glbase.Enum) {
	C.gl4_2compat_glResetMinmax(gl.funcs, C.GLenum(target))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glResetHistogram.xml
func (gl *GL) ResetHistogram(target glbase.Enum) {
	C.gl4_2compat_glResetHistogram(gl.funcs, C.GLenum(target))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMinmax.xml
func (gl *GL) Minmax(target, internalformat glbase.Enum, sink bool) {
	C.gl4_2compat_glMinmax(gl.funcs, C.GLenum(target), C.GLenum(internalformat), *(*C.GLboolean)(unsafe.Pointer(&sink)))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glHistogram.xml
func (gl *GL) Histogram(target glbase.Enum, width int32, internalformat glbase.Enum, sink bool) {
	C.gl4_2compat_glHistogram(gl.funcs, C.GLenum(target), C.GLsizei(width), C.GLenum(internalformat), *(*C.GLboolean)(unsafe.Pointer(&sink)))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetMinmaxParameteriv.xml
func (gl *GL) GetMinmaxParameteriv(target, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetMinmaxParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetMinmaxParameterfv.xml
func (gl *GL) GetMinmaxParameterfv(target, pname glbase.Enum, params []float32) {
	C.gl4_2compat_glGetMinmaxParameterfv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetMinmax.xml
func (gl *GL) GetMinmax(target glbase.Enum, reset bool, format, gltype glbase.Enum, values interface{}) {
	values_v := reflect.ValueOf(values)
	if values_v.Kind() != reflect.Slice {
		panic("parameter values must be a slice")
	}
	C.gl4_2compat_glGetMinmax(gl.funcs, C.GLenum(target), *(*C.GLboolean)(unsafe.Pointer(&reset)), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(values_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetHistogramParameteriv.xml
func (gl *GL) GetHistogramParameteriv(target, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetHistogramParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetHistogramParameterfv.xml
func (gl *GL) GetHistogramParameterfv(target, pname glbase.Enum, params []float32) {
	C.gl4_2compat_glGetHistogramParameterfv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetHistogram.xml
func (gl *GL) GetHistogram(target glbase.Enum, reset bool, format, gltype glbase.Enum, values interface{}) {
	values_v := reflect.ValueOf(values)
	if values_v.Kind() != reflect.Slice {
		panic("parameter values must be a slice")
	}
	C.gl4_2compat_glGetHistogram(gl.funcs, C.GLenum(target), *(*C.GLboolean)(unsafe.Pointer(&reset)), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(values_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSeparableFilter2D.xml
func (gl *GL) SeparableFilter2D(target, internalformat glbase.Enum, width, height int32, format, gltype glbase.Enum, row, column interface{}) {
	row_v := reflect.ValueOf(row)
	if row_v.Kind() != reflect.Slice {
		panic("parameter row must be a slice")
	}
	column_v := reflect.ValueOf(column)
	if column_v.Kind() != reflect.Slice {
		panic("parameter column must be a slice")
	}
	C.gl4_2compat_glSeparableFilter2D(gl.funcs, C.GLenum(target), C.GLenum(internalformat), C.GLsizei(width), C.GLsizei(height), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(row_v.Index(0).Addr().Pointer()), unsafe.Pointer(column_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetSeparableFilter.xml
func (gl *GL) GetSeparableFilter(target, format, gltype glbase.Enum, row, column, span interface{}) {
	row_v := reflect.ValueOf(row)
	if row_v.Kind() != reflect.Slice {
		panic("parameter row must be a slice")
	}
	column_v := reflect.ValueOf(column)
	if column_v.Kind() != reflect.Slice {
		panic("parameter column must be a slice")
	}
	span_v := reflect.ValueOf(span)
	if span_v.Kind() != reflect.Slice {
		panic("parameter span must be a slice")
	}
	C.gl4_2compat_glGetSeparableFilter(gl.funcs, C.GLenum(target), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(row_v.Index(0).Addr().Pointer()), unsafe.Pointer(column_v.Index(0).Addr().Pointer()), unsafe.Pointer(span_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetConvolutionParameteriv.xml
func (gl *GL) GetConvolutionParameteriv(target, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetConvolutionParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetConvolutionParameterfv.xml
func (gl *GL) GetConvolutionParameterfv(target, pname glbase.Enum, params []float32) {
	C.gl4_2compat_glGetConvolutionParameterfv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetConvolutionFilter.xml
func (gl *GL) GetConvolutionFilter(target, format, gltype glbase.Enum, image interface{}) {
	image_v := reflect.ValueOf(image)
	if image_v.Kind() != reflect.Slice {
		panic("parameter image must be a slice")
	}
	C.gl4_2compat_glGetConvolutionFilter(gl.funcs, C.GLenum(target), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(image_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCopyConvolutionFilter2D.xml
func (gl *GL) CopyConvolutionFilter2D(target, internalformat glbase.Enum, x, y, width, height int32) {
	C.gl4_2compat_glCopyConvolutionFilter2D(gl.funcs, C.GLenum(target), C.GLenum(internalformat), C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCopyConvolutionFilter1D.xml
func (gl *GL) CopyConvolutionFilter1D(target, internalformat glbase.Enum, x, y, width int32) {
	C.gl4_2compat_glCopyConvolutionFilter1D(gl.funcs, C.GLenum(target), C.GLenum(internalformat), C.GLint(x), C.GLint(y), C.GLsizei(width))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glConvolutionParameteriv.xml
func (gl *GL) ConvolutionParameteriv(target, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glConvolutionParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glConvolutionParameteri.xml
func (gl *GL) ConvolutionParameteri(target, pname glbase.Enum, params int32) {
	C.gl4_2compat_glConvolutionParameteri(gl.funcs, C.GLenum(target), C.GLenum(pname), C.GLint(params))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glConvolutionParameterfv.xml
func (gl *GL) ConvolutionParameterfv(target, pname glbase.Enum, params []float32) {
	C.gl4_2compat_glConvolutionParameterfv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glConvolutionParameterf.xml
func (gl *GL) ConvolutionParameterf(target, pname glbase.Enum, params float32) {
	C.gl4_2compat_glConvolutionParameterf(gl.funcs, C.GLenum(target), C.GLenum(pname), C.GLfloat(params))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glConvolutionFilter2D.xml
func (gl *GL) ConvolutionFilter2D(target, internalformat glbase.Enum, width, height int32, format, gltype glbase.Enum, image interface{}) {
	image_v := reflect.ValueOf(image)
	if image_v.Kind() != reflect.Slice {
		panic("parameter image must be a slice")
	}
	C.gl4_2compat_glConvolutionFilter2D(gl.funcs, C.GLenum(target), C.GLenum(internalformat), C.GLsizei(width), C.GLsizei(height), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(image_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glConvolutionFilter1D.xml
func (gl *GL) ConvolutionFilter1D(target, internalformat glbase.Enum, width int32, format, gltype glbase.Enum, image interface{}) {
	image_v := reflect.ValueOf(image)
	if image_v.Kind() != reflect.Slice {
		panic("parameter image must be a slice")
	}
	C.gl4_2compat_glConvolutionFilter1D(gl.funcs, C.GLenum(target), C.GLenum(internalformat), C.GLsizei(width), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(image_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCopyColorSubTable.xml
func (gl *GL) CopyColorSubTable(target glbase.Enum, start, x, y, width int32) {
	C.gl4_2compat_glCopyColorSubTable(gl.funcs, C.GLenum(target), C.GLsizei(start), C.GLint(x), C.GLint(y), C.GLsizei(width))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColorSubTable.xml
func (gl *GL) ColorSubTable(target glbase.Enum, start, count int32, format, gltype glbase.Enum, data interface{}) {
	data_v := reflect.ValueOf(data)
	if data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	C.gl4_2compat_glColorSubTable(gl.funcs, C.GLenum(target), C.GLsizei(start), C.GLsizei(count), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(data_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetColorTableParameteriv.xml
func (gl *GL) GetColorTableParameteriv(target, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glGetColorTableParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetColorTableParameterfv.xml
func (gl *GL) GetColorTableParameterfv(target, pname glbase.Enum, params []float32) {
	C.gl4_2compat_glGetColorTableParameterfv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetColorTable.xml
func (gl *GL) GetColorTable(target, format, gltype glbase.Enum, table interface{}) {
	table_v := reflect.ValueOf(table)
	if table_v.Kind() != reflect.Slice {
		panic("parameter table must be a slice")
	}
	C.gl4_2compat_glGetColorTable(gl.funcs, C.GLenum(target), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(table_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCopyColorTable.xml
func (gl *GL) CopyColorTable(target, internalformat glbase.Enum, x, y, width int32) {
	C.gl4_2compat_glCopyColorTable(gl.funcs, C.GLenum(target), C.GLenum(internalformat), C.GLint(x), C.GLint(y), C.GLsizei(width))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColorTableParameteriv.xml
func (gl *GL) ColorTableParameteriv(target, pname glbase.Enum, params []int32) {
	C.gl4_2compat_glColorTableParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColorTableParameterfv.xml
func (gl *GL) ColorTableParameterfv(target, pname glbase.Enum, params []float32) {
	C.gl4_2compat_glColorTableParameterfv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColorTable.xml
func (gl *GL) ColorTable(target, internalformat glbase.Enum, width int32, format, gltype glbase.Enum, table interface{}) {
	table_v := reflect.ValueOf(table)
	if table_v.Kind() != reflect.Slice {
		panic("parameter table must be a slice")
	}
	C.gl4_2compat_glColorTable(gl.funcs, C.GLenum(target), C.GLenum(internalformat), C.GLsizei(width), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(table_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultTransposeMatrixd.xml
func (gl *GL) MultTransposeMatrixd(m []float64) {
	C.gl4_2compat_glMultTransposeMatrixd(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&m[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultTransposeMatrixf.xml
func (gl *GL) MultTransposeMatrixf(m []float32) {
	C.gl4_2compat_glMultTransposeMatrixf(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&m[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glLoadTransposeMatrixd.xml
func (gl *GL) LoadTransposeMatrixd(m []float64) {
	C.gl4_2compat_glLoadTransposeMatrixd(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&m[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glLoadTransposeMatrixf.xml
func (gl *GL) LoadTransposeMatrixf(m []float32) {
	C.gl4_2compat_glLoadTransposeMatrixf(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&m[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord4sv.xml
func (gl *GL) MultiTexCoord4sv(target glbase.Enum, v []int16) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glMultiTexCoord4sv(gl.funcs, C.GLenum(target), (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord4s.xml
func (gl *GL) MultiTexCoord4s(target glbase.Enum, s, t, r, q int16) {
	C.gl4_2compat_glMultiTexCoord4s(gl.funcs, C.GLenum(target), C.GLshort(s), C.GLshort(t), C.GLshort(r), C.GLshort(q))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord4iv.xml
func (gl *GL) MultiTexCoord4iv(target glbase.Enum, v []int32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glMultiTexCoord4iv(gl.funcs, C.GLenum(target), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord4i.xml
func (gl *GL) MultiTexCoord4i(target glbase.Enum, s, t, r, q int32) {
	C.gl4_2compat_glMultiTexCoord4i(gl.funcs, C.GLenum(target), C.GLint(s), C.GLint(t), C.GLint(r), C.GLint(q))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord4fv.xml
func (gl *GL) MultiTexCoord4fv(target glbase.Enum, v []float32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glMultiTexCoord4fv(gl.funcs, C.GLenum(target), (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord4f.xml
func (gl *GL) MultiTexCoord4f(target glbase.Enum, s, t, r, q float32) {
	C.gl4_2compat_glMultiTexCoord4f(gl.funcs, C.GLenum(target), C.GLfloat(s), C.GLfloat(t), C.GLfloat(r), C.GLfloat(q))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord4dv.xml
func (gl *GL) MultiTexCoord4dv(target glbase.Enum, v []float64) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glMultiTexCoord4dv(gl.funcs, C.GLenum(target), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord4d.xml
func (gl *GL) MultiTexCoord4d(target glbase.Enum, s, t, r, q float64) {
	C.gl4_2compat_glMultiTexCoord4d(gl.funcs, C.GLenum(target), C.GLdouble(s), C.GLdouble(t), C.GLdouble(r), C.GLdouble(q))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord3sv.xml
func (gl *GL) MultiTexCoord3sv(target glbase.Enum, v []int16) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glMultiTexCoord3sv(gl.funcs, C.GLenum(target), (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord3s.xml
func (gl *GL) MultiTexCoord3s(target glbase.Enum, s, t, r int16) {
	C.gl4_2compat_glMultiTexCoord3s(gl.funcs, C.GLenum(target), C.GLshort(s), C.GLshort(t), C.GLshort(r))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord3iv.xml
func (gl *GL) MultiTexCoord3iv(target glbase.Enum, v []int32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glMultiTexCoord3iv(gl.funcs, C.GLenum(target), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord3i.xml
func (gl *GL) MultiTexCoord3i(target glbase.Enum, s, t, r int32) {
	C.gl4_2compat_glMultiTexCoord3i(gl.funcs, C.GLenum(target), C.GLint(s), C.GLint(t), C.GLint(r))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord3fv.xml
func (gl *GL) MultiTexCoord3fv(target glbase.Enum, v []float32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glMultiTexCoord3fv(gl.funcs, C.GLenum(target), (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord3f.xml
func (gl *GL) MultiTexCoord3f(target glbase.Enum, s, t, r float32) {
	C.gl4_2compat_glMultiTexCoord3f(gl.funcs, C.GLenum(target), C.GLfloat(s), C.GLfloat(t), C.GLfloat(r))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord3dv.xml
func (gl *GL) MultiTexCoord3dv(target glbase.Enum, v []float64) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glMultiTexCoord3dv(gl.funcs, C.GLenum(target), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord3d.xml
func (gl *GL) MultiTexCoord3d(target glbase.Enum, s, t, r float64) {
	C.gl4_2compat_glMultiTexCoord3d(gl.funcs, C.GLenum(target), C.GLdouble(s), C.GLdouble(t), C.GLdouble(r))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord2sv.xml
func (gl *GL) MultiTexCoord2sv(target glbase.Enum, v []int16) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glMultiTexCoord2sv(gl.funcs, C.GLenum(target), (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord2s.xml
func (gl *GL) MultiTexCoord2s(target glbase.Enum, s, t int16) {
	C.gl4_2compat_glMultiTexCoord2s(gl.funcs, C.GLenum(target), C.GLshort(s), C.GLshort(t))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord2iv.xml
func (gl *GL) MultiTexCoord2iv(target glbase.Enum, v []int32) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glMultiTexCoord2iv(gl.funcs, C.GLenum(target), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord2i.xml
func (gl *GL) MultiTexCoord2i(target glbase.Enum, s, t int32) {
	C.gl4_2compat_glMultiTexCoord2i(gl.funcs, C.GLenum(target), C.GLint(s), C.GLint(t))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord2fv.xml
func (gl *GL) MultiTexCoord2fv(target glbase.Enum, v []float32) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glMultiTexCoord2fv(gl.funcs, C.GLenum(target), (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord2f.xml
func (gl *GL) MultiTexCoord2f(target glbase.Enum, s, t float32) {
	C.gl4_2compat_glMultiTexCoord2f(gl.funcs, C.GLenum(target), C.GLfloat(s), C.GLfloat(t))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord2dv.xml
func (gl *GL) MultiTexCoord2dv(target glbase.Enum, v []float64) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glMultiTexCoord2dv(gl.funcs, C.GLenum(target), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord2d.xml
func (gl *GL) MultiTexCoord2d(target glbase.Enum, s, t float64) {
	C.gl4_2compat_glMultiTexCoord2d(gl.funcs, C.GLenum(target), C.GLdouble(s), C.GLdouble(t))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord1sv.xml
func (gl *GL) MultiTexCoord1sv(target glbase.Enum, v []int16) {
	C.gl4_2compat_glMultiTexCoord1sv(gl.funcs, C.GLenum(target), (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord1s.xml
func (gl *GL) MultiTexCoord1s(target glbase.Enum, s int16) {
	C.gl4_2compat_glMultiTexCoord1s(gl.funcs, C.GLenum(target), C.GLshort(s))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord1iv.xml
func (gl *GL) MultiTexCoord1iv(target glbase.Enum, v []int32) {
	C.gl4_2compat_glMultiTexCoord1iv(gl.funcs, C.GLenum(target), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord1i.xml
func (gl *GL) MultiTexCoord1i(target glbase.Enum, s int32) {
	C.gl4_2compat_glMultiTexCoord1i(gl.funcs, C.GLenum(target), C.GLint(s))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord1fv.xml
func (gl *GL) MultiTexCoord1fv(target glbase.Enum, v []float32) {
	C.gl4_2compat_glMultiTexCoord1fv(gl.funcs, C.GLenum(target), (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord1f.xml
func (gl *GL) MultiTexCoord1f(target glbase.Enum, s float32) {
	C.gl4_2compat_glMultiTexCoord1f(gl.funcs, C.GLenum(target), C.GLfloat(s))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord1dv.xml
func (gl *GL) MultiTexCoord1dv(target glbase.Enum, v []float64) {
	C.gl4_2compat_glMultiTexCoord1dv(gl.funcs, C.GLenum(target), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glMultiTexCoord1d.xml
func (gl *GL) MultiTexCoord1d(target glbase.Enum, s float64) {
	C.gl4_2compat_glMultiTexCoord1d(gl.funcs, C.GLenum(target), C.GLdouble(s))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClientActiveTexture.xml
func (gl *GL) ClientActiveTexture(texture glbase.Enum) {
	C.gl4_2compat_glClientActiveTexture(gl.funcs, C.GLenum(texture))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glWindowPos3sv.xml
func (gl *GL) WindowPos3sv(v []int16) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glWindowPos3sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glWindowPos3s.xml
func (gl *GL) WindowPos3s(x, y, z int16) {
	C.gl4_2compat_glWindowPos3s(gl.funcs, C.GLshort(x), C.GLshort(y), C.GLshort(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glWindowPos3iv.xml
func (gl *GL) WindowPos3iv(v []int32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glWindowPos3iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glWindowPos3i.xml
func (gl *GL) WindowPos3i(x, y, z int32) {
	C.gl4_2compat_glWindowPos3i(gl.funcs, C.GLint(x), C.GLint(y), C.GLint(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glWindowPos3fv.xml
func (gl *GL) WindowPos3fv(v []float32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glWindowPos3fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glWindowPos3f.xml
func (gl *GL) WindowPos3f(x, y, z float32) {
	C.gl4_2compat_glWindowPos3f(gl.funcs, C.GLfloat(x), C.GLfloat(y), C.GLfloat(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glWindowPos3dv.xml
func (gl *GL) WindowPos3dv(v []float64) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glWindowPos3dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glWindowPos3d.xml
func (gl *GL) WindowPos3d(x, y, z float64) {
	C.gl4_2compat_glWindowPos3d(gl.funcs, C.GLdouble(x), C.GLdouble(y), C.GLdouble(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glWindowPos2sv.xml
func (gl *GL) WindowPos2sv(v []int16) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glWindowPos2sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glWindowPos2s.xml
func (gl *GL) WindowPos2s(x, y int16) {
	C.gl4_2compat_glWindowPos2s(gl.funcs, C.GLshort(x), C.GLshort(y))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glWindowPos2iv.xml
func (gl *GL) WindowPos2iv(v []int32) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glWindowPos2iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glWindowPos2i.xml
func (gl *GL) WindowPos2i(x, y int32) {
	C.gl4_2compat_glWindowPos2i(gl.funcs, C.GLint(x), C.GLint(y))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glWindowPos2fv.xml
func (gl *GL) WindowPos2fv(v []float32) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glWindowPos2fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glWindowPos2f.xml
func (gl *GL) WindowPos2f(x, y float32) {
	C.gl4_2compat_glWindowPos2f(gl.funcs, C.GLfloat(x), C.GLfloat(y))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glWindowPos2dv.xml
func (gl *GL) WindowPos2dv(v []float64) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glWindowPos2dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glWindowPos2d.xml
func (gl *GL) WindowPos2d(x, y float64) {
	C.gl4_2compat_glWindowPos2d(gl.funcs, C.GLdouble(x), C.GLdouble(y))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSecondaryColorPointer.xml
func (gl *GL) SecondaryColorPointer(size int32, gltype glbase.Enum, stride int32, pointer interface{}) {
	pointer_v := reflect.ValueOf(pointer)
	if pointer_v.Kind() != reflect.Slice {
		panic("parameter pointer must be a slice")
	}
	C.gl4_2compat_glSecondaryColorPointer(gl.funcs, C.GLint(size), C.GLenum(gltype), C.GLsizei(stride), unsafe.Pointer(pointer_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSecondaryColor3usv.xml
func (gl *GL) SecondaryColor3usv(v []uint16) {
	C.gl4_2compat_glSecondaryColor3usv(gl.funcs, (*C.GLushort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSecondaryColor3us.xml
func (gl *GL) SecondaryColor3us(red, green, blue uint16) {
	C.gl4_2compat_glSecondaryColor3us(gl.funcs, C.GLushort(red), C.GLushort(green), C.GLushort(blue))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSecondaryColor3uiv.xml
func (gl *GL) SecondaryColor3uiv(v []uint32) {
	C.gl4_2compat_glSecondaryColor3uiv(gl.funcs, (*C.GLuint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSecondaryColor3ui.xml
func (gl *GL) SecondaryColor3ui(red, green, blue uint32) {
	C.gl4_2compat_glSecondaryColor3ui(gl.funcs, C.GLuint(red), C.GLuint(green), C.GLuint(blue))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSecondaryColor3ubv.xml
func (gl *GL) SecondaryColor3ubv(v []uint8) {
	C.gl4_2compat_glSecondaryColor3ubv(gl.funcs, (*C.GLubyte)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSecondaryColor3ub.xml
func (gl *GL) SecondaryColor3ub(red, green, blue uint8) {
	C.gl4_2compat_glSecondaryColor3ub(gl.funcs, C.GLubyte(red), C.GLubyte(green), C.GLubyte(blue))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSecondaryColor3sv.xml
func (gl *GL) SecondaryColor3sv(v []int16) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glSecondaryColor3sv(gl.funcs, (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSecondaryColor3s.xml
func (gl *GL) SecondaryColor3s(red, green, blue int16) {
	C.gl4_2compat_glSecondaryColor3s(gl.funcs, C.GLshort(red), C.GLshort(green), C.GLshort(blue))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSecondaryColor3iv.xml
func (gl *GL) SecondaryColor3iv(v []int32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glSecondaryColor3iv(gl.funcs, (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSecondaryColor3i.xml
func (gl *GL) SecondaryColor3i(red, green, blue int32) {
	C.gl4_2compat_glSecondaryColor3i(gl.funcs, C.GLint(red), C.GLint(green), C.GLint(blue))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSecondaryColor3fv.xml
func (gl *GL) SecondaryColor3fv(v []float32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glSecondaryColor3fv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSecondaryColor3f.xml
func (gl *GL) SecondaryColor3f(red, green, blue float32) {
	C.gl4_2compat_glSecondaryColor3f(gl.funcs, C.GLfloat(red), C.GLfloat(green), C.GLfloat(blue))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSecondaryColor3dv.xml
func (gl *GL) SecondaryColor3dv(v []float64) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glSecondaryColor3dv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSecondaryColor3d.xml
func (gl *GL) SecondaryColor3d(red, green, blue float64) {
	C.gl4_2compat_glSecondaryColor3d(gl.funcs, C.GLdouble(red), C.GLdouble(green), C.GLdouble(blue))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSecondaryColor3bv.xml
func (gl *GL) SecondaryColor3bv(v []byte) {
	C.gl4_2compat_glSecondaryColor3bv(gl.funcs, (*C.GLbyte)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSecondaryColor3b.xml
func (gl *GL) SecondaryColor3b(red, green, blue byte) {
	C.gl4_2compat_glSecondaryColor3b(gl.funcs, C.GLbyte(red), C.GLbyte(green), C.GLbyte(blue))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFogCoordPointer.xml
func (gl *GL) FogCoordPointer(gltype glbase.Enum, stride int32, pointer interface{}) {
	pointer_v := reflect.ValueOf(pointer)
	if pointer_v.Kind() != reflect.Slice {
		panic("parameter pointer must be a slice")
	}
	C.gl4_2compat_glFogCoordPointer(gl.funcs, C.GLenum(gltype), C.GLsizei(stride), unsafe.Pointer(pointer_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFogCoorddv.xml
func (gl *GL) FogCoorddv(coord []float64) {
	C.gl4_2compat_glFogCoorddv(gl.funcs, (*C.GLdouble)(unsafe.Pointer(&coord[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFogCoordd.xml
func (gl *GL) FogCoordd(coord float64) {
	C.gl4_2compat_glFogCoordd(gl.funcs, C.GLdouble(coord))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFogCoordfv.xml
func (gl *GL) FogCoordfv(coord []float32) {
	C.gl4_2compat_glFogCoordfv(gl.funcs, (*C.GLfloat)(unsafe.Pointer(&coord[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFogCoordf.xml
func (gl *GL) FogCoordf(coord float32) {
	C.gl4_2compat_glFogCoordf(gl.funcs, C.GLfloat(coord))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib4usv.xml
func (gl *GL) VertexAttrib4usv(index glbase.Attrib, v []uint16) {
	C.gl4_2compat_glVertexAttrib4usv(gl.funcs, C.GLuint(index), (*C.GLushort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib4uiv.xml
func (gl *GL) VertexAttrib4uiv(index glbase.Attrib, v []uint32) {
	C.gl4_2compat_glVertexAttrib4uiv(gl.funcs, C.GLuint(index), (*C.GLuint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib4ubv.xml
func (gl *GL) VertexAttrib4ubv(index glbase.Attrib, v []uint8) {
	C.gl4_2compat_glVertexAttrib4ubv(gl.funcs, C.GLuint(index), (*C.GLubyte)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib4sv.xml
func (gl *GL) VertexAttrib4sv(index glbase.Attrib, v []int16) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertexAttrib4sv(gl.funcs, C.GLuint(index), (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib4s.xml
func (gl *GL) VertexAttrib4s(index glbase.Attrib, x, y, z, w int16) {
	C.gl4_2compat_glVertexAttrib4s(gl.funcs, C.GLuint(index), C.GLshort(x), C.GLshort(y), C.GLshort(z), C.GLshort(w))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib4iv.xml
func (gl *GL) VertexAttrib4iv(index glbase.Attrib, v []int32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertexAttrib4iv(gl.funcs, C.GLuint(index), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib4fv.xml
func (gl *GL) VertexAttrib4fv(index glbase.Attrib, v []float32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertexAttrib4fv(gl.funcs, C.GLuint(index), (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib4f.xml
func (gl *GL) VertexAttrib4f(index glbase.Attrib, x, y, z, w float32) {
	C.gl4_2compat_glVertexAttrib4f(gl.funcs, C.GLuint(index), C.GLfloat(x), C.GLfloat(y), C.GLfloat(z), C.GLfloat(w))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib4dv.xml
func (gl *GL) VertexAttrib4dv(index glbase.Attrib, v []float64) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertexAttrib4dv(gl.funcs, C.GLuint(index), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib4d.xml
func (gl *GL) VertexAttrib4d(index glbase.Attrib, x, y, z, w float64) {
	C.gl4_2compat_glVertexAttrib4d(gl.funcs, C.GLuint(index), C.GLdouble(x), C.GLdouble(y), C.GLdouble(z), C.GLdouble(w))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib4bv.xml
func (gl *GL) VertexAttrib4bv(index glbase.Attrib, v []byte) {
	C.gl4_2compat_glVertexAttrib4bv(gl.funcs, C.GLuint(index), (*C.GLbyte)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib4Nusv.xml
func (gl *GL) VertexAttrib4Nusv(index glbase.Attrib, v []uint16) {
	C.gl4_2compat_glVertexAttrib4Nusv(gl.funcs, C.GLuint(index), (*C.GLushort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib4Nuiv.xml
func (gl *GL) VertexAttrib4Nuiv(index glbase.Attrib, v []uint32) {
	C.gl4_2compat_glVertexAttrib4Nuiv(gl.funcs, C.GLuint(index), (*C.GLuint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib4Nubv.xml
func (gl *GL) VertexAttrib4Nubv(index glbase.Attrib, v []uint8) {
	C.gl4_2compat_glVertexAttrib4Nubv(gl.funcs, C.GLuint(index), (*C.GLubyte)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib4Nub.xml
func (gl *GL) VertexAttrib4Nub(index glbase.Attrib, x, y, z, w uint8) {
	C.gl4_2compat_glVertexAttrib4Nub(gl.funcs, C.GLuint(index), C.GLubyte(x), C.GLubyte(y), C.GLubyte(z), C.GLubyte(w))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib4Nsv.xml
func (gl *GL) VertexAttrib4Nsv(index glbase.Attrib, v []int16) {
	C.gl4_2compat_glVertexAttrib4Nsv(gl.funcs, C.GLuint(index), (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib4Niv.xml
func (gl *GL) VertexAttrib4Niv(index glbase.Attrib, v []int32) {
	C.gl4_2compat_glVertexAttrib4Niv(gl.funcs, C.GLuint(index), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib4Nbv.xml
func (gl *GL) VertexAttrib4Nbv(index glbase.Attrib, v []byte) {
	C.gl4_2compat_glVertexAttrib4Nbv(gl.funcs, C.GLuint(index), (*C.GLbyte)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib3sv.xml
func (gl *GL) VertexAttrib3sv(index glbase.Attrib, v []int16) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertexAttrib3sv(gl.funcs, C.GLuint(index), (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib3s.xml
func (gl *GL) VertexAttrib3s(index glbase.Attrib, x, y, z int16) {
	C.gl4_2compat_glVertexAttrib3s(gl.funcs, C.GLuint(index), C.GLshort(x), C.GLshort(y), C.GLshort(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib3fv.xml
func (gl *GL) VertexAttrib3fv(index glbase.Attrib, v []float32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertexAttrib3fv(gl.funcs, C.GLuint(index), (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib3f.xml
func (gl *GL) VertexAttrib3f(index glbase.Attrib, x, y, z float32) {
	C.gl4_2compat_glVertexAttrib3f(gl.funcs, C.GLuint(index), C.GLfloat(x), C.GLfloat(y), C.GLfloat(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib3dv.xml
func (gl *GL) VertexAttrib3dv(index glbase.Attrib, v []float64) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertexAttrib3dv(gl.funcs, C.GLuint(index), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib3d.xml
func (gl *GL) VertexAttrib3d(index glbase.Attrib, x, y, z float64) {
	C.gl4_2compat_glVertexAttrib3d(gl.funcs, C.GLuint(index), C.GLdouble(x), C.GLdouble(y), C.GLdouble(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib2sv.xml
func (gl *GL) VertexAttrib2sv(index glbase.Attrib, v []int16) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertexAttrib2sv(gl.funcs, C.GLuint(index), (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib2s.xml
func (gl *GL) VertexAttrib2s(index glbase.Attrib, x, y int16) {
	C.gl4_2compat_glVertexAttrib2s(gl.funcs, C.GLuint(index), C.GLshort(x), C.GLshort(y))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib2fv.xml
func (gl *GL) VertexAttrib2fv(index glbase.Attrib, v []float32) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertexAttrib2fv(gl.funcs, C.GLuint(index), (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib2f.xml
func (gl *GL) VertexAttrib2f(index glbase.Attrib, x, y float32) {
	C.gl4_2compat_glVertexAttrib2f(gl.funcs, C.GLuint(index), C.GLfloat(x), C.GLfloat(y))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib2dv.xml
func (gl *GL) VertexAttrib2dv(index glbase.Attrib, v []float64) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertexAttrib2dv(gl.funcs, C.GLuint(index), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib2d.xml
func (gl *GL) VertexAttrib2d(index glbase.Attrib, x, y float64) {
	C.gl4_2compat_glVertexAttrib2d(gl.funcs, C.GLuint(index), C.GLdouble(x), C.GLdouble(y))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib1sv.xml
func (gl *GL) VertexAttrib1sv(index glbase.Attrib, v []int16) {
	C.gl4_2compat_glVertexAttrib1sv(gl.funcs, C.GLuint(index), (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib1s.xml
func (gl *GL) VertexAttrib1s(index glbase.Attrib, x int16) {
	C.gl4_2compat_glVertexAttrib1s(gl.funcs, C.GLuint(index), C.GLshort(x))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib1fv.xml
func (gl *GL) VertexAttrib1fv(index glbase.Attrib, v []float32) {
	C.gl4_2compat_glVertexAttrib1fv(gl.funcs, C.GLuint(index), (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib1f.xml
func (gl *GL) VertexAttrib1f(index glbase.Attrib, x float32) {
	C.gl4_2compat_glVertexAttrib1f(gl.funcs, C.GLuint(index), C.GLfloat(x))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib1dv.xml
func (gl *GL) VertexAttrib1dv(index glbase.Attrib, v []float64) {
	C.gl4_2compat_glVertexAttrib1dv(gl.funcs, C.GLuint(index), (*C.GLdouble)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib1d.xml
func (gl *GL) VertexAttrib1d(index glbase.Attrib, x float64) {
	C.gl4_2compat_glVertexAttrib1d(gl.funcs, C.GLuint(index), C.GLdouble(x))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribI4usv.xml
func (gl *GL) VertexAttribI4usv(index glbase.Attrib, v []uint16) {
	C.gl4_2compat_glVertexAttribI4usv(gl.funcs, C.GLuint(index), (*C.GLushort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribI4ubv.xml
func (gl *GL) VertexAttribI4ubv(index glbase.Attrib, v []uint8) {
	C.gl4_2compat_glVertexAttribI4ubv(gl.funcs, C.GLuint(index), (*C.GLubyte)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribI4sv.xml
func (gl *GL) VertexAttribI4sv(index glbase.Attrib, v []int16) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertexAttribI4sv(gl.funcs, C.GLuint(index), (*C.GLshort)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribI4bv.xml
func (gl *GL) VertexAttribI4bv(index glbase.Attrib, v []byte) {
	C.gl4_2compat_glVertexAttribI4bv(gl.funcs, C.GLuint(index), (*C.GLbyte)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribI4uiv.xml
func (gl *GL) VertexAttribI4uiv(index glbase.Attrib, v []uint32) {
	C.gl4_2compat_glVertexAttribI4uiv(gl.funcs, C.GLuint(index), (*C.GLuint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribI3uiv.xml
func (gl *GL) VertexAttribI3uiv(index glbase.Attrib, v []uint32) {
	C.gl4_2compat_glVertexAttribI3uiv(gl.funcs, C.GLuint(index), (*C.GLuint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribI2uiv.xml
func (gl *GL) VertexAttribI2uiv(index glbase.Attrib, v []uint32) {
	C.gl4_2compat_glVertexAttribI2uiv(gl.funcs, C.GLuint(index), (*C.GLuint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribI1uiv.xml
func (gl *GL) VertexAttribI1uiv(index glbase.Attrib, v []uint32) {
	C.gl4_2compat_glVertexAttribI1uiv(gl.funcs, C.GLuint(index), (*C.GLuint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribI4iv.xml
func (gl *GL) VertexAttribI4iv(index glbase.Attrib, v []int32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertexAttribI4iv(gl.funcs, C.GLuint(index), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribI3iv.xml
func (gl *GL) VertexAttribI3iv(index glbase.Attrib, v []int32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertexAttribI3iv(gl.funcs, C.GLuint(index), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribI2iv.xml
func (gl *GL) VertexAttribI2iv(index glbase.Attrib, v []int32) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gl4_2compat_glVertexAttribI2iv(gl.funcs, C.GLuint(index), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribI1iv.xml
func (gl *GL) VertexAttribI1iv(index glbase.Attrib, v []int32) {
	C.gl4_2compat_glVertexAttribI1iv(gl.funcs, C.GLuint(index), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribI4ui.xml
func (gl *GL) VertexAttribI4ui(index glbase.Attrib, x, y, z, w uint32) {
	C.gl4_2compat_glVertexAttribI4ui(gl.funcs, C.GLuint(index), C.GLuint(x), C.GLuint(y), C.GLuint(z), C.GLuint(w))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribI3ui.xml
func (gl *GL) VertexAttribI3ui(index glbase.Attrib, x, y, z uint32) {
	C.gl4_2compat_glVertexAttribI3ui(gl.funcs, C.GLuint(index), C.GLuint(x), C.GLuint(y), C.GLuint(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribI2ui.xml
func (gl *GL) VertexAttribI2ui(index glbase.Attrib, x, y uint32) {
	C.gl4_2compat_glVertexAttribI2ui(gl.funcs, C.GLuint(index), C.GLuint(x), C.GLuint(y))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribI1ui.xml
func (gl *GL) VertexAttribI1ui(index glbase.Attrib, x uint32) {
	C.gl4_2compat_glVertexAttribI1ui(gl.funcs, C.GLuint(index), C.GLuint(x))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribI4i.xml
func (gl *GL) VertexAttribI4i(index glbase.Attrib, x, y, z, w int32) {
	C.gl4_2compat_glVertexAttribI4i(gl.funcs, C.GLuint(index), C.GLint(x), C.GLint(y), C.GLint(z), C.GLint(w))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribI3i.xml
func (gl *GL) VertexAttribI3i(index glbase.Attrib, x, y, z int32) {
	C.gl4_2compat_glVertexAttribI3i(gl.funcs, C.GLuint(index), C.GLint(x), C.GLint(y), C.GLint(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribI2i.xml
func (gl *GL) VertexAttribI2i(index glbase.Attrib, x, y int32) {
	C.gl4_2compat_glVertexAttribI2i(gl.funcs, C.GLuint(index), C.GLint(x), C.GLint(y))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribI1i.xml
func (gl *GL) VertexAttribI1i(index glbase.Attrib, x int32) {
	C.gl4_2compat_glVertexAttribI1i(gl.funcs, C.GLuint(index), C.GLint(x))
}
