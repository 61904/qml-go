// ** file automatically generated by glgen -- do not edit manually **

package GL

// #cgo CXXFLAGS: -std=c++0x -pedantic-errors -Wall -fno-strict-aliasing
// #cgo LDFLAGS: -lstdc++
// #cgo !darwin LDFLAGS: -lGL
// #cgo  darwin LDFLAGS: -framework OpenGL
// #cgo pkg-config: Qt5Core Qt5OpenGL
//
// #include "funcs.h"
//
import "C"

import (
	"fmt"
	"reflect"
	"unsafe"

	"gopkg.in/qml.v1/gl/glbase"
)

// API returns a value that offers methods matching the OpenGL version ES2 API.
//
// The returned API must not be used after the provided OpenGL context becomes invalid.
func API(context glbase.Contexter) *GL {
	gl := &GL{}
	gl.funcs = C.gles2_funcs()
	if gl.funcs == nil {
		panic(fmt.Errorf("OpenGL version ES2 is not available"))
	}
	return gl
}

// GL implements the OpenGL version ES2 API. Values of this
// type must be created via the API function, and it must not be used after
// the associated OpenGL context becomes invalid.
type GL struct {
	funcs unsafe.Pointer
}

const (
	FALSE = 0
	TRUE  = 1
	NONE  = 0

	BYTE           = 0x1400
	UNSIGNED_BYTE  = 0x1401
	SHORT          = 0x1402
	UNSIGNED_SHORT = 0x1403
	INT            = 0x1404
	UNSIGNED_INT   = 0x1405
	FLOAT          = 0x1406
	FIXED          = 0x140C

	COLOR_BUFFER_BIT   = 0x00004000
	DEPTH_BUFFER_BIT   = 0x00000100
	STENCIL_BUFFER_BIT = 0x00000400

	ALWAYS   = 0x0207
	EQUAL    = 0x0202
	GEQUAL   = 0x0206
	GREATER  = 0x0204
	LEQUAL   = 0x0203
	LESS     = 0x0201
	NEVER    = 0x0200
	NOTEQUAL = 0x0205

	DST_ALPHA           = 0x0304
	ONE                 = 1
	ONE_MINUS_DST_ALPHA = 0x0305
	ONE_MINUS_SRC_ALPHA = 0x0303
	ONE_MINUS_SRC_COLOR = 0x0301
	SRC_ALPHA           = 0x0302
	SRC_COLOR           = 0x0300
	ZERO                = 0

	DST_COLOR           = 0x0306
	ONE_MINUS_DST_COLOR = 0x0307
	SRC_ALPHA_SATURATE  = 0x0308

	BACK           = 0x0405
	FRONT          = 0x0404
	FRONT_AND_BACK = 0x0408

	BLEND               = 0x0BE2
	CULL_FACE           = 0x0B44
	DEPTH_TEST          = 0x0B71
	DITHER              = 0x0BD0
	POLYGON_OFFSET_FILL = 0x8037
	SCISSOR_TEST        = 0x0C11
	STENCIL_TEST        = 0x0B90
	TEXTURE_2D          = 0x0DE1

	INVALID_ENUM                  = 0x0500
	INVALID_FRAMEBUFFER_OPERATION = 0x0506
	INVALID_OPERATION             = 0x0502
	INVALID_VALUE                 = 0x0501
	NO_ERROR                      = 0
	OUT_OF_MEMORY                 = 0x0505

	LINEAR = 0x2601

	CCW = 0x0901
	CW  = 0x0900

	ALIASED_LINE_WIDTH_RANGE = 0x846E
	ALIASED_POINT_SIZE_RANGE = 0x846D
	ALPHA_BITS               = 0x0D55
	BLUE_BITS                = 0x0D54
	COLOR_CLEAR_VALUE        = 0x0C22
	COLOR_WRITEMASK          = 0x0C23
	CULL_FACE_MODE           = 0x0B45
	DEPTH_BITS               = 0x0D56
	DEPTH_CLEAR_VALUE        = 0x0B73
	DEPTH_FUNC               = 0x0B74
	DEPTH_RANGE              = 0x0B70
	DEPTH_WRITEMASK          = 0x0B72
	FRONT_FACE               = 0x0B46
	GREEN_BITS               = 0x0D53
	LINE_WIDTH               = 0x0B21
	MAX_TEXTURE_SIZE         = 0x0D33
	MAX_VIEWPORT_DIMS        = 0x0D3A
	PACK_ALIGNMENT           = 0x0D05
	POLYGON_OFFSET_FACTOR    = 0x8038
	POLYGON_OFFSET_UNITS     = 0x2A00
	RED_BITS                 = 0x0D52
	SCISSOR_BOX              = 0x0C10
	STENCIL_BITS             = 0x0D57
	STENCIL_CLEAR_VALUE      = 0x0B91
	STENCIL_FAIL             = 0x0B94
	STENCIL_FUNC             = 0x0B92
	STENCIL_PASS_DEPTH_FAIL  = 0x0B95
	STENCIL_PASS_DEPTH_PASS  = 0x0B96
	STENCIL_REF              = 0x0B97
	STENCIL_VALUE_MASK       = 0x0B93
	STENCIL_WRITEMASK        = 0x0B98
	SUBPIXEL_BITS            = 0x0D50
	TEXTURE_BINDING_2D       = 0x8069
	UNPACK_ALIGNMENT         = 0x0CF5
	VIEWPORT                 = 0x0BA2

	TEXTURE_MAG_FILTER = 0x2800
	TEXTURE_MIN_FILTER = 0x2801
	TEXTURE_WRAP_S     = 0x2802
	TEXTURE_WRAP_T     = 0x2803

	DONT_CARE = 0x1100
	FASTEST   = 0x1101
	NICEST    = 0x1102

	GENERATE_MIPMAP_HINT = 0x8192

	REPLACE = 0x1E01

	INVERT = 0x150A

	TEXTURE = 0x1702

	ALPHA           = 0x1906
	DEPTH_COMPONENT = 0x1902
	LUMINANCE       = 0x1909
	LUMINANCE_ALPHA = 0x190A
	RGB             = 0x1907
	RGBA            = 0x1908

	RGB5_A1 = 0x8057
	RGBA4   = 0x8056

	UNSIGNED_SHORT_4_4_4_4 = 0x8033
	UNSIGNED_SHORT_5_5_5_1 = 0x8034

	LINES          = 0x0001
	LINE_LOOP      = 0x0002
	LINE_STRIP     = 0x0003
	POINTS         = 0x0000
	TRIANGLES      = 0x0004
	TRIANGLE_FAN   = 0x0006
	TRIANGLE_STRIP = 0x0005

	DECR = 0x1E03
	INCR = 0x1E02
	KEEP = 0x1E00

	EXTENSIONS = 0x1F03
	RENDERER   = 0x1F01
	VENDOR     = 0x1F00
	VERSION    = 0x1F02

	NEAREST = 0x2600

	LINEAR_MIPMAP_LINEAR   = 0x2703
	LINEAR_MIPMAP_NEAREST  = 0x2701
	NEAREST_MIPMAP_LINEAR  = 0x2702
	NEAREST_MIPMAP_NEAREST = 0x2700

	CLAMP_TO_EDGE = 0x812F
	REPEAT        = 0x2901

	CONSTANT_COLOR                               = 0x8001
	ONE_MINUS_CONSTANT_COLOR                     = 0x8002
	CONSTANT_ALPHA                               = 0x8003
	ONE_MINUS_CONSTANT_ALPHA                     = 0x8004
	BLEND_COLOR                                  = 0x8005
	FUNC_ADD                                     = 0x8006
	BLEND_EQUATION                               = 0x8009
	BLEND_EQUATION_RGB                           = 0x8009
	FUNC_SUBTRACT                                = 0x800A
	FUNC_REVERSE_SUBTRACT                        = 0x800B
	SAMPLE_ALPHA_TO_COVERAGE                     = 0x809E
	SAMPLE_COVERAGE                              = 0x80A0
	SAMPLE_BUFFERS                               = 0x80A8
	SAMPLES                                      = 0x80A9
	SAMPLE_COVERAGE_VALUE                        = 0x80AA
	SAMPLE_COVERAGE_INVERT                       = 0x80AB
	BLEND_DST_RGB                                = 0x80C8
	BLEND_SRC_RGB                                = 0x80C9
	BLEND_DST_ALPHA                              = 0x80CA
	BLEND_SRC_ALPHA                              = 0x80CB
	DEPTH_COMPONENT16                            = 0x81A5
	UNSIGNED_SHORT_5_6_5                         = 0x8363
	MIRRORED_REPEAT                              = 0x8370
	TEXTURE0                                     = 0x84C0
	TEXTURE1                                     = 0x84C1
	TEXTURE2                                     = 0x84C2
	TEXTURE3                                     = 0x84C3
	TEXTURE4                                     = 0x84C4
	TEXTURE5                                     = 0x84C5
	TEXTURE6                                     = 0x84C6
	TEXTURE7                                     = 0x84C7
	TEXTURE8                                     = 0x84C8
	TEXTURE9                                     = 0x84C9
	TEXTURE10                                    = 0x84CA
	TEXTURE11                                    = 0x84CB
	TEXTURE12                                    = 0x84CC
	TEXTURE13                                    = 0x84CD
	TEXTURE14                                    = 0x84CE
	TEXTURE15                                    = 0x84CF
	TEXTURE16                                    = 0x84D0
	TEXTURE17                                    = 0x84D1
	TEXTURE18                                    = 0x84D2
	TEXTURE19                                    = 0x84D3
	TEXTURE20                                    = 0x84D4
	TEXTURE21                                    = 0x84D5
	TEXTURE22                                    = 0x84D6
	TEXTURE23                                    = 0x84D7
	TEXTURE24                                    = 0x84D8
	TEXTURE25                                    = 0x84D9
	TEXTURE26                                    = 0x84DA
	TEXTURE27                                    = 0x84DB
	TEXTURE28                                    = 0x84DC
	TEXTURE29                                    = 0x84DD
	TEXTURE30                                    = 0x84DE
	TEXTURE31                                    = 0x84DF
	ACTIVE_TEXTURE                               = 0x84E0
	MAX_RENDERBUFFER_SIZE                        = 0x84E8
	INCR_WRAP                                    = 0x8507
	DECR_WRAP                                    = 0x8508
	TEXTURE_CUBE_MAP                             = 0x8513
	TEXTURE_BINDING_CUBE_MAP                     = 0x8514
	TEXTURE_CUBE_MAP_POSITIVE_X                  = 0x8515
	TEXTURE_CUBE_MAP_NEGATIVE_X                  = 0x8516
	TEXTURE_CUBE_MAP_POSITIVE_Y                  = 0x8517
	TEXTURE_CUBE_MAP_NEGATIVE_Y                  = 0x8518
	TEXTURE_CUBE_MAP_POSITIVE_Z                  = 0x8519
	TEXTURE_CUBE_MAP_NEGATIVE_Z                  = 0x851A
	MAX_CUBE_MAP_TEXTURE_SIZE                    = 0x851C
	VERTEX_ATTRIB_ARRAY_ENABLED                  = 0x8622
	VERTEX_ATTRIB_ARRAY_SIZE                     = 0x8623
	VERTEX_ATTRIB_ARRAY_STRIDE                   = 0x8624
	VERTEX_ATTRIB_ARRAY_TYPE                     = 0x8625
	CURRENT_VERTEX_ATTRIB                        = 0x8626
	VERTEX_ATTRIB_ARRAY_POINTER                  = 0x8645
	NUM_COMPRESSED_TEXTURE_FORMATS               = 0x86A2
	COMPRESSED_TEXTURE_FORMATS                   = 0x86A3
	BUFFER_SIZE                                  = 0x8764
	BUFFER_USAGE                                 = 0x8765
	STENCIL_BACK_FUNC                            = 0x8800
	STENCIL_BACK_FAIL                            = 0x8801
	STENCIL_BACK_PASS_DEPTH_FAIL                 = 0x8802
	STENCIL_BACK_PASS_DEPTH_PASS                 = 0x8803
	BLEND_EQUATION_ALPHA                         = 0x883D
	MAX_VERTEX_ATTRIBS                           = 0x8869
	VERTEX_ATTRIB_ARRAY_NORMALIZED               = 0x886A
	MAX_TEXTURE_IMAGE_UNITS                      = 0x8872
	ARRAY_BUFFER                                 = 0x8892
	ELEMENT_ARRAY_BUFFER                         = 0x8893
	ARRAY_BUFFER_BINDING                         = 0x8894
	ELEMENT_ARRAY_BUFFER_BINDING                 = 0x8895
	VERTEX_ATTRIB_ARRAY_BUFFER_BINDING           = 0x889F
	STREAM_DRAW                                  = 0x88E0
	STATIC_DRAW                                  = 0x88E4
	DYNAMIC_DRAW                                 = 0x88E8
	FRAGMENT_SHADER                              = 0x8B30
	VERTEX_SHADER                                = 0x8B31
	MAX_VERTEX_TEXTURE_IMAGE_UNITS               = 0x8B4C
	MAX_COMBINED_TEXTURE_IMAGE_UNITS             = 0x8B4D
	SHADER_TYPE                                  = 0x8B4F
	FLOAT_VEC2                                   = 0x8B50
	FLOAT_VEC3                                   = 0x8B51
	FLOAT_VEC4                                   = 0x8B52
	INT_VEC2                                     = 0x8B53
	INT_VEC3                                     = 0x8B54
	INT_VEC4                                     = 0x8B55
	BOOL                                         = 0x8B56
	BOOL_VEC2                                    = 0x8B57
	BOOL_VEC3                                    = 0x8B58
	BOOL_VEC4                                    = 0x8B59
	FLOAT_MAT2                                   = 0x8B5A
	FLOAT_MAT3                                   = 0x8B5B
	FLOAT_MAT4                                   = 0x8B5C
	SAMPLER_2D                                   = 0x8B5E
	SAMPLER_CUBE                                 = 0x8B60
	DELETE_STATUS                                = 0x8B80
	COMPILE_STATUS                               = 0x8B81
	LINK_STATUS                                  = 0x8B82
	VALIDATE_STATUS                              = 0x8B83
	INFO_LOG_LENGTH                              = 0x8B84
	ATTACHED_SHADERS                             = 0x8B85
	ACTIVE_UNIFORMS                              = 0x8B86
	ACTIVE_UNIFORM_MAX_LENGTH                    = 0x8B87
	SHADER_SOURCE_LENGTH                         = 0x8B88
	ACTIVE_ATTRIBUTES                            = 0x8B89
	ACTIVE_ATTRIBUTE_MAX_LENGTH                  = 0x8B8A
	SHADING_LANGUAGE_VERSION                     = 0x8B8C
	CURRENT_PROGRAM                              = 0x8B8D
	IMPLEMENTATION_COLOR_READ_TYPE               = 0x8B9A
	IMPLEMENTATION_COLOR_READ_FORMAT             = 0x8B9B
	STENCIL_BACK_REF                             = 0x8CA3
	STENCIL_BACK_VALUE_MASK                      = 0x8CA4
	STENCIL_BACK_WRITEMASK                       = 0x8CA5
	FRAMEBUFFER_BINDING                          = 0x8CA6
	RENDERBUFFER_BINDING                         = 0x8CA7
	FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE           = 0x8CD0
	FRAMEBUFFER_ATTACHMENT_OBJECT_NAME           = 0x8CD1
	FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL         = 0x8CD2
	FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3
	FRAMEBUFFER_COMPLETE                         = 0x8CD5
	FRAMEBUFFER_INCOMPLETE_ATTACHMENT            = 0x8CD6
	FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT    = 0x8CD7
	FRAMEBUFFER_INCOMPLETE_DIMENSIONS            = 0x8CD9
	FRAMEBUFFER_UNSUPPORTED                      = 0x8CDD
	COLOR_ATTACHMENT0                            = 0x8CE0
	DEPTH_ATTACHMENT                             = 0x8D00
	STENCIL_ATTACHMENT                           = 0x8D20
	FRAMEBUFFER                                  = 0x8D40
	RENDERBUFFER                                 = 0x8D41
	RENDERBUFFER_WIDTH                           = 0x8D42
	RENDERBUFFER_HEIGHT                          = 0x8D43
	RENDERBUFFER_INTERNAL_FORMAT                 = 0x8D44
	STENCIL_INDEX8                               = 0x8D48
	RENDERBUFFER_RED_SIZE                        = 0x8D50
	RENDERBUFFER_GREEN_SIZE                      = 0x8D51
	RENDERBUFFER_BLUE_SIZE                       = 0x8D52
	RENDERBUFFER_ALPHA_SIZE                      = 0x8D53
	RENDERBUFFER_DEPTH_SIZE                      = 0x8D54
	RENDERBUFFER_STENCIL_SIZE                    = 0x8D55
	RGB565                                       = 0x8D62
	LOW_FLOAT                                    = 0x8DF0
	MEDIUM_FLOAT                                 = 0x8DF1
	HIGH_FLOAT                                   = 0x8DF2
	LOW_INT                                      = 0x8DF3
	MEDIUM_INT                                   = 0x8DF4
	HIGH_INT                                     = 0x8DF5
	SHADER_BINARY_FORMATS                        = 0x8DF8
	NUM_SHADER_BINARY_FORMATS                    = 0x8DF9
	SHADER_COMPILER                              = 0x8DFA
	MAX_VERTEX_UNIFORM_VECTORS                   = 0x8DFB
	MAX_VARYING_VECTORS                          = 0x8DFC
	MAX_FRAGMENT_UNIFORM_VECTORS                 = 0x8DFD
)

// https://www.opengl.org/sdk/docs/man2/xhtml/glActiveTexture.xml
func (gl *GL) ActiveTexture(texture glbase.Enum) {
	C.gles2_glActiveTexture(gl.funcs, C.GLenum(texture))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glAttachShader.xml
func (gl *GL) AttachShader(program glbase.Program, shader glbase.Shader) {
	C.gles2_glAttachShader(gl.funcs, C.GLuint(program), C.GLuint(shader))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindAttribLocation.xml
func (gl *GL) BindAttribLocation(program glbase.Program, index uint32, name []byte) {
	C.gles2_glBindAttribLocation(gl.funcs, C.GLuint(program), C.GLuint(index), (*C.GLchar)(unsafe.Pointer(&name[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindBuffer.xml
func (gl *GL) BindBuffer(target glbase.Enum, buffer glbase.Buffer) {
	C.gles2_glBindBuffer(gl.funcs, C.GLenum(target), C.GLuint(buffer))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindFramebuffer.xml
func (gl *GL) BindFramebuffer(target glbase.Enum, framebuffer uint32) {
	C.gles2_glBindFramebuffer(gl.funcs, C.GLenum(target), C.GLuint(framebuffer))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindRenderbuffer.xml
func (gl *GL) BindRenderbuffer(target glbase.Enum, renderbuffer uint32) {
	C.gles2_glBindRenderbuffer(gl.funcs, C.GLenum(target), C.GLuint(renderbuffer))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBlendColor.xml
func (gl *GL) BlendColor(red, green, blue, alpha glbase.Clampf) {
	C.gles2_glBlendColor(gl.funcs, C.GLclampf(red), C.GLclampf(green), C.GLclampf(blue), C.GLclampf(alpha))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBlendEquation.xml
func (gl *GL) BlendEquation(mode glbase.Enum) {
	C.gles2_glBlendEquation(gl.funcs, C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBlendEquationSeparate.xml
func (gl *GL) BlendEquationSeparate(modeRGB, modeAlpha glbase.Enum) {
	C.gles2_glBlendEquationSeparate(gl.funcs, C.GLenum(modeRGB), C.GLenum(modeAlpha))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBlendFuncSeparate.xml
func (gl *GL) BlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha glbase.Enum) {
	C.gles2_glBlendFuncSeparate(gl.funcs, C.GLenum(srcRGB), C.GLenum(dstRGB), C.GLenum(srcAlpha), C.GLenum(dstAlpha))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBufferData.xml
func (gl *GL) BufferData(target glbase.Enum, size int, data interface{}, usage glbase.Enum) {
	data_v := reflect.ValueOf(data)
	if data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	C.gles2_glBufferData(gl.funcs, C.GLenum(target), C.GLsizeiptr(size), unsafe.Pointer(data_v.Index(0).Addr().Pointer()), C.GLenum(usage))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBufferSubData.xml
func (gl *GL) BufferSubData(target glbase.Enum, offset, size int, data interface{}) {
	data_v := reflect.ValueOf(data)
	if data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	C.gles2_glBufferSubData(gl.funcs, C.GLenum(target), C.GLintptr(offset), C.GLsizeiptr(size), unsafe.Pointer(data_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCheckFramebufferStatus.xml
func (gl *GL) CheckFramebufferStatus(target glbase.Enum) glbase.Enum {
	result := C.gles2_glCheckFramebufferStatus(gl.funcs, C.GLenum(target))
	return glbase.Enum(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClearDepthf.xml
func (gl *GL) ClearDepthf(depth glbase.Clampf) {
	C.gles2_glClearDepthf(gl.funcs, C.GLclampf(depth))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCompileShader.xml
func (gl *GL) CompileShader(shader glbase.Shader) {
	C.gles2_glCompileShader(gl.funcs, C.GLuint(shader))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCompressedTexImage2D.xml
func (gl *GL) CompressedTexImage2D(target glbase.Enum, level int32, internalformat glbase.Enum, width, height, border, imageSize int32, data interface{}) {
	data_v := reflect.ValueOf(data)
	if data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	C.gles2_glCompressedTexImage2D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLenum(internalformat), C.GLsizei(width), C.GLsizei(height), C.GLint(border), C.GLsizei(imageSize), unsafe.Pointer(data_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCompressedTexSubImage2D.xml
func (gl *GL) CompressedTexSubImage2D(target glbase.Enum, level, xoffset, yoffset, width, height int32, format glbase.Enum, imageSize int32, data interface{}) {
	data_v := reflect.ValueOf(data)
	if data_v.Kind() != reflect.Slice {
		panic("parameter data must be a slice")
	}
	C.gles2_glCompressedTexSubImage2D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLint(yoffset), C.GLsizei(width), C.GLsizei(height), C.GLenum(format), C.GLsizei(imageSize), unsafe.Pointer(data_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCreateProgram.xml
func (gl *GL) CreateProgram() glbase.Program {
	result := C.gles2_glCreateProgram(gl.funcs)
	return glbase.Program(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCreateShader.xml
func (gl *GL) CreateShader(gltype glbase.Enum) glbase.Shader {
	result := C.gles2_glCreateShader(gl.funcs, C.GLenum(gltype))
	return glbase.Shader(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteBuffers.xml
func (gl *GL) DeleteBuffers(n int32, buffers []uint32) {
	C.gles2_glDeleteBuffers(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&buffers[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteFramebuffers.xml
func (gl *GL) DeleteFramebuffers(n int32, framebuffers []uint32) {
	C.gles2_glDeleteFramebuffers(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&framebuffers[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteProgram.xml
func (gl *GL) DeleteProgram(program glbase.Program) {
	C.gles2_glDeleteProgram(gl.funcs, C.GLuint(program))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteRenderbuffers.xml
func (gl *GL) DeleteRenderbuffers(n int32, renderbuffers []uint32) {
	C.gles2_glDeleteRenderbuffers(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&renderbuffers[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteShader.xml
func (gl *GL) DeleteShader(shader glbase.Shader) {
	C.gles2_glDeleteShader(gl.funcs, C.GLuint(shader))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDepthRangef.xml
func (gl *GL) DepthRangef(zNear, zFar glbase.Clampf) {
	C.gles2_glDepthRangef(gl.funcs, C.GLclampf(zNear), C.GLclampf(zFar))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDetachShader.xml
func (gl *GL) DetachShader(program glbase.Program, shader glbase.Shader) {
	C.gles2_glDetachShader(gl.funcs, C.GLuint(program), C.GLuint(shader))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDisableVertexAttribArray.xml
func (gl *GL) DisableVertexAttribArray(index uint32) {
	C.gles2_glDisableVertexAttribArray(gl.funcs, C.GLuint(index))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEnableVertexAttribArray.xml
func (gl *GL) EnableVertexAttribArray(index uint32) {
	C.gles2_glEnableVertexAttribArray(gl.funcs, C.GLuint(index))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFramebufferRenderbuffer.xml
func (gl *GL) FramebufferRenderbuffer(target, attachment, renderbuffertarget glbase.Enum, renderbuffer uint32) {
	C.gles2_glFramebufferRenderbuffer(gl.funcs, C.GLenum(target), C.GLenum(attachment), C.GLenum(renderbuffertarget), C.GLuint(renderbuffer))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFramebufferTexture2D.xml
func (gl *GL) FramebufferTexture2D(target, attachment, textarget glbase.Enum, texture glbase.Texture, level int32) {
	C.gles2_glFramebufferTexture2D(gl.funcs, C.GLenum(target), C.GLenum(attachment), C.GLenum(textarget), C.GLuint(texture), C.GLint(level))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGenBuffers.xml
func (gl *GL) GenBuffers(n int32, buffers []uint32) {
	C.gles2_glGenBuffers(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&buffers[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGenerateMipmap.xml
func (gl *GL) GenerateMipmap(target glbase.Enum) {
	C.gles2_glGenerateMipmap(gl.funcs, C.GLenum(target))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGenFramebuffers.xml
func (gl *GL) GenFramebuffers(n int32, framebuffers []uint32) {
	C.gles2_glGenFramebuffers(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&framebuffers[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGenRenderbuffers.xml
func (gl *GL) GenRenderbuffers(n int32, renderbuffers []uint32) {
	C.gles2_glGenRenderbuffers(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&renderbuffers[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetActiveAttrib.xml
func (gl *GL) GetActiveAttrib(program glbase.Program, index uint32, bufsize int32, length, size []int32, gltype []glbase.Enum, name []byte) {
	C.gles2_glGetActiveAttrib(gl.funcs, C.GLuint(program), C.GLuint(index), C.GLsizei(bufsize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLint)(unsafe.Pointer(&size[0])), (*C.GLenum)(unsafe.Pointer(&gltype[0])), (*C.GLchar)(unsafe.Pointer(&name[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetActiveUniform.xml
func (gl *GL) GetActiveUniform(program glbase.Program, index uint32, bufsize int32, length, size []int32, gltype []glbase.Enum, name []byte) {
	C.gles2_glGetActiveUniform(gl.funcs, C.GLuint(program), C.GLuint(index), C.GLsizei(bufsize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLint)(unsafe.Pointer(&size[0])), (*C.GLenum)(unsafe.Pointer(&gltype[0])), (*C.GLchar)(unsafe.Pointer(&name[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetAttachedShaders.xml
func (gl *GL) GetAttachedShaders(program glbase.Program, maxcount int32, count []int32, shaders []uint32) {
	C.gles2_glGetAttachedShaders(gl.funcs, C.GLuint(program), C.GLsizei(maxcount), (*C.GLsizei)(unsafe.Pointer(&count[0])), (*C.GLuint)(unsafe.Pointer(&shaders[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetAttribLocation.xml
func (gl *GL) GetAttribLocation(program glbase.Program, name []byte) int32 {
	result := C.gles2_glGetAttribLocation(gl.funcs, C.GLuint(program), (*C.GLchar)(unsafe.Pointer(&name[0])))
	return int32(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetBufferParameteriv.xml
func (gl *GL) GetBufferParameteriv(target, pname glbase.Enum, params []int32) {
	C.gles2_glGetBufferParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetFramebufferAttachmentParameteriv.xml
func (gl *GL) GetFramebufferAttachmentParameteriv(target, attachment, pname glbase.Enum, params []int32) {
	C.gles2_glGetFramebufferAttachmentParameteriv(gl.funcs, C.GLenum(target), C.GLenum(attachment), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetProgramiv.xml
func (gl *GL) GetProgramiv(program glbase.Program, pname glbase.Enum, params []int32) {
	C.gles2_glGetProgramiv(gl.funcs, C.GLuint(program), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetProgramInfoLog.xml
func (gl *GL) GetProgramInfoLog(program glbase.Program, bufsize int32, length []int32, infolog []byte) {
	C.gles2_glGetProgramInfoLog(gl.funcs, C.GLuint(program), C.GLsizei(bufsize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLchar)(unsafe.Pointer(&infolog[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetRenderbufferParameteriv.xml
func (gl *GL) GetRenderbufferParameteriv(target, pname glbase.Enum, params []int32) {
	C.gles2_glGetRenderbufferParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetShaderiv.xml
func (gl *GL) GetShaderiv(shader glbase.Shader, pname glbase.Enum, params []int32) {
	C.gles2_glGetShaderiv(gl.funcs, C.GLuint(shader), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetShaderInfoLog.xml
func (gl *GL) GetShaderInfoLog(shader glbase.Shader, bufsize int32, length []int32, infolog []byte) {
	C.gles2_glGetShaderInfoLog(gl.funcs, C.GLuint(shader), C.GLsizei(bufsize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLchar)(unsafe.Pointer(&infolog[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetShaderPrecisionFormat.xml
func (gl *GL) GetShaderPrecisionFormat(shadertype, precisiontype glbase.Enum, range_, precision []int32) {
	C.gles2_glGetShaderPrecisionFormat(gl.funcs, C.GLenum(shadertype), C.GLenum(precisiontype), (*C.GLint)(unsafe.Pointer(&range_[0])), (*C.GLint)(unsafe.Pointer(&precision[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetShaderSource.xml
func (gl *GL) GetShaderSource(shader glbase.Shader, bufsize int32, length []int32, source []byte) {
	C.gles2_glGetShaderSource(gl.funcs, C.GLuint(shader), C.GLsizei(bufsize), (*C.GLsizei)(unsafe.Pointer(&length[0])), (*C.GLchar)(unsafe.Pointer(&source[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetUniformfv.xml
func (gl *GL) GetUniformfv(program glbase.Program, location glbase.Uniform, params []float32) {
	C.gles2_glGetUniformfv(gl.funcs, C.GLuint(program), C.GLint(location), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetUniformiv.xml
func (gl *GL) GetUniformiv(program glbase.Program, location glbase.Uniform, params []int32) {
	C.gles2_glGetUniformiv(gl.funcs, C.GLuint(program), C.GLint(location), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetUniformLocation.xml
func (gl *GL) GetUniformLocation(program glbase.Program, name []byte) int32 {
	result := C.gles2_glGetUniformLocation(gl.funcs, C.GLuint(program), (*C.GLchar)(unsafe.Pointer(&name[0])))
	return int32(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetVertexAttribfv.xml
func (gl *GL) GetVertexAttribfv(index uint32, pname glbase.Enum, params []float32) {
	C.gles2_glGetVertexAttribfv(gl.funcs, C.GLuint(index), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetVertexAttribiv.xml
func (gl *GL) GetVertexAttribiv(index uint32, pname glbase.Enum, params []int32) {
	C.gles2_glGetVertexAttribiv(gl.funcs, C.GLuint(index), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsBuffer.xml
func (gl *GL) IsBuffer(buffer glbase.Buffer) glbase.Boolean {
	result := C.gles2_glIsBuffer(gl.funcs, C.GLuint(buffer))
	return glbase.Boolean(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsFramebuffer.xml
func (gl *GL) IsFramebuffer(framebuffer uint32) glbase.Boolean {
	result := C.gles2_glIsFramebuffer(gl.funcs, C.GLuint(framebuffer))
	return glbase.Boolean(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsProgram.xml
func (gl *GL) IsProgram(program glbase.Program) glbase.Boolean {
	result := C.gles2_glIsProgram(gl.funcs, C.GLuint(program))
	return glbase.Boolean(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsRenderbuffer.xml
func (gl *GL) IsRenderbuffer(renderbuffer uint32) glbase.Boolean {
	result := C.gles2_glIsRenderbuffer(gl.funcs, C.GLuint(renderbuffer))
	return glbase.Boolean(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsShader.xml
func (gl *GL) IsShader(shader glbase.Shader) glbase.Boolean {
	result := C.gles2_glIsShader(gl.funcs, C.GLuint(shader))
	return glbase.Boolean(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glLinkProgram.xml
func (gl *GL) LinkProgram(program glbase.Program) {
	C.gles2_glLinkProgram(gl.funcs, C.GLuint(program))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glReleaseShaderCompiler.xml
func (gl *GL) ReleaseShaderCompiler() {
	C.gles2_glReleaseShaderCompiler(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glRenderbufferStorage.xml
func (gl *GL) RenderbufferStorage(target, internalformat glbase.Enum, width, height int32) {
	C.gles2_glRenderbufferStorage(gl.funcs, C.GLenum(target), C.GLenum(internalformat), C.GLsizei(width), C.GLsizei(height))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glSampleCoverage.xml
func (gl *GL) SampleCoverage(value glbase.Clampf, invert glbase.Boolean) {
	C.gles2_glSampleCoverage(gl.funcs, C.GLclampf(value), C.GLboolean(invert))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glShaderBinary.xml
func (gl *GL) ShaderBinary(n int32, shaders []uint32, binaryformat glbase.Enum, binary interface{}, length int32) {
	binary_v := reflect.ValueOf(binary)
	if binary_v.Kind() != reflect.Slice {
		panic("parameter binary must be a slice")
	}
	C.gles2_glShaderBinary(gl.funcs, C.GLint(n), (*C.GLuint)(unsafe.Pointer(&shaders[0])), C.GLenum(binaryformat), unsafe.Pointer(binary_v.Index(0).Addr().Pointer()), C.GLint(length))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glShaderSource.xml
func (gl *GL) ShaderSource(shader glbase.Shader, source ...string) {
	count := len(source)
	length := make([]int32, count)
	glstring := make([]unsafe.Pointer, count)
	for i, src := range source {
		length[i] = int32(len(src))
		if len(src) > 0 {
			glstring[i] = *(*unsafe.Pointer)(unsafe.Pointer(&src))
		} else {
			glstring[i] = unsafe.Pointer(uintptr(0))
		}
	}
	C.gles2_glShaderSource(gl.funcs, C.GLuint(shader), C.GLsizei(count), (**C.GLchar)(unsafe.Pointer(&glstring[0])), (*C.GLint)(unsafe.Pointer(&length[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glStencilFuncSeparate.xml
func (gl *GL) StencilFuncSeparate(face, glfunc glbase.Enum, ref int32, mask uint32) {
	C.gles2_glStencilFuncSeparate(gl.funcs, C.GLenum(face), C.GLenum(glfunc), C.GLint(ref), C.GLuint(mask))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glStencilMaskSeparate.xml
func (gl *GL) StencilMaskSeparate(face glbase.Enum, mask uint32) {
	C.gles2_glStencilMaskSeparate(gl.funcs, C.GLenum(face), C.GLuint(mask))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glStencilOpSeparate.xml
func (gl *GL) StencilOpSeparate(face, fail, zfail, zpass glbase.Enum) {
	C.gles2_glStencilOpSeparate(gl.funcs, C.GLenum(face), C.GLenum(fail), C.GLenum(zfail), C.GLenum(zpass))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform1f.xml
func (gl *GL) Uniform1f(location glbase.Uniform, x float32) {
	C.gles2_glUniform1f(gl.funcs, C.GLint(location), C.GLfloat(x))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform1fv.xml
func (gl *GL) Uniform1fv(location glbase.Uniform, count int32, v []float32) {
	C.gles2_glUniform1fv(gl.funcs, C.GLint(location), C.GLsizei(count), (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform1i.xml
func (gl *GL) Uniform1i(location glbase.Uniform, x int32) {
	C.gles2_glUniform1i(gl.funcs, C.GLint(location), C.GLint(x))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform1iv.xml
func (gl *GL) Uniform1iv(location glbase.Uniform, count int32, v []int32) {
	C.gles2_glUniform1iv(gl.funcs, C.GLint(location), C.GLsizei(count), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform2f.xml
func (gl *GL) Uniform2f(location glbase.Uniform, x, y float32) {
	C.gles2_glUniform2f(gl.funcs, C.GLint(location), C.GLfloat(x), C.GLfloat(y))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform2fv.xml
func (gl *GL) Uniform2fv(location glbase.Uniform, count int32, v []float32) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gles2_glUniform2fv(gl.funcs, C.GLint(location), C.GLsizei(count), (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform2i.xml
func (gl *GL) Uniform2i(location glbase.Uniform, x, y int32) {
	C.gles2_glUniform2i(gl.funcs, C.GLint(location), C.GLint(x), C.GLint(y))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform2iv.xml
func (gl *GL) Uniform2iv(location glbase.Uniform, count int32, v []int32) {
	if len(v) != 2 {
		panic("parameter v has incorrect length")
	}
	C.gles2_glUniform2iv(gl.funcs, C.GLint(location), C.GLsizei(count), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform3f.xml
func (gl *GL) Uniform3f(location glbase.Uniform, x, y, z float32) {
	C.gles2_glUniform3f(gl.funcs, C.GLint(location), C.GLfloat(x), C.GLfloat(y), C.GLfloat(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform3fv.xml
func (gl *GL) Uniform3fv(location glbase.Uniform, count int32, v []float32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gles2_glUniform3fv(gl.funcs, C.GLint(location), C.GLsizei(count), (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform3i.xml
func (gl *GL) Uniform3i(location glbase.Uniform, x, y, z int32) {
	C.gles2_glUniform3i(gl.funcs, C.GLint(location), C.GLint(x), C.GLint(y), C.GLint(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform3iv.xml
func (gl *GL) Uniform3iv(location glbase.Uniform, count int32, v []int32) {
	if len(v) != 3 {
		panic("parameter v has incorrect length")
	}
	C.gles2_glUniform3iv(gl.funcs, C.GLint(location), C.GLsizei(count), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform4f.xml
func (gl *GL) Uniform4f(location glbase.Uniform, x, y, z, w float32) {
	C.gles2_glUniform4f(gl.funcs, C.GLint(location), C.GLfloat(x), C.GLfloat(y), C.GLfloat(z), C.GLfloat(w))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform4fv.xml
func (gl *GL) Uniform4fv(location glbase.Uniform, count int32, v []float32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gles2_glUniform4fv(gl.funcs, C.GLint(location), C.GLsizei(count), (*C.GLfloat)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform4i.xml
func (gl *GL) Uniform4i(location glbase.Uniform, x, y, z, w int32) {
	C.gles2_glUniform4i(gl.funcs, C.GLint(location), C.GLint(x), C.GLint(y), C.GLint(z), C.GLint(w))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniform4iv.xml
func (gl *GL) Uniform4iv(location glbase.Uniform, count int32, v []int32) {
	if len(v) != 4 {
		panic("parameter v has incorrect length")
	}
	C.gles2_glUniform4iv(gl.funcs, C.GLint(location), C.GLsizei(count), (*C.GLint)(unsafe.Pointer(&v[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniformMatrix2fv.xml
func (gl *GL) UniformMatrix2fv(location glbase.Uniform, count int32, transpose glbase.Boolean, value []float32) {
	if len(value) != 2 {
		panic("parameter value has incorrect length")
	}
	C.gles2_glUniformMatrix2fv(gl.funcs, C.GLint(location), C.GLsizei(count), C.GLboolean(transpose), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniformMatrix3fv.xml
func (gl *GL) UniformMatrix3fv(location glbase.Uniform, count int32, transpose glbase.Boolean, value []float32) {
	if len(value) != 3 {
		panic("parameter value has incorrect length")
	}
	C.gles2_glUniformMatrix3fv(gl.funcs, C.GLint(location), C.GLsizei(count), C.GLboolean(transpose), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUniformMatrix4fv.xml
func (gl *GL) UniformMatrix4fv(location glbase.Uniform, count int32, transpose glbase.Boolean, value []float32) {
	if len(value) != 4 {
		panic("parameter value has incorrect length")
	}
	C.gles2_glUniformMatrix4fv(gl.funcs, C.GLint(location), C.GLsizei(count), C.GLboolean(transpose), (*C.GLfloat)(unsafe.Pointer(&value[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glUseProgram.xml
func (gl *GL) UseProgram(program glbase.Program) {
	C.gles2_glUseProgram(gl.funcs, C.GLuint(program))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glValidateProgram.xml
func (gl *GL) ValidateProgram(program glbase.Program) {
	C.gles2_glValidateProgram(gl.funcs, C.GLuint(program))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib1f.xml
func (gl *GL) VertexAttrib1f(indx uint32, x float32) {
	C.gles2_glVertexAttrib1f(gl.funcs, C.GLuint(indx), C.GLfloat(x))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib1fv.xml
func (gl *GL) VertexAttrib1fv(indx uint32, values []float32) {
	C.gles2_glVertexAttrib1fv(gl.funcs, C.GLuint(indx), (*C.GLfloat)(unsafe.Pointer(&values[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib2f.xml
func (gl *GL) VertexAttrib2f(indx uint32, x, y float32) {
	C.gles2_glVertexAttrib2f(gl.funcs, C.GLuint(indx), C.GLfloat(x), C.GLfloat(y))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib2fv.xml
func (gl *GL) VertexAttrib2fv(indx uint32, values []float32) {
	if len(values) != 2 {
		panic("parameter values has incorrect length")
	}
	C.gles2_glVertexAttrib2fv(gl.funcs, C.GLuint(indx), (*C.GLfloat)(unsafe.Pointer(&values[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib3f.xml
func (gl *GL) VertexAttrib3f(indx uint32, x, y, z float32) {
	C.gles2_glVertexAttrib3f(gl.funcs, C.GLuint(indx), C.GLfloat(x), C.GLfloat(y), C.GLfloat(z))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib3fv.xml
func (gl *GL) VertexAttrib3fv(indx uint32, values []float32) {
	if len(values) != 3 {
		panic("parameter values has incorrect length")
	}
	C.gles2_glVertexAttrib3fv(gl.funcs, C.GLuint(indx), (*C.GLfloat)(unsafe.Pointer(&values[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib4f.xml
func (gl *GL) VertexAttrib4f(indx uint32, x, y, z, w float32) {
	C.gles2_glVertexAttrib4f(gl.funcs, C.GLuint(indx), C.GLfloat(x), C.GLfloat(y), C.GLfloat(z), C.GLfloat(w))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttrib4fv.xml
func (gl *GL) VertexAttrib4fv(indx uint32, values []float32) {
	if len(values) != 4 {
		panic("parameter values has incorrect length")
	}
	C.gles2_glVertexAttrib4fv(gl.funcs, C.GLuint(indx), (*C.GLfloat)(unsafe.Pointer(&values[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glVertexAttribPointer.xml
func (gl *GL) VertexAttribPointer(indx uint32, size int32, gltype glbase.Enum, normalized glbase.Boolean, stride int32, ptr interface{}) {
	ptr_v := reflect.ValueOf(ptr)
	if ptr_v.Kind() != reflect.Slice {
		panic("parameter ptr must be a slice")
	}
	C.gles2_glVertexAttribPointer(gl.funcs, C.GLuint(indx), C.GLint(size), C.GLenum(gltype), C.GLboolean(normalized), C.GLsizei(stride), unsafe.Pointer(ptr_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBindTexture.xml
func (gl *GL) BindTexture(target glbase.Enum, texture glbase.Texture) {
	C.gles2_glBindTexture(gl.funcs, C.GLenum(target), C.GLuint(texture))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glBlendFunc.xml
func (gl *GL) BlendFunc(sfactor, dfactor glbase.Enum) {
	C.gles2_glBlendFunc(gl.funcs, C.GLenum(sfactor), C.GLenum(dfactor))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClear.xml
func (gl *GL) Clear(mask glbase.Bitfield) {
	C.gles2_glClear(gl.funcs, C.GLbitfield(mask))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClearColor.xml
func (gl *GL) ClearColor(red, green, blue, alpha glbase.Clampf) {
	C.gles2_glClearColor(gl.funcs, C.GLclampf(red), C.GLclampf(green), C.GLclampf(blue), C.GLclampf(alpha))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glClearStencil.xml
func (gl *GL) ClearStencil(s int32) {
	C.gles2_glClearStencil(gl.funcs, C.GLint(s))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glColorMask.xml
func (gl *GL) ColorMask(red, green, blue, alpha glbase.Boolean) {
	C.gles2_glColorMask(gl.funcs, C.GLboolean(red), C.GLboolean(green), C.GLboolean(blue), C.GLboolean(alpha))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCopyTexImage2D.xml
func (gl *GL) CopyTexImage2D(target glbase.Enum, level int32, internalformat glbase.Enum, x, y, width, height, border int32) {
	C.gles2_glCopyTexImage2D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLenum(internalformat), C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height), C.GLint(border))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCopyTexSubImage2D.xml
func (gl *GL) CopyTexSubImage2D(target glbase.Enum, level, xoffset, yoffset, x, y, width, height int32) {
	C.gles2_glCopyTexSubImage2D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLint(yoffset), C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glCullFace.xml
func (gl *GL) CullFace(mode glbase.Enum) {
	C.gles2_glCullFace(gl.funcs, C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDeleteTextures.xml
func (gl *GL) DeleteTextures(n int32, textures []uint32) {
	C.gles2_glDeleteTextures(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&textures[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDepthFunc.xml
func (gl *GL) DepthFunc(glfunc glbase.Enum) {
	C.gles2_glDepthFunc(gl.funcs, C.GLenum(glfunc))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDepthMask.xml
func (gl *GL) DepthMask(flag glbase.Boolean) {
	C.gles2_glDepthMask(gl.funcs, C.GLboolean(flag))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDisable.xml
func (gl *GL) Disable(cap glbase.Enum) {
	C.gles2_glDisable(gl.funcs, C.GLenum(cap))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawArrays.xml
func (gl *GL) DrawArrays(mode glbase.Enum, first, count int32) {
	C.gles2_glDrawArrays(gl.funcs, C.GLenum(mode), C.GLint(first), C.GLsizei(count))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glDrawElements.xml
func (gl *GL) DrawElements(mode glbase.Enum, count int32, gltype glbase.Enum, indices interface{}) {
	indices_v := reflect.ValueOf(indices)
	if indices_v.Kind() != reflect.Slice {
		panic("parameter indices must be a slice")
	}
	C.gles2_glDrawElements(gl.funcs, C.GLenum(mode), C.GLsizei(count), C.GLenum(gltype), unsafe.Pointer(indices_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glEnable.xml
func (gl *GL) Enable(cap glbase.Enum) {
	C.gles2_glEnable(gl.funcs, C.GLenum(cap))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFinish.xml
func (gl *GL) Finish() {
	C.gles2_glFinish(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFlush.xml
func (gl *GL) Flush() {
	C.gles2_glFlush(gl.funcs)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glFrontFace.xml
func (gl *GL) FrontFace(mode glbase.Enum) {
	C.gles2_glFrontFace(gl.funcs, C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGenTextures.xml
func (gl *GL) GenTextures(n int32, textures []uint32) {
	C.gles2_glGenTextures(gl.funcs, C.GLsizei(n), (*C.GLuint)(unsafe.Pointer(&textures[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetBooleanv.xml
func (gl *GL) GetBooleanv(pname glbase.Enum, params []glbase.Boolean) {
	C.gles2_glGetBooleanv(gl.funcs, C.GLenum(pname), (*C.GLboolean)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetError.xml
func (gl *GL) GetError() glbase.Enum {
	result := C.gles2_glGetError(gl.funcs)
	return glbase.Enum(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetFloatv.xml
func (gl *GL) GetFloatv(pname glbase.Enum, params []float32) {
	C.gles2_glGetFloatv(gl.funcs, C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetIntegerv.xml
func (gl *GL) GetIntegerv(pname glbase.Enum, params []int32) {
	C.gles2_glGetIntegerv(gl.funcs, C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetTexParameterfv.xml
func (gl *GL) GetTexParameterfv(target, pname glbase.Enum, params []float32) {
	C.gles2_glGetTexParameterfv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glGetTexParameteriv.xml
func (gl *GL) GetTexParameteriv(target, pname glbase.Enum, params []int32) {
	C.gles2_glGetTexParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glHint.xml
func (gl *GL) Hint(target, mode glbase.Enum) {
	C.gles2_glHint(gl.funcs, C.GLenum(target), C.GLenum(mode))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsEnabled.xml
func (gl *GL) IsEnabled(cap glbase.Enum) glbase.Boolean {
	result := C.gles2_glIsEnabled(gl.funcs, C.GLenum(cap))
	return glbase.Boolean(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glIsTexture.xml
func (gl *GL) IsTexture(texture glbase.Texture) glbase.Boolean {
	result := C.gles2_glIsTexture(gl.funcs, C.GLuint(texture))
	return glbase.Boolean(result)
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glLineWidth.xml
func (gl *GL) LineWidth(width float32) {
	C.gles2_glLineWidth(gl.funcs, C.GLfloat(width))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPixelStorei.xml
func (gl *GL) PixelStorei(pname glbase.Enum, param int32) {
	C.gles2_glPixelStorei(gl.funcs, C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glPolygonOffset.xml
func (gl *GL) PolygonOffset(factor, units float32) {
	C.gles2_glPolygonOffset(gl.funcs, C.GLfloat(factor), C.GLfloat(units))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glReadPixels.xml
func (gl *GL) ReadPixels(x, y, width, height int32, format, gltype glbase.Enum, pixels interface{}) {
	pixels_v := reflect.ValueOf(pixels)
	if pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	C.gles2_glReadPixels(gl.funcs, C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(pixels_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glScissor.xml
func (gl *GL) Scissor(x, y, width, height int32) {
	C.gles2_glScissor(gl.funcs, C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glStencilFunc.xml
func (gl *GL) StencilFunc(glfunc glbase.Enum, ref int32, mask uint32) {
	C.gles2_glStencilFunc(gl.funcs, C.GLenum(glfunc), C.GLint(ref), C.GLuint(mask))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glStencilMask.xml
func (gl *GL) StencilMask(mask uint32) {
	C.gles2_glStencilMask(gl.funcs, C.GLuint(mask))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glStencilOp.xml
func (gl *GL) StencilOp(fail, zfail, zpass glbase.Enum) {
	C.gles2_glStencilOp(gl.funcs, C.GLenum(fail), C.GLenum(zfail), C.GLenum(zpass))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexImage2D.xml
func (gl *GL) TexImage2D(target glbase.Enum, level, internalformat, width, height, border int32, format, gltype glbase.Enum, pixels interface{}) {
	pixels_v := reflect.ValueOf(pixels)
	if pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	C.gles2_glTexImage2D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(internalformat), C.GLsizei(width), C.GLsizei(height), C.GLint(border), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(pixels_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexParameterf.xml
func (gl *GL) TexParameterf(target, pname glbase.Enum, param float32) {
	C.gles2_glTexParameterf(gl.funcs, C.GLenum(target), C.GLenum(pname), C.GLfloat(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexParameterfv.xml
func (gl *GL) TexParameterfv(target, pname glbase.Enum, params []float32) {
	C.gles2_glTexParameterfv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLfloat)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexParameteri.xml
func (gl *GL) TexParameteri(target, pname glbase.Enum, param int32) {
	C.gles2_glTexParameteri(gl.funcs, C.GLenum(target), C.GLenum(pname), C.GLint(param))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexParameteriv.xml
func (gl *GL) TexParameteriv(target, pname glbase.Enum, params []int32) {
	C.gles2_glTexParameteriv(gl.funcs, C.GLenum(target), C.GLenum(pname), (*C.GLint)(unsafe.Pointer(&params[0])))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glTexSubImage2D.xml
func (gl *GL) TexSubImage2D(target glbase.Enum, level, xoffset, yoffset, width, height int32, format, gltype glbase.Enum, pixels interface{}) {
	pixels_v := reflect.ValueOf(pixels)
	if pixels_v.Kind() != reflect.Slice {
		panic("parameter pixels must be a slice")
	}
	C.gles2_glTexSubImage2D(gl.funcs, C.GLenum(target), C.GLint(level), C.GLint(xoffset), C.GLint(yoffset), C.GLsizei(width), C.GLsizei(height), C.GLenum(format), C.GLenum(gltype), unsafe.Pointer(pixels_v.Index(0).Addr().Pointer()))
}

// https://www.opengl.org/sdk/docs/man2/xhtml/glViewport.xml
func (gl *GL) Viewport(x, y, width, height int32) {
	C.gles2_glViewport(gl.funcs, C.GLint(x), C.GLint(y), C.GLsizei(width), C.GLsizei(height))
}
